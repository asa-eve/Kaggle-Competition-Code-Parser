notebook_name,notebook_url,public_score,private_score,medal,upvotes,views,run_time_info,last_updated,notebook_full_text,code_text,markdowns_text,input_datasources,python_libraries,LLM_summarized_code
AIMO Zero-Shot SC MMOS-DeepSeekMath,https://www.kaggle.com/code/olyatsimboy/aimo-zero-shot-sc-mmos-deepseekmath,13.0,,gold,281,11350,1623.1s - GPU T4 x2,2 months,"# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    BitsAndBytesConfig, 
    AutoConfig,
    set_seed
)

set_seed(42)

MODEL_PATH = ""/kaggle/input/deepseek-math""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map=""auto"",
    torch_dtype=""auto"",
    trust_remote_code=True,
#     quantization_config=quantization_config,
    config=config
)
model.dtype
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import transformers

pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=""auto"",
)
print(f""Transformers Version: {transformers.__version__}"")
import torch

torch.backends.cuda.enable_mem_efficient_sdp(False)
import re
import sys
import subprocess


def process_output(output):
    result = output
    
    try:
        code = output.split('```')[1][7:]

        with open('code.py', 'w') as fout:
            fout.write(code)

        batcmd = 'timeout 7 ' + sys.executable + ' code.py'
        try:
            shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
            print(shell_output)
            code_output = round(float(eval(shell_output))) % 1000
        except:
            code_output = -1

        print('CODE RESULTS', code_output)
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        code_output = -1
    
    try:
        result_output = re.findall(r'\\boxed\{(.*)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        result_output = -1
    
    return result_output, code_output
import re
from collections import defaultdict


tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'


n_repetitions = 5 if PRIVATE else 2

total_results = []
total_answers = []

for i in tqdm(range(len(df))):
    id_ = df['id'].loc[i]
    problem = df['problem'].loc[i]
    
    messages = [
        {
            ""role"": ""user"", 
            ""content"": problem + tool_instruction
        }
    ]
    
    query_prompt = tokenizer.apply_chat_template(
        messages,
        tokenize=False
    )
    
    results = []
    answers = []
    
    for _ in tqdm(range(n_repetitions)):
        try:
            raw_output = pipeline(
                query_prompt, 
                max_new_tokens=2048, 
                do_sample=True, 
                temperature=0.7,
                return_full_text=False
            )
            raw_output = raw_output[0]['generated_text']

            result_output, code_output = process_output(raw_output)

            torch.cuda.empty_cache()
            gc.collect()

        except Exception as e:
            print(e)
            result_output, code_output = -1, -1
        
        results.append(result_output)
        answers.append(code_output)
    
    total_results.append(results)
    total_answers.append(answers)
import numpy as np
from collections import Counter

final_answers = []

for a, b in zip(total_answers, total_results):
    a = np.array(a)
    b = np.array(b)
    a[a < 0] = b[a < 0]
    
    pred = Counter(a.tolist()).most_common(2)

    ans = pred[0][0] if not pred[0][0] < 0 else pred[1][0]

    final_answers.append(ans)
    print(ans)

df['answer'] = final_answers
df
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = final_answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')

","# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    BitsAndBytesConfig, 
    AutoConfig,
    set_seed
)

set_seed(42)

MODEL_PATH = ""/kaggle/input/deepseek-math""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map=""auto"",
    torch_dtype=""auto"",
    trust_remote_code=True,
#     quantization_config=quantization_config,
    config=config
)
model.dtype
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import transformers

pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=""auto"",
)
print(f""Transformers Version: {transformers.__version__}"")
import torch

torch.backends.cuda.enable_mem_efficient_sdp(False)
import re
import sys
import subprocess


def process_output(output):
    result = output
    
    try:
        code = output.split('```')[1][7:]

        with open('code.py', 'w') as fout:
            fout.write(code)

        batcmd = 'timeout 7 ' + sys.executable + ' code.py'
        try:
            shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
            print(shell_output)
            code_output = round(float(eval(shell_output))) % 1000
        except:
            code_output = -1

        print('CODE RESULTS', code_output)
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        code_output = -1
    
    try:
        result_output = re.findall(r'\\boxed\{(.*)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        result_output = -1
    
    return result_output, code_output
import re
from collections import defaultdict


tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'


n_repetitions = 5 if PRIVATE else 2

total_results = []
total_answers = []

for i in tqdm(range(len(df))):
    id_ = df['id'].loc[i]
    problem = df['problem'].loc[i]
    
    messages = [
        {
            ""role"": ""user"", 
            ""content"": problem + tool_instruction
        }
    ]
    
    query_prompt = tokenizer.apply_chat_template(
        messages,
        tokenize=False
    )
    
    results = []
    answers = []
    
    for _ in tqdm(range(n_repetitions)):
        try:
            raw_output = pipeline(
                query_prompt, 
                max_new_tokens=2048, 
                do_sample=True, 
                temperature=0.7,
                return_full_text=False
            )
            raw_output = raw_output[0]['generated_text']

            result_output, code_output = process_output(raw_output)

            torch.cuda.empty_cache()
            gc.collect()

        except Exception as e:
            print(e)
            result_output, code_output = -1, -1
        
        results.append(result_output)
        answers.append(code_output)
    
    total_results.append(results)
    total_answers.append(answers)
import numpy as np
from collections import Counter

final_answers = []

for a, b in zip(total_answers, total_results):
    a = np.array(a)
    b = np.array(b)
    a[a < 0] = b[a < 0]
    
    pred = Counter(a.tolist()).most_common(2)

    ans = pred[0][0] if not pred[0][0] < 0 else pred[1][0]

    final_answers.append(ans)
    print(ans)

df['answer'] = final_answers
df
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = final_answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')

","# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
","['AI Mathematical Olympiad - Progress Prize 1', 'bitsandbytes-0.42.0-py3-none-any.whl', 'deepseek-math', 'open-math-mistral']","['torch', 'transformers', 'pandas', 'tqdm', 'gc', 're', 'sys', 'subprocess', 'collections', 'numpy']","Here is a summary of the unique aspects of this Machine Learning code written in Python:

1. **Pre-trained Model**: The code uses the `AutoModelForCausalLM` pre-trained model from the Hugging Face Transformers library to perform text generation tasks.
2. **Custom Pipeline**: A custom pipeline is created using the `transformers.pipeline` function, which integrates the pre-trained model with a tokenizer and performs text-to-text generation tasks.
3. **CUDA Support**: The code uses CUDA acceleration for GPU-based computations using the PyTorch backend.
4. **Memory-Efficient SDP**: The code enables memory-efficient sparse differentiated programming (SDP) using the `torch.backends.cuda.enable_mem_efficient_sdp` function, which helps to reduce memory usage and improve performance.
5. **Regular Expressions**: The code uses regular expressions (regex) to parse and extract specific patterns from generated text output.
6. **Subprocess Execution**: The code uses the `subprocess` module to execute shell commands and capture their output, which is used to generate code results.
7. **Error Handling**: The code includes try-except blocks to handle errors and exceptions during processing and execution of code.
8. **Data Processing**: The code processes a CSV file containing mathematical problems and answers using the Pandas library and performs data manipulation tasks such as filtering and grouping.
9. **Natural Language Reasoning**: The code integrates natural language reasoning with programming to solve mathematical problems, which is used to generate answers for each problem.
10. **Submission Generation**: The code generates a submission CSV file containing the predicted answers and their corresponding IDs.

Overall, this code demonstrates advanced techniques in machine learning, natural language processing, and data processing, particularly in the context of solving mathematical problems using pre-trained models and custom pipelines."
Improved Code Interpretation,https://www.kaggle.com/code/abdurrafae/improved-code-interpretation,20.0,,gold,189,10472,51.1s - GPU T4 x2,1 month,"## Forked From  https://kaggle.com/code/xiaoz259/pure-rng/notebook


# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
import time

NOTEBOOK_START_TIME = time.time()
TO-DO

Change temperature as the question goes longer
Change temperature based on question lenght
# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
DEBUG = False

QUANT = False

if QUANT:
    from transformers import BitsAndBytesConfig
    quantization_config = BitsAndBytesConfig(
        load_in_4bit = True,
        bnb_4bit_quant_type=""nf4"",
        bnb_4bit_compute_dtype=torch.bfloat16,
        bnb_4bit_use_double_quant=True,
    )

USE_PAST_KEY = True
%%time
if QUANT:
    !pip install -U /kaggle/input/accelerate-wheelwhl/accelerate-0.29.1-py3-none-any.whl -qq
    !pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq


import torch
import gc
torch.backends.cuda.enable_mem_efficient_sdp(False)

from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    AutoConfig,
    StoppingCriteria,
    set_seed
)

import transformers
print(f""Transformers Version: {transformers.__version__}"")
set_seed(42)
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import re
import sys
import subprocess

def return_last_print(output, n):
    lines = output.strip().split('\n')
    if lines:
        return lines[n]
    else:
        return """"

def process_code(code, return_shell_output=False):
    
    def repl(match):
        if ""real"" not in match.group():
            return ""{}{}"".format(match.group()[:-1], ', real=True)')
        else:
            return ""{}{}"".format(match.group()[:-1], ')')
    code = re.sub(r""symbols\([^)]+\)"", repl, code)

    if return_shell_output:
        code = code.replace('\n', '\n    ')
            # Add a try...except block
        code = ""\ntry:\n    from sympy import *\n{}\nexcept Exception as e:\n    print(e)\n    print('FAIL')\n"".format(code)
    
    if not return_shell_output:
        print(code)
    with open('code.py', 'w') as fout:
        fout.write(code)
    
    batcmd = 'timeout 7 ' + sys.executable + ' code.py'
    try:
        shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
        return_value = return_last_print(shell_output, -1)
        print(shell_output)
        if return_shell_output:
            if return_value=='FAIL':
                CODE_STATUS = False
                return_value = return_last_print(shell_output, -2)
                if ""not defined"" in return_value:
                    return_value+='\nTry checking the formatting and imports'
            else:
                CODE_STATUS = True
            return return_value, CODE_STATUS  
        code_output = round(float(eval(return_value))) % 1000
    except Exception as e:
        print(e,'shell_output')
        code_output = -1
    
    if return_shell_output:
        if code_output==-1:
            CODE_STATUS = False
        else:
            CODE_STATUS = True
        return code_output, CODE_STATUS  
    
    
    return code_output


def process_text_output(output):
    result = output    
    try:
        result_output = re.findall(r'\\boxed\{(\d+)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED FINAL', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING TEXT')
        result_output = -1
    
    return result_output

torch.cuda.empty_cache()
gc.collect()
import re
import math
import random

from collections import defaultdict

n_repetitions = 22 if PRIVATE else 4
TOTAL_TOKENS = 2048 # if PRIVATE else 512

if PRIVATE:
    TIME_LIMIT = 31500
else:
    TIME_LIMIT = 1
if PRIVATE:

    MODEL_PATH = ""/kaggle/input/deepseek-math""#""/kaggle/input/gemma/transformers/7b-it/1""
    DEEP = True

    config = AutoConfig.from_pretrained(MODEL_PATH)
    config.gradient_checkpointing = True

    tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

    device_map = [('model.embed_tokens', 0),
                 ('model.layers.0', 0),
                 ('model.layers.1', 0),
                 ('model.layers.2', 0),
                 ('model.layers.3', 0),
                 ('model.layers.4', 0),
                 ('model.layers.5', 0),
                 ('model.layers.6', 0),
                 ('model.layers.7', 0),
                 ('model.layers.8', 0),
                 ('model.layers.9', 0),
                 ('model.layers.10', 0),
                 ('model.layers.11', 0),
                 ('model.layers.12', 0),
                 ('model.layers.13', 0),
                 ('model.layers.14', 0),
                 ('model.layers.15', 0),
                 ('model.layers.16', 0),
                 ('model.layers.17', 0),
                 ('model.layers.18', 0),
                 ('model.layers.19', 0),
                 ('model.layers.20', 0),
                 ('model.layers.21', 0),
                 ('model.layers.22', 1),
                 ('model.layers.23', 1),
                 ('model.layers.24', 1),
                 ('model.layers.25', 1),
                 ('model.layers.26', 1),
                 ('model.layers.27', 1),
                 ('model.layers.28', 1),
                 ('model.layers.29', 1),
                 ('model.norm', 1),
                 ('lm_head', 1)]

    device_map = {ii:jj for (ii,jj) in device_map}

    if QUANT:
        from transformers import BitsAndBytesConfig
        quantization_config = BitsAndBytesConfig(
            load_in_4bit = True,
            bnb_4bit_quant_type=""nf4"",
            bnb_4bit_compute_dtype=torch.bfloat16,
            bnb_4bit_use_double_quant=True,
        )
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=""sequential"",
            torch_dtype=""auto"",
            trust_remote_code=True, 
            quantization_config=quantization_config,
            config=config
        )
    else:  
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=device_map,
            torch_dtype=""auto"",
            trust_remote_code=True,
            #quantization_config=quantization_config,
            config=config
        )
    
    pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=device_map,
)
    from transformers import StoppingCriteriaList

    class StoppingCriteriaSub(StoppingCriteria):
        def __init__(self, stops = [], encounters=1):
            super().__init__()
            self.stops = [stop.to(""cuda"") for stop in stops]

        def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor):
            for stop in self.stops:
                last_token = input_ids[0][-len(stop):]
                if torch.all(torch.eq(stop,last_token)):
                    return True
            return False


    stop_words = [""```output"", ""```python"", ""```\nOutput"" , "")\n```"" , ""``````output""] #,  
    stop_words_ids = [tokenizer(stop_word, return_tensors='pt', add_special_tokens=False)['input_ids'].squeeze() for stop_word in stop_words]
    stopping_criteria = StoppingCriteriaList([StoppingCriteriaSub(stops=stop_words_ids)])
    
    model.dtype, model.hf_device_map



code = """"""Below is a math problem you are to solve (positive numerical answer):
\""{}\""
To accomplish this, first determine a sympy-based approach for solving the problem by listing each step to take and what functions need to be called in each step. Be clear so even an idiot can follow your instructions, and remember, your final answer should be positive integer, not an algebraic expression!
Write the entire script covering all the steps (use comments and document it well) and print the result. After solving the problem, output the final numerical answer within \\boxed{}.

Approach:""""""


cot = """"""Below is a math problem you are to solve (positive numerical answer!):
\""{}\""
Analyze this problem and think step by step to come to a solution with programs. After solving the problem, output the final numerical answer within \\boxed{}.\n\n""""""

promplt_options = [code,cot]
import re
from collections import defaultdict
from collections import Counter

from numpy.random import choice
import numpy as np

tool_instruction = '\n\nPlease integrate natural language reasoning with programs to solve the above problem, and put your final numerical answer within \\boxed{}.\nNote that the intermediary calculations may be real numbers, but the final numercal answer would always be an integer.'


#tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
#tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'

temperature = 0.9
top_p = 1.0

temperature_coding = 0.9
top_p_coding = 1.0

   
total_results = {}
total_answers = {}
best_stats = {}
total_outputs = {}
question_type_counts = {}
starting_counts = (2,3)
    
    
for jj in tqdm(range(n_repetitions)):   
    for i in tqdm(range(len(df))):
        TIME_SPENT = time.time() - NOTEBOOK_START_TIME
        
        if TIME_SPENT>TIME_LIMIT:
            break
        

        id_ = df['id'].loc[i]
        problem = df['problem'].loc[i]
        print(f""\n\n\nQUESTION {i} - {jj} - TIME_SPENT : {TIME_SPENT:.0f} secs"")
        
        best, best_count = best_stats.get(i,(-1,-1))
        if best_count>np.sqrt(jj):
            print(""SKIPPING CAUSE ALREADY FOUND BEST"")
            continue
            
        outputs = total_outputs.get(i,[])
        text_answers, code_answers = question_type_counts.get(i,starting_counts)
        results = total_results.get(i,[])
        answers = total_answers.get(i,[])
        
        for _ in range(5):
            torch.cuda.empty_cache()
            gc.collect()
            time.sleep(0.2)

        try:
            ALREADY_GEN = 0
            code_error = None
            code_error_count = 0
            code_output = -1
            #initail_message = problem  + tool_instruction 
            counts = np.array([text_answers,code_answers])

            draw = choice(promplt_options, 1,
                          p=counts/counts.sum())

            initail_message = draw[0].format(problem,""{}"")            
            prompt = f""User: {initail_message}""

            current_printed = len(prompt)
            print(f""{jj}_{prompt}\n"")

            model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
            input_len = len(model_inputs['input_ids'][0])

            generation_output = model.generate(**model_inputs, 
                                               max_new_tokens=TOTAL_TOKENS-ALREADY_GEN,
                                               return_dict_in_generate=USE_PAST_KEY,
                                               do_sample = True,
                                               temperature = temperature,
                                               top_p = top_p,
                                               num_return_sequences=1, stopping_criteria = stopping_criteria)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]
            decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
            print(f""{decoded_output[current_printed:]}\n"")
            current_printed += len(decoded_output[current_printed:])
            cummulative_code = """"
            
            
            stop_word_cond = False
            for stop_word in stop_words:
                stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)
                
            
            while (stop_word_cond) and (ALREADY_GEN<(TOTAL_TOKENS)):

                if (decoded_output[-len(""```python""):]==""```python""):
                    temperature_inner=temperature_coding
                    top_p_inner = top_p_coding
                    prompt = decoded_output
                else:
                    temperature_inner=temperature
                    top_p_inner = top_p
                    try:
                        if (decoded_output[-len(""``````output""):]==""``````output""):
                            code_text = decoded_output.split('```python')[-1].split(""``````"")[0]
                        else:
                            code_text = decoded_output.split('```python')[-1].split(""```"")[0]
                        

                        cummulative_code+=code_text
                        code_output, CODE_STATUS = process_code(cummulative_code, return_shell_output=True)
                        print('CODE RESULTS', code_output)

                        if code_error==code_output:
                            code_error_count+=1
                        else:
                            code_error=code_output
                            code_error_count = 0

                        if not CODE_STATUS:
                            cummulative_code = cummulative_code[:-len(code_text)]

                            if code_error_count>=1:
                                print(""REPEATED ERRORS"")
                                break

                    except Exception as e:
                        print(e)
                        print('ERROR PARSING CODE')
                        code_output = -1

                    if code_output!=-1:
                        if (decoded_output[-len("")\n```""):]=="")\n```""):
                            prompt = decoded_output+'```output\n'+str(code_output)+'\n```\n'
                        else:
                            prompt = decoded_output+'\n'+str(code_output)+'\n```\n'
                    else:
                        prompt = decoded_output
                        cummulative_code=""""


                model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
                ALREADY_GEN =  len(model_inputs['input_ids'][0])-input_len

                if USE_PAST_KEY:
                    old_values = generation_output.past_key_values
                else:
                    old_values = None

                generation_output = model.generate(**model_inputs, 
                                                   max_new_tokens=TOTAL_TOKENS-ALREADY_GEN, 
                                                   return_dict_in_generate=USE_PAST_KEY,
                                                   past_key_values=old_values,
                                                   do_sample = True,
                                                   temperature = temperature_inner,
                                                   top_p = top_p_inner,
                                                   num_return_sequences=1, stopping_criteria = stopping_criteria)

                if USE_PAST_KEY:
                    output_ids = generation_output.sequences[0]
                else:
                    output_ids = generation_output[0]
                decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
                print(f""\nINTERMEDIATE OUT :\n{decoded_output[current_printed:]}\n"")
                current_printed+=len(decoded_output[current_printed:])
                
                stop_word_cond = False
                for stop_word in stop_words:
                    stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]

            raw_output = tokenizer.decode(output_ids[input_len:], skip_special_tokens=True)
            #print(f""\n\nOutput :\n{raw_output}\n"")                            
            result_output = process_text_output(raw_output)
            
            try:
                code_output = round(float(eval(code_output))) % 1000
            except Exception as e:
                print(e,'final_eval')
                code_output = -1

        except Exception as e:
            print(e,""5"")
            result_output, code_output = -1, -1

        if code_output!=-1:
            outputs.append(code_output)
            code_answers+=1

        if result_output!=-1:
            outputs.append(result_output)
            text_answers+=1

        if len(outputs) > 0:
            occurances = Counter(outputs).most_common()
            print(occurances)
            if occurances[0][1] > best_count:
                print(""GOOD ANSWER UPDATED!"")
                best = occurances[0][0]
                best_count = occurances[0][1]
            if occurances[0][1] > 5:
                print(""ANSWER FOUND!"")
                break

        results.append(result_output)
        answers.append(code_output)
        
        best_stats[i] = (best, best_count) 
        question_type_counts[i] = (text_answers, code_answers)
        total_outputs[i] = outputs
        
        total_results[i] = results
        total_answers[i] = answers

        print(""code_answers"",code_answers-starting_counts[1],""text_answers"",text_answers-starting_counts[0])
        if DEBUG:
            break
import numpy as np
if PRIVATE:
    for ii in range(len(df)):
        a = total_answers[ii]
        b = total_answers[ii]
        a = np.array(a)
        b = np.array(b)
        print(a,b)
        a[a < 0] = b[a < 0]

        pred = Counter(a.tolist()).most_common(2)
        print(pred)
if PRIVATE:
    df['answer'] = [best_stats[ii][0] for ii in range(len(df))]
else:
    df['answer'] = 2
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    if PRIVATE:
        df['model_answer'] = [best_stats[ii][0] for ii in range(len(df))]
        df['match'] = df.answer == df.model_answer
        print(f'{df.match.sum()} matches in {len(df)} examples')
df
with open('code.py', 'w') as fout:
    fout.write(""print('done')"")

batcmd = 'timeout 7 ' + sys.executable + ' code.py'
try:
    shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
    print(shell_output)
except:
    pass

","## Forked From  https://kaggle.com/code/xiaoz259/pure-rng/notebook


# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
import time

NOTEBOOK_START_TIME = time.time()
DEBUG = False

QUANT = False

if QUANT:
    from transformers import BitsAndBytesConfig
    quantization_config = BitsAndBytesConfig(
        load_in_4bit = True,
        bnb_4bit_quant_type=""nf4"",
        bnb_4bit_compute_dtype=torch.bfloat16,
        bnb_4bit_use_double_quant=True,
    )

USE_PAST_KEY = True
%%time
if QUANT:
    !pip install -U /kaggle/input/accelerate-wheelwhl/accelerate-0.29.1-py3-none-any.whl -qq
    !pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq


import torch
import gc
torch.backends.cuda.enable_mem_efficient_sdp(False)

from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    AutoConfig,
    StoppingCriteria,
    set_seed
)

import transformers
print(f""Transformers Version: {transformers.__version__}"")
set_seed(42)
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import re
import sys
import subprocess

def return_last_print(output, n):
    lines = output.strip().split('\n')
    if lines:
        return lines[n]
    else:
        return """"

def process_code(code, return_shell_output=False):
    
    def repl(match):
        if ""real"" not in match.group():
            return ""{}{}"".format(match.group()[:-1], ', real=True)')
        else:
            return ""{}{}"".format(match.group()[:-1], ')')
    code = re.sub(r""symbols\([^)]+\)"", repl, code)

    if return_shell_output:
        code = code.replace('\n', '\n    ')
            # Add a try...except block
        code = ""\ntry:\n    from sympy import *\n{}\nexcept Exception as e:\n    print(e)\n    print('FAIL')\n"".format(code)
    
    if not return_shell_output:
        print(code)
    with open('code.py', 'w') as fout:
        fout.write(code)
    
    batcmd = 'timeout 7 ' + sys.executable + ' code.py'
    try:
        shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
        return_value = return_last_print(shell_output, -1)
        print(shell_output)
        if return_shell_output:
            if return_value=='FAIL':
                CODE_STATUS = False
                return_value = return_last_print(shell_output, -2)
                if ""not defined"" in return_value:
                    return_value+='\nTry checking the formatting and imports'
            else:
                CODE_STATUS = True
            return return_value, CODE_STATUS  
        code_output = round(float(eval(return_value))) % 1000
    except Exception as e:
        print(e,'shell_output')
        code_output = -1
    
    if return_shell_output:
        if code_output==-1:
            CODE_STATUS = False
        else:
            CODE_STATUS = True
        return code_output, CODE_STATUS  
    
    
    return code_output


def process_text_output(output):
    result = output    
    try:
        result_output = re.findall(r'\\boxed\{(\d+)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED FINAL', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING TEXT')
        result_output = -1
    
    return result_output

torch.cuda.empty_cache()
gc.collect()
import re
import math
import random

from collections import defaultdict

n_repetitions = 22 if PRIVATE else 4
TOTAL_TOKENS = 2048 # if PRIVATE else 512

if PRIVATE:
    TIME_LIMIT = 31500
else:
    TIME_LIMIT = 1
if PRIVATE:

    MODEL_PATH = ""/kaggle/input/deepseek-math""#""/kaggle/input/gemma/transformers/7b-it/1""
    DEEP = True

    config = AutoConfig.from_pretrained(MODEL_PATH)
    config.gradient_checkpointing = True

    tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

    device_map = [('model.embed_tokens', 0),
                 ('model.layers.0', 0),
                 ('model.layers.1', 0),
                 ('model.layers.2', 0),
                 ('model.layers.3', 0),
                 ('model.layers.4', 0),
                 ('model.layers.5', 0),
                 ('model.layers.6', 0),
                 ('model.layers.7', 0),
                 ('model.layers.8', 0),
                 ('model.layers.9', 0),
                 ('model.layers.10', 0),
                 ('model.layers.11', 0),
                 ('model.layers.12', 0),
                 ('model.layers.13', 0),
                 ('model.layers.14', 0),
                 ('model.layers.15', 0),
                 ('model.layers.16', 0),
                 ('model.layers.17', 0),
                 ('model.layers.18', 0),
                 ('model.layers.19', 0),
                 ('model.layers.20', 0),
                 ('model.layers.21', 0),
                 ('model.layers.22', 1),
                 ('model.layers.23', 1),
                 ('model.layers.24', 1),
                 ('model.layers.25', 1),
                 ('model.layers.26', 1),
                 ('model.layers.27', 1),
                 ('model.layers.28', 1),
                 ('model.layers.29', 1),
                 ('model.norm', 1),
                 ('lm_head', 1)]

    device_map = {ii:jj for (ii,jj) in device_map}

    if QUANT:
        from transformers import BitsAndBytesConfig
        quantization_config = BitsAndBytesConfig(
            load_in_4bit = True,
            bnb_4bit_quant_type=""nf4"",
            bnb_4bit_compute_dtype=torch.bfloat16,
            bnb_4bit_use_double_quant=True,
        )
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=""sequential"",
            torch_dtype=""auto"",
            trust_remote_code=True, 
            quantization_config=quantization_config,
            config=config
        )
    else:  
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=device_map,
            torch_dtype=""auto"",
            trust_remote_code=True,
            #quantization_config=quantization_config,
            config=config
        )
    
    pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=device_map,
)
    from transformers import StoppingCriteriaList

    class StoppingCriteriaSub(StoppingCriteria):
        def __init__(self, stops = [], encounters=1):
            super().__init__()
            self.stops = [stop.to(""cuda"") for stop in stops]

        def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor):
            for stop in self.stops:
                last_token = input_ids[0][-len(stop):]
                if torch.all(torch.eq(stop,last_token)):
                    return True
            return False


    stop_words = [""```output"", ""```python"", ""```\nOutput"" , "")\n```"" , ""``````output""] #,  
    stop_words_ids = [tokenizer(stop_word, return_tensors='pt', add_special_tokens=False)['input_ids'].squeeze() for stop_word in stop_words]
    stopping_criteria = StoppingCriteriaList([StoppingCriteriaSub(stops=stop_words_ids)])
    
    model.dtype, model.hf_device_map



code = """"""Below is a math problem you are to solve (positive numerical answer):
\""{}\""
To accomplish this, first determine a sympy-based approach for solving the problem by listing each step to take and what functions need to be called in each step. Be clear so even an idiot can follow your instructions, and remember, your final answer should be positive integer, not an algebraic expression!
Write the entire script covering all the steps (use comments and document it well) and print the result. After solving the problem, output the final numerical answer within \\boxed{}.

Approach:""""""


cot = """"""Below is a math problem you are to solve (positive numerical answer!):
\""{}\""
Analyze this problem and think step by step to come to a solution with programs. After solving the problem, output the final numerical answer within \\boxed{}.\n\n""""""

promplt_options = [code,cot]
import re
from collections import defaultdict
from collections import Counter

from numpy.random import choice
import numpy as np

tool_instruction = '\n\nPlease integrate natural language reasoning with programs to solve the above problem, and put your final numerical answer within \\boxed{}.\nNote that the intermediary calculations may be real numbers, but the final numercal answer would always be an integer.'


#tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
#tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'

temperature = 0.9
top_p = 1.0

temperature_coding = 0.9
top_p_coding = 1.0

   
total_results = {}
total_answers = {}
best_stats = {}
total_outputs = {}
question_type_counts = {}
starting_counts = (2,3)
    
    
for jj in tqdm(range(n_repetitions)):   
    for i in tqdm(range(len(df))):
        TIME_SPENT = time.time() - NOTEBOOK_START_TIME
        
        if TIME_SPENT>TIME_LIMIT:
            break
        

        id_ = df['id'].loc[i]
        problem = df['problem'].loc[i]
        print(f""\n\n\nQUESTION {i} - {jj} - TIME_SPENT : {TIME_SPENT:.0f} secs"")
        
        best, best_count = best_stats.get(i,(-1,-1))
        if best_count>np.sqrt(jj):
            print(""SKIPPING CAUSE ALREADY FOUND BEST"")
            continue
            
        outputs = total_outputs.get(i,[])
        text_answers, code_answers = question_type_counts.get(i,starting_counts)
        results = total_results.get(i,[])
        answers = total_answers.get(i,[])
        
        for _ in range(5):
            torch.cuda.empty_cache()
            gc.collect()
            time.sleep(0.2)

        try:
            ALREADY_GEN = 0
            code_error = None
            code_error_count = 0
            code_output = -1
            #initail_message = problem  + tool_instruction 
            counts = np.array([text_answers,code_answers])

            draw = choice(promplt_options, 1,
                          p=counts/counts.sum())

            initail_message = draw[0].format(problem,""{}"")            
            prompt = f""User: {initail_message}""

            current_printed = len(prompt)
            print(f""{jj}_{prompt}\n"")

            model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
            input_len = len(model_inputs['input_ids'][0])

            generation_output = model.generate(**model_inputs, 
                                               max_new_tokens=TOTAL_TOKENS-ALREADY_GEN,
                                               return_dict_in_generate=USE_PAST_KEY,
                                               do_sample = True,
                                               temperature = temperature,
                                               top_p = top_p,
                                               num_return_sequences=1, stopping_criteria = stopping_criteria)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]
            decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
            print(f""{decoded_output[current_printed:]}\n"")
            current_printed += len(decoded_output[current_printed:])
            cummulative_code = """"
            
            
            stop_word_cond = False
            for stop_word in stop_words:
                stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)
                
            
            while (stop_word_cond) and (ALREADY_GEN<(TOTAL_TOKENS)):

                if (decoded_output[-len(""```python""):]==""```python""):
                    temperature_inner=temperature_coding
                    top_p_inner = top_p_coding
                    prompt = decoded_output
                else:
                    temperature_inner=temperature
                    top_p_inner = top_p
                    try:
                        if (decoded_output[-len(""``````output""):]==""``````output""):
                            code_text = decoded_output.split('```python')[-1].split(""``````"")[0]
                        else:
                            code_text = decoded_output.split('```python')[-1].split(""```"")[0]
                        

                        cummulative_code+=code_text
                        code_output, CODE_STATUS = process_code(cummulative_code, return_shell_output=True)
                        print('CODE RESULTS', code_output)

                        if code_error==code_output:
                            code_error_count+=1
                        else:
                            code_error=code_output
                            code_error_count = 0

                        if not CODE_STATUS:
                            cummulative_code = cummulative_code[:-len(code_text)]

                            if code_error_count>=1:
                                print(""REPEATED ERRORS"")
                                break

                    except Exception as e:
                        print(e)
                        print('ERROR PARSING CODE')
                        code_output = -1

                    if code_output!=-1:
                        if (decoded_output[-len("")\n```""):]=="")\n```""):
                            prompt = decoded_output+'```output\n'+str(code_output)+'\n```\n'
                        else:
                            prompt = decoded_output+'\n'+str(code_output)+'\n```\n'
                    else:
                        prompt = decoded_output
                        cummulative_code=""""


                model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
                ALREADY_GEN =  len(model_inputs['input_ids'][0])-input_len

                if USE_PAST_KEY:
                    old_values = generation_output.past_key_values
                else:
                    old_values = None

                generation_output = model.generate(**model_inputs, 
                                                   max_new_tokens=TOTAL_TOKENS-ALREADY_GEN, 
                                                   return_dict_in_generate=USE_PAST_KEY,
                                                   past_key_values=old_values,
                                                   do_sample = True,
                                                   temperature = temperature_inner,
                                                   top_p = top_p_inner,
                                                   num_return_sequences=1, stopping_criteria = stopping_criteria)

                if USE_PAST_KEY:
                    output_ids = generation_output.sequences[0]
                else:
                    output_ids = generation_output[0]
                decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
                print(f""\nINTERMEDIATE OUT :\n{decoded_output[current_printed:]}\n"")
                current_printed+=len(decoded_output[current_printed:])
                
                stop_word_cond = False
                for stop_word in stop_words:
                    stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]

            raw_output = tokenizer.decode(output_ids[input_len:], skip_special_tokens=True)
            #print(f""\n\nOutput :\n{raw_output}\n"")                            
            result_output = process_text_output(raw_output)
            
            try:
                code_output = round(float(eval(code_output))) % 1000
            except Exception as e:
                print(e,'final_eval')
                code_output = -1

        except Exception as e:
            print(e,""5"")
            result_output, code_output = -1, -1

        if code_output!=-1:
            outputs.append(code_output)
            code_answers+=1

        if result_output!=-1:
            outputs.append(result_output)
            text_answers+=1

        if len(outputs) > 0:
            occurances = Counter(outputs).most_common()
            print(occurances)
            if occurances[0][1] > best_count:
                print(""GOOD ANSWER UPDATED!"")
                best = occurances[0][0]
                best_count = occurances[0][1]
            if occurances[0][1] > 5:
                print(""ANSWER FOUND!"")
                break

        results.append(result_output)
        answers.append(code_output)
        
        best_stats[i] = (best, best_count) 
        question_type_counts[i] = (text_answers, code_answers)
        total_outputs[i] = outputs
        
        total_results[i] = results
        total_answers[i] = answers

        print(""code_answers"",code_answers-starting_counts[1],""text_answers"",text_answers-starting_counts[0])
        if DEBUG:
            break
import numpy as np
if PRIVATE:
    for ii in range(len(df)):
        a = total_answers[ii]
        b = total_answers[ii]
        a = np.array(a)
        b = np.array(b)
        print(a,b)
        a[a < 0] = b[a < 0]

        pred = Counter(a.tolist()).most_common(2)
        print(pred)
if PRIVATE:
    df['answer'] = [best_stats[ii][0] for ii in range(len(df))]
else:
    df['answer'] = 2
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    if PRIVATE:
        df['model_answer'] = [best_stats[ii][0] for ii in range(len(df))]
        df['match'] = df.answer == df.model_answer
        print(f'{df.match.sum()} matches in {len(df)} examples')
df
with open('code.py', 'w') as fout:
    fout.write(""print('done')"")

batcmd = 'timeout 7 ' + sys.executable + ' code.py'
try:
    shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
    print(shell_output)
except:
    pass

","TO-DO

Change temperature as the question goes longer
Change temperature based on question lenght
# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
","['AI Mathematical Olympiad - Progress Prize 1', 'accelerate wheel/whl', 'bitsandbytes-0.42.0-py3-none-any.whl', 'deepseek-math', 'open-math-mistral']","['time', 'torch', 'gc', 'transformers', 'pandas', 'tqdm', 're', 'sys', 'subprocess', 'math', 'random', 'collections', 'numpy.random', 'numpy']","Here is a summary of the unique aspects of this Machine Learning code written in Python:

1. **Generative Model**: The code appears to be using a generative model, possibly based on transformer architecture, to generate text outputs.
2. **Tokenization**: The code uses tokenization to process input texts and generates output tokens using a tokenizer.
3. **Conditional Generation**: The code allows for conditional generation of text outputs by specifying the past key values (USE_PAST_KEY) and temperature (temperature_ inner).
4. **Stop Words**: The code includes stop words that are used to conditionally generate text outputs based on the presence of specific stop words in the input.
5. **Evaluation Metrics**: The code uses evaluation metrics such as best answer, best count, and occurrences to determine the quality of generated text outputs.
6. **Dataframe Manipulation**: The code manipulates a dataframe (df) to store results, answers, and statistics.
7. **Private Mode**: The code has a private mode that allows for custom processing of data, including converting arrays to numpy arrays and performing statistical analysis.
8. **CSV Output**: The code writes the final results to a CSV file named ""submission.csv"".
9. **Shell Command Execution**: The code executes a shell command using subprocess.check_output() to run an external program (code.py) with a timeout of 7 seconds.

These unique aspects suggest that this code is part of a natural language processing (NLP) project, possibly for generating text outputs or answering mathematical questions based on a dataset."
AIMO Mixtral Baseline,https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline,3.0,,gold,162,8192,2253.0s - GPU T4 x2,2 months,"# credits: https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig, AutoConfig

MODEL_PATH = ""/kaggle/input/mixtral/pytorch/8x7b-instruct-v0.1-hf/1""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

# To prevent GPU memory overflow in Mixtral8x7b
config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map = ""auto"",
    trust_remote_code = True,
    quantization_config=quantization_config,
    config=config
)
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
def gen_prompt(problem):
    
    return f""""""
Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n
### Instruction:\n{problem}\n\n
### Response: Let's think step by step. The final response should be a single number in the last line of your response.
""""""
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return int(''.join(out))
answers = []

for i in tqdm(range(len(df))):
    try:
        id_ = df['id'].loc[i]
        problem = df['problem'].loc[i]
        query_prompt = gen_prompt(problem)
        
        messages = [
            {
                ""role"": ""user"",
                ""content"": query_prompt
            }
        ]

        inputs = tokenizer.apply_chat_template(messages, return_tensors=""pt"").to(""cuda"")

        with torch.no_grad():
            encoded_output = model.generate(inputs, max_new_tokens=1500, do_sample=False, pad_token_id=tokenizer.eos_token_id)

        decoded_output = tokenizer.decode(encoded_output[0], skip_special_tokens=True).replace(query_prompt, '').replace(""[INST]"", """").replace(""[/INST]"", """").strip()
    
        print(i)
        print(decoded_output)
        
        answer = decoded_output.split('\n')[-1]
        answer = naive_parse(answer)
        print(answer)
        answer = int(answer) % 1000
        print(answer)
        answers.append(answer)
        torch.cuda.empty_cache()
        gc.collect()
        
    except Exception as e:
        print(e)
        answers.append(0)
df['answer'] = answers
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')

","# credits: https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig, AutoConfig

MODEL_PATH = ""/kaggle/input/mixtral/pytorch/8x7b-instruct-v0.1-hf/1""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

# To prevent GPU memory overflow in Mixtral8x7b
config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map = ""auto"",
    trust_remote_code = True,
    quantization_config=quantization_config,
    config=config
)
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
def gen_prompt(problem):
    
    return f""""""
Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n
### Instruction:\n{problem}\n\n
### Response: Let's think step by step. The final response should be a single number in the last line of your response.
""""""
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return int(''.join(out))
answers = []

for i in tqdm(range(len(df))):
    try:
        id_ = df['id'].loc[i]
        problem = df['problem'].loc[i]
        query_prompt = gen_prompt(problem)
        
        messages = [
            {
                ""role"": ""user"",
                ""content"": query_prompt
            }
        ]

        inputs = tokenizer.apply_chat_template(messages, return_tensors=""pt"").to(""cuda"")

        with torch.no_grad():
            encoded_output = model.generate(inputs, max_new_tokens=1500, do_sample=False, pad_token_id=tokenizer.eos_token_id)

        decoded_output = tokenizer.decode(encoded_output[0], skip_special_tokens=True).replace(query_prompt, '').replace(""[INST]"", """").replace(""[/INST]"", """").strip()
    
        print(i)
        print(decoded_output)
        
        answer = decoded_output.split('\n')[-1]
        answer = naive_parse(answer)
        print(answer)
        answer = int(answer) % 1000
        print(answer)
        answers.append(answer)
        torch.cuda.empty_cache()
        gc.collect()
        
    except Exception as e:
        print(e)
        answers.append(0)
df['answer'] = answers
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')

",,"['AI Mathematical Olympiad - Progress Prize 1', 'bitsandbytes-0.42.0-py3-none-any.whl']","['torch', 'transformers', 'pandas', 'tqdm', 'gc']","Unique aspects:
1. The use of the Mixtral-8x7b model, a pre-trained causal language model for mathematical reasoning.
2. The integration of quantization techniques using BitsAndBytesConfig to optimize GPU memory usage.

Steps taken:
1. Import necessary libraries, including PyTorch and transformers.
2. Load the pre-trained Mixtral-8x7b model and tokenizer.
3. Define a custom pipeline for text generation using the transformers library.
4. Process the output of the pipeline to extract code blocks and execute them to obtain results.
5. Integrate natural language reasoning with programs to solve mathematical problems.

Summary:
This code uses the Mixtral-8x7b model, a pre-trained causal language model for mathematical reasoning, to integrate natural language reasoning with programs to solve mathematical problems. It also employs quantization techniques using BitsAndBytesConfig to optimize GPU memory usage."
AIMO: KerasNLP Starter,https://www.kaggle.com/code/awsaf49/aimo-kerasnlp-starter,,,gold,146,13804,783.0s - GPU P100,1 month,"<center><img src=""https://keras.io/img/logo-small.png"" alt=""Keras logo"" width=""100""><br/>
This starter notebook is provided by the Keras team.</center>
# AI Math Olympiad with [KerasNLP](https://github.com/keras-team/keras-nlp) and [Keras](https://github.com/keras-team/keras)

<div align=""center"">
    <img src=""https://i.ibb.co/9rx4pbX/AIMO.png"">
</div>

In this competition, we aim is to build AI models that can solve tough math problems, in other words, creating LLM models capable of solving Math Olympiad problems. This notebook will guide you through the process of fine-tuning the **Gemma** LLM model with LoRA to solve math problems using KerasNLP. With KerasNLP, fine-tuning with LoRA becomes straightforward with just a few lines of code.

**Did you know:**: This notebook is backend-agnostic? Which means it supports TensorFlow, PyTorch, and JAX backends. However, the best performance can be achieved with `JAX`. KerasNLP and Keras enable the choice of preferred backend. Explore further details on [Keras](https://keras.io/keras_3/).

**Note**: For a deeper understanding of KerasNLP, refer to the [KerasNLP guides](https://keras.io/keras_nlp/).
# Install Libraries

We need to install latest KerasNLP to load Gemma 1.1 model. As we don't have access to internet during inference, we will be installing this library from our local files.
!pip install -q /kaggle/input/keras-lib-dataset/keras_nlp-0.9.2-py3-none-any.whl --no-deps
# Import Libraries 
import os
os.environ[""KERAS_BACKEND""] = ""jax"" # you can also use tensorflow or torch
os.environ[""XLA_PYTHON_CLIENT_MEM_FRACTION""] = ""0.9"" # avoid memory fragmentation on JAX backend.

import keras
import keras_nlp

import numpy as np
import pandas as pd
from tqdm.notebook import tqdm
tqdm.pandas() # progress bar for pandas

import plotly.graph_objs as go
import plotly.express as px
from IPython.display import display, Markdown
# Configuration
class CFG:
    seed = 42
    dataset_path = ""/kaggle/input/ai-mathematical-olympiad-prize""
    preset = ""gemma_1.1_instruct_2b_en"" # name of pretrained Gemma
    sequence_length = 512 # max size of input sequence for training
    batch_size = 1 # size of the input batch in training
    epochs = 1 # number of epochs to train
# Reproducibility 
Sets value for random seed to produce similar result in each run.
keras.utils.set_random_seed(CFG.seed)
# Data

No training data is provided in this competition; in other words, we can use any openly available datasets for this competition. In this notebook, we will use a modified **Math** dataset which I have compiled to have a `Question-Solution-Answer` format.

**Data Format:**

These datasets include:
- `problem`: The math problem in LaTeX format.
- `solution`: Step-by-step solution to this problem.
- `answer`: Final answer of the solution which will be the ground truth for this competition.
- `level`: Difficulty of the problem.
- `type`: The category of the problem.

> This dataset comes with its own train test split. However, we will merge them both and use them for fine-tuning. You are welcome to use them for trainining and validation separately. Also to reduce the training time we will only be training on the first`1000` samples. You are welcome to train on the full data.
df1 = pd.read_csv(""/kaggle/input/math-qsa-dataset/train.csv"")
df2 = pd.read_csv(""/kaggle/input/math-qsa-dataset/test.csv"")
df = pd.concat([df1, df2], axis=0)
df = df[:1000] # take first 1000 samples
df.head(2)
# Filter Data

The Math dataset contains various problems, but not all of them are suitable for this competition. More specifically, this competition requires a `non-negative integer` answer, while the Math dataset includes problems with different types of answers such as integers, floats, fractions, matrices, etc. In this notebook, we will only use those problems whose answers are non-negative integers and filter out the rest.
def is_integer(text):
    try:
        if int(text) >= 0:
            return True
        else:
            return False
    except ValueError:
        return False
    
df[""is_integer""] = df.answer.map(is_integer)
df = df[df.is_integer].reset_index(drop=True)
df.head(2)
# Prompt Engineering

We will be using below simple prompt template we'll use to create problem-solution-answer trio to feed the model. This template will help the model to follow instruction and respond accurately. You can explore more advanced prompt templates for better results. 

```
Role:
You are an advanced AI system with exceptional mathematical reasoning and problem-solving capabilities, specifically designed to solve tricky math problems (whose answer is a non-negative integer) written in LaTeX format from the AI Mathematical Olympiad (AIMO) competition. Your task is to accurately analyze and solve intricate mathematical problems, demonstrating a deep understanding of mathematical concepts and a strong ability to apply logical reasoning strategies.

Instruction:
1. Carefully read and comprehend the problem statement provided in the ""Problem"" section.
2. In the ""Solution"" section, provide a solution of the problem with detailed explanation of your logical reasoning process. Keep in mind that answer must be a non-negative integer number.
3. At the end, create a ""Answer"" section where you will state only the final numerical or algebraic answer, without any additional text or narrative.

Problem:
...

Solution:
...

Answer:
...
```
template = """"""Role:\nYou are an advanced AI system with exceptional mathematical reasoning and problem-solving capabilities, specifically designed to solve tricky math problems (whose answer is a non-negative integer) written in LaTeX format from the AI Mathematical Olympiad (AIMO) competition. Your task is to accurately analyze and solve intricate mathematical problems, demonstrating a deep understanding of mathematical concepts and a strong ability to apply logical reasoning strategies.\n\nInstruction:
1. Carefully read and comprehend the problem statement provided in the ""Problem"" section.
2. In the ""Solution"" section, provide a solution of the problem with detailed explanation of your logical reasoning process. Keep in mind that answer must be a non-negative integer number.
3. At the end, create a ""Answer"" section where you will state only the final numerical or algebraic answer, without any additional text or narrative.\n\nProblem:\n{problem}\n\nSolution:\n{solution}""""""
df[""prompt""] = df.progress_apply(lambda row: template.format(problem=row.problem,
                                                             solution=f""{row.solution}\n\nAnswer:\n{row.answer}""),
                                                             axis=1)
data = df.prompt.tolist()
Let's examine a sample prompt. As the answers in our dataset are curated with **markdown** format, we will render the sample using `Markdown()` to properly visualize the formatting.
## Check Sample
def colorize_text(text):
    for word, color in zip([""Role"", ""Instruction"", ""Problem"", ""Solution"", ""Answer""],
                           [""blue"", ""yellow"", ""red"", ""cyan"", ""green""]):
        text = text.replace(f""{word}:"", f""\n\n**<font color='{color}'>{word}:</font>**"")
    return text
## Sample 1
# Take a random sample
sample = data[12]

# Give colors to Instruction, Response and Category
sample = colorize_text(sample)

# Show sample in markdown
display(Markdown(sample))
## Sample 2
# Take a random sample
sample = data[32]

# Give colors to Instruction, Response and Category
sample = colorize_text(sample)

# Show sample in markdown
display(Markdown(sample))
# Modeling

<div align=""center""><img src=""https://i.ibb.co/Bqg9w3g/Gemma-Logo-no-background.png"" width=""300""></div>

**Gemma** is a collection of advanced open LLMs developed by **Google DeepMind** and other **Google teams**, derived from the same research and technology behind the **Gemini** models. They can be integrated into applications and run on various platforms including mobile devices and hosted services. Developers can customize Gemma models using tuning techniques to enhance their performance for specific tasks, offering more targeted and efficient generative AI solutions beyond text generation.

Gemma models are available in several sizes so we can build generative AI solutions based on your available computing resources, the capabilities you need, and where you want to run them.

| Parameters size | Tuned versions    | Intended platforms                 | Preset                 |
|-----------------|-------------------|------------------------------------|------------------------|
| 2B              | Pretrained        | Mobile devices and laptops         | `gemma_2b_en`          |
| 2B              | Instruction tuned | Mobile devices and laptops         | `gemma_1.1_instruct_2b_en` |
| 2B              | Pretrained        | Code Completion in Mobile Device   | `code_gemma_2b_en` |
| 7B              | Pretrained        | Desktop computers and small servers| `gemma_7b_en`          |
| 7B              | Instruction tuned | Desktop computers and small servers| `gemma_1.1_instruct_7b_en` |
| 7B              | Instruction tuned | Code Completion in Desktop computers| `code_gemma_7b_en` |

In this notebook, we will utilize the `Gemma 1.1 2b-it` model from KerasNLP's pretrained models to solve the math olympiad questions. We are using the ""Instruction tuned"" model instead of the ""Pretrained"" one because it is easier for the model to fine-tune on the prepared dataset. 

To explore other available models, you can simply adjust the `preset` value in the `CFG` (config). You can find a list of other pretrained models on the [KerasNLP website](https://keras.io/api/keras_nlp/models/).
## Gemma Causal LM

The code below will build an end-to-end Gemma model for causal language modeling (hence the name `GemmaCausalLM`). A causal language model (LM) predicts the next token based on previous tokens. This task setup can be used to train the model unsupervised on plain text input or to autoregressively generate plain text similar to the data used for training. This task can be used for pre-training or fine-tuning a Gemma model simply by calling `fit()`.

This model has a `generate()` method, which generates text based on a prompt. The generation strategy used is controlled by an additional sampler argument on `compile()`. You can recompile the model with different `keras_nlp.samplers` objects to control the generation. By default, `""greedy""` sampling will be used.

> The `from_preset` method instantiates the model from a preset architecture and weights.
gemma_lm = keras_nlp.models.GemmaCausalLM.from_preset(CFG.preset)
gemma_lm.summary()
## Gemma LM Preprocessor

An important part of the Gemma model is the **Preprocessor** layer, which under the hood uses **Tokenizer**.

**What it does:** The preprocessor takes input strings and transforms them into a dictionary (`token_ids`, `padding_mask`) containing preprocessed tensors. This process starts with tokenization, where input strings are converted into sequences of token IDs.

**Why it's important:** Initially, raw text data is complex and challenging for modeling due to its high dimensionality. By converting text into a compact set of tokens, such as transforming `""The quick brown fox""` into `[""the"", ""qu"", ""##ick"", ""br"", ""##own"", ""fox""]`, we simplify the data. Many models rely on special tokens and additional tensors to understand input. These tokens help divide input and identify padding, among other tasks. Making all sequences the same length through padding boosts computational efficiency, making subsequent steps smoother.

Explore the following pages to access the available preprocessing and tokenizer layers in **KerasNLP**:
- [Preprocessing](https://keras.io/api/keras_nlp/preprocessing_layers/)
- [Tokenizers](https://keras.io/api/keras_nlp/tokenizers/)
x, y, sample_weight = gemma_lm.preprocessor(data[0:2])
This preprocessing layer will take in batches of strings, and return outputs in a `(x, y, sample_weight)` format, where the `y` label is the next token id in the `x` sequence.

From the code below, we can see that, after the preprocessor, the data shape is `(num_samples, sequence_length)`.
# Display the shape of each processed output
for k, v in x.items():
    print(k, "":"", v.shape)
# Inference before Fine-Tuning

Before we do fine-tuning, let's see how Gemma model responds with some prepared prompts.

> As this model is not yet fine-tuned for instruction, you will notice that the model's responses are inaccurate.
## Sample 1
# Take one sample
row = df.iloc[12]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution="""",
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))

## Sample 2
# Take one sample
row = df.iloc[32]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution=""""
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))

# Fine-tuning with LoRA

To get better responses from the model, we will fine-tune the model with Low Rank Adaptation (LoRA).

**What exactly is LoRA?**

LoRA is a method used to fine-tune large language models (LLMs) in an efficient way. It involves freezing the weights of the LLM and injecting trainable rank-decomposition matrices.

Imagine in an LLM, we have a pre-trained dense layer, represented by a $d \times d$ weight matrix, denoted as $W_0$. We then initialize two additional dense layers, labeled as $A$ and $B$, with shapes $d \times r$ and $r \times d$, respectively. Here, $r$ denotes the rank, which is typically **much smaller than** $d$. Prior to LoRA, the model's output was computed using the equation $output = W_0 \cdot x + b_0$, where $x$ represents the input and $b_0$ denotes the bias term associated with the original dense layer, which remains frozen. After applying LoRA, the equation becomes $output = (W_0 \cdot x + b_0) + (B \cdot A \cdot x)$, where $A$ and $B$ denote the trainable rank-decomposition matrices that have been introduced.

<center><img src=""https://i.ibb.co/DWsbhLg/LoRA.png"" width=""300""><br/>
Credit: <a href=""https://arxiv.org/abs/2106.09685"">LoRA: Low-Rank Adaptation of Large Language Models</a> Paper</center>


In the LoRA paper, $A$ is initialized with $\mathcal{N} (0, \sigma^2)$ and $B$ with $0$, where $\mathcal{N}$ denotes the normal distribution, and $\sigma^2$ is the variance.

**Why does LoRA save memory?**

Even though we're adding more layers to the model with LoRA, it actually helps save memory. This is because the smaller layers (A and B) have fewer parameters to learn compared to the big model and fewer trainable parameters mean fewer optimizer variables to store. So, even though the overall model might seem bigger, it's actually more efficient in terms of memory usage. 

> This notebook uses a LoRA rank of `4`. A higher rank means more detailed changes are possible, but also means more trainable parameters.
# Enable LoRA for the model and set the LoRA rank to 4.
gemma_lm.backbone.enable_lora(rank=4)
gemma_lm.summary()
**Notice** that, the number of trainable parameters is reduced from ~$2.5$ billions to ~$1.3$ millions after enabling LoRA.
## Training
# Limit the input sequence length to 512 (to control memory usage).
gemma_lm.preprocessor.sequence_length = CFG.sequence_length 

# Compile the model with loss, optimizer, and metric
gemma_lm.compile(
    loss=keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    optimizer=keras.optimizers.Adam(learning_rate=2e-5),
    weighted_metrics=[keras.metrics.SparseCategoricalAccuracy()],
)

# Train model
gemma_lm.fit(data, epochs=CFG.epochs, batch_size=CFG.batch_size)
# Inference after fine-tuning

Let's see how our fine-tuned model responds to the same questions we asked before fine-tuning the model.
## Sample 1
# Take one sample
row = df.iloc[12]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution=""""
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))
## Sample 2
# Take one sample
row = df.iloc[32]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution=""""
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))

# AIMO Data

So far we have inferred our model on **Math** dataset but now let's see how our model perform on AIMO (competition) dataset.
## Utilities
import re

# Extract answer from model response
def get_answer(text):
    try:
        answer = re.search(r'Answer:\s*([\s\S]+)', text).group(1).strip()
        answer = answer.replace("","","""")
        if is_integer(answer):
            return int(answer)%1000
        else:
            return 0
    except:
        return 0
    
    
def infer(df):
    preds = []
    for i in tqdm(range(len(df))):
        row = df.iloc[i]

        # Generate Prompt using template
        prompt = template.format(
            problem=row.problem,
            solution=""""
        )

        # Infer
        output = gemma_lm.generate(prompt, max_length=1024)
        pred = get_answer(output)

        # Store predictions
        preds.append([row.id, pred])
        if ""answer"" in row:
            preds[-1] += [row.answer]
    return preds
## Inference on AIMO Data
aimo_df = pd.read_csv(f""{CFG.dataset_path}/train.csv"")
train_preds = infer(aimo_df)
train_pred_df = pd.DataFrame(train_preds, columns=[""id"", ""prediction"", ""answer""])
train_pred_df
# Submission
## Infer on Test Data
test_df = pd.read_csv(f""{CFG.dataset_path}/test.csv"")
test_preds = infer(test_df)
## Prepare Submission File

While preparing the submission file, we must keep in mind that, the answer must be between `0-999`. This can easily handled by using `remainder (%)` operation. For this notebook, this step is already applied in the inference stage while extracting `answer` from `solution`. So, we don't need to separately apply it heer.
sub_df = pd.DataFrame(test_preds, columns=[""id"", ""answer""])
sub_df.to_csv(""submission.csv"",index=False,header=True)
sub_df.head()
# Conclusion

We can see that after fine-tuning, the model is following instructions more accurately. However, it may still struggle to solve problems accurately, which can be attributed to its small size. Nevertheless, there is ample room for improvement. Here are some tips to enhance performance:

- Train on the full data instead of first `1000` samples.
- Try using the non-instruction-tuned version of Gemma.
- Increase the `sequence_length`.
- Experiment with advanced prompt engineering techniques.
- Implement augmentation to increase the number of samples.
- Utilize a learning rate scheduler.
# Reference
* [Fine-tune Gemma models in Keras using LoRA](https://www.kaggle.com/code/nilaychauhan/fine-tune-gemma-models-in-keras-using-lora)
* [Parameter-efficient fine-tuning of GPT-2 with LoRA](https://keras.io/examples/nlp/parameter_efficient_finetuning_of_gpt2_with_lora/)
* [Gemma - KerasNLP](https://keras.io/api/keras_nlp/models/gemma/)
","!pip install -q /kaggle/input/keras-lib-dataset/keras_nlp-0.9.2-py3-none-any.whl --no-deps
import os
os.environ[""KERAS_BACKEND""] = ""jax"" # you can also use tensorflow or torch
os.environ[""XLA_PYTHON_CLIENT_MEM_FRACTION""] = ""0.9"" # avoid memory fragmentation on JAX backend.

import keras
import keras_nlp

import numpy as np
import pandas as pd
from tqdm.notebook import tqdm
tqdm.pandas() # progress bar for pandas

import plotly.graph_objs as go
import plotly.express as px
from IPython.display import display, Markdown
class CFG:
    seed = 42
    dataset_path = ""/kaggle/input/ai-mathematical-olympiad-prize""
    preset = ""gemma_1.1_instruct_2b_en"" # name of pretrained Gemma
    sequence_length = 512 # max size of input sequence for training
    batch_size = 1 # size of the input batch in training
    epochs = 1 # number of epochs to train
keras.utils.set_random_seed(CFG.seed)
df1 = pd.read_csv(""/kaggle/input/math-qsa-dataset/train.csv"")
df2 = pd.read_csv(""/kaggle/input/math-qsa-dataset/test.csv"")
df = pd.concat([df1, df2], axis=0)
df = df[:1000] # take first 1000 samples
df.head(2)
def is_integer(text):
    try:
        if int(text) >= 0:
            return True
        else:
            return False
    except ValueError:
        return False
    
df[""is_integer""] = df.answer.map(is_integer)
df = df[df.is_integer].reset_index(drop=True)
df.head(2)
template = """"""Role:\nYou are an advanced AI system with exceptional mathematical reasoning and problem-solving capabilities, specifically designed to solve tricky math problems (whose answer is a non-negative integer) written in LaTeX format from the AI Mathematical Olympiad (AIMO) competition. Your task is to accurately analyze and solve intricate mathematical problems, demonstrating a deep understanding of mathematical concepts and a strong ability to apply logical reasoning strategies.\n\nInstruction:
1. Carefully read and comprehend the problem statement provided in the ""Problem"" section.
2. In the ""Solution"" section, provide a solution of the problem with detailed explanation of your logical reasoning process. Keep in mind that answer must be a non-negative integer number.
3. At the end, create a ""Answer"" section where you will state only the final numerical or algebraic answer, without any additional text or narrative.\n\nProblem:\n{problem}\n\nSolution:\n{solution}""""""
df[""prompt""] = df.progress_apply(lambda row: template.format(problem=row.problem,
                                                             solution=f""{row.solution}\n\nAnswer:\n{row.answer}""),
                                                             axis=1)
data = df.prompt.tolist()
def colorize_text(text):
    for word, color in zip([""Role"", ""Instruction"", ""Problem"", ""Solution"", ""Answer""],
                           [""blue"", ""yellow"", ""red"", ""cyan"", ""green""]):
        text = text.replace(f""{word}:"", f""\n\n**<font color='{color}'>{word}:</font>**"")
    return text
# Take a random sample
sample = data[12]

# Give colors to Instruction, Response and Category
sample = colorize_text(sample)

# Show sample in markdown
display(Markdown(sample))
# Take a random sample
sample = data[32]

# Give colors to Instruction, Response and Category
sample = colorize_text(sample)

# Show sample in markdown
display(Markdown(sample))
gemma_lm = keras_nlp.models.GemmaCausalLM.from_preset(CFG.preset)
gemma_lm.summary()
x, y, sample_weight = gemma_lm.preprocessor(data[0:2])
# Display the shape of each processed output
for k, v in x.items():
    print(k, "":"", v.shape)
# Take one sample
row = df.iloc[12]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution="""",
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))

# Take one sample
row = df.iloc[32]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution=""""
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))

# Enable LoRA for the model and set the LoRA rank to 4.
gemma_lm.backbone.enable_lora(rank=4)
gemma_lm.summary()
# Limit the input sequence length to 512 (to control memory usage).
gemma_lm.preprocessor.sequence_length = CFG.sequence_length 

# Compile the model with loss, optimizer, and metric
gemma_lm.compile(
    loss=keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    optimizer=keras.optimizers.Adam(learning_rate=2e-5),
    weighted_metrics=[keras.metrics.SparseCategoricalAccuracy()],
)

# Train model
gemma_lm.fit(data, epochs=CFG.epochs, batch_size=CFG.batch_size)
# Take one sample
row = df.iloc[12]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution=""""
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))
# Take one sample
row = df.iloc[32]

# Generate Prompt using template
prompt = template.format(
    problem=row.problem,
    solution=""""
)

# Infer
output = gemma_lm.generate(prompt, max_length=1024)

# Colorize
output = colorize_text(output)

# Display in markdown
display(Markdown(output))

import re

# Extract answer from model response
def get_answer(text):
    try:
        answer = re.search(r'Answer:\s*([\s\S]+)', text).group(1).strip()
        answer = answer.replace("","","""")
        if is_integer(answer):
            return int(answer)%1000
        else:
            return 0
    except:
        return 0
    
    
def infer(df):
    preds = []
    for i in tqdm(range(len(df))):
        row = df.iloc[i]

        # Generate Prompt using template
        prompt = template.format(
            problem=row.problem,
            solution=""""
        )

        # Infer
        output = gemma_lm.generate(prompt, max_length=1024)
        pred = get_answer(output)

        # Store predictions
        preds.append([row.id, pred])
        if ""answer"" in row:
            preds[-1] += [row.answer]
    return preds
aimo_df = pd.read_csv(f""{CFG.dataset_path}/train.csv"")
train_preds = infer(aimo_df)
train_pred_df = pd.DataFrame(train_preds, columns=[""id"", ""prediction"", ""answer""])
train_pred_df
test_df = pd.read_csv(f""{CFG.dataset_path}/test.csv"")
test_preds = infer(test_df)
sub_df = pd.DataFrame(test_preds, columns=[""id"", ""answer""])
sub_df.to_csv(""submission.csv"",index=False,header=True)
sub_df.head()
","<center><img src=""https://keras.io/img/logo-small.png"" alt=""Keras logo"" width=""100""><br/>
This starter notebook is provided by the Keras team.</center>
# AI Math Olympiad with [KerasNLP](https://github.com/keras-team/keras-nlp) and [Keras](https://github.com/keras-team/keras)

<div align=""center"">
    <img src=""https://i.ibb.co/9rx4pbX/AIMO.png"">
</div>

In this competition, we aim is to build AI models that can solve tough math problems, in other words, creating LLM models capable of solving Math Olympiad problems. This notebook will guide you through the process of fine-tuning the **Gemma** LLM model with LoRA to solve math problems using KerasNLP. With KerasNLP, fine-tuning with LoRA becomes straightforward with just a few lines of code.

**Did you know:**: This notebook is backend-agnostic? Which means it supports TensorFlow, PyTorch, and JAX backends. However, the best performance can be achieved with `JAX`. KerasNLP and Keras enable the choice of preferred backend. Explore further details on [Keras](https://keras.io/keras_3/).

**Note**: For a deeper understanding of KerasNLP, refer to the [KerasNLP guides](https://keras.io/keras_nlp/).
# Install Libraries

We need to install latest KerasNLP to load Gemma 1.1 model. As we don't have access to internet during inference, we will be installing this library from our local files.
# Import Libraries 
# Configuration
# Reproducibility 
Sets value for random seed to produce similar result in each run.
# Data

No training data is provided in this competition; in other words, we can use any openly available datasets for this competition. In this notebook, we will use a modified **Math** dataset which I have compiled to have a `Question-Solution-Answer` format.

**Data Format:**

These datasets include:
- `problem`: The math problem in LaTeX format.
- `solution`: Step-by-step solution to this problem.
- `answer`: Final answer of the solution which will be the ground truth for this competition.
- `level`: Difficulty of the problem.
- `type`: The category of the problem.

> This dataset comes with its own train test split. However, we will merge them both and use them for fine-tuning. You are welcome to use them for trainining and validation separately. Also to reduce the training time we will only be training on the first`1000` samples. You are welcome to train on the full data.
# Filter Data

The Math dataset contains various problems, but not all of them are suitable for this competition. More specifically, this competition requires a `non-negative integer` answer, while the Math dataset includes problems with different types of answers such as integers, floats, fractions, matrices, etc. In this notebook, we will only use those problems whose answers are non-negative integers and filter out the rest.
# Prompt Engineering

We will be using below simple prompt template we'll use to create problem-solution-answer trio to feed the model. This template will help the model to follow instruction and respond accurately. You can explore more advanced prompt templates for better results. 

```
Role:
You are an advanced AI system with exceptional mathematical reasoning and problem-solving capabilities, specifically designed to solve tricky math problems (whose answer is a non-negative integer) written in LaTeX format from the AI Mathematical Olympiad (AIMO) competition. Your task is to accurately analyze and solve intricate mathematical problems, demonstrating a deep understanding of mathematical concepts and a strong ability to apply logical reasoning strategies.

Instruction:
1. Carefully read and comprehend the problem statement provided in the ""Problem"" section.
2. In the ""Solution"" section, provide a solution of the problem with detailed explanation of your logical reasoning process. Keep in mind that answer must be a non-negative integer number.
3. At the end, create a ""Answer"" section where you will state only the final numerical or algebraic answer, without any additional text or narrative.

Problem:
...

Solution:
...

Answer:
...
```
Let's examine a sample prompt. As the answers in our dataset are curated with **markdown** format, we will render the sample using `Markdown()` to properly visualize the formatting.
## Check Sample
## Sample 1
## Sample 2
# Modeling

<div align=""center""><img src=""https://i.ibb.co/Bqg9w3g/Gemma-Logo-no-background.png"" width=""300""></div>

**Gemma** is a collection of advanced open LLMs developed by **Google DeepMind** and other **Google teams**, derived from the same research and technology behind the **Gemini** models. They can be integrated into applications and run on various platforms including mobile devices and hosted services. Developers can customize Gemma models using tuning techniques to enhance their performance for specific tasks, offering more targeted and efficient generative AI solutions beyond text generation.

Gemma models are available in several sizes so we can build generative AI solutions based on your available computing resources, the capabilities you need, and where you want to run them.

| Parameters size | Tuned versions    | Intended platforms                 | Preset                 |
|-----------------|-------------------|------------------------------------|------------------------|
| 2B              | Pretrained        | Mobile devices and laptops         | `gemma_2b_en`          |
| 2B              | Instruction tuned | Mobile devices and laptops         | `gemma_1.1_instruct_2b_en` |
| 2B              | Pretrained        | Code Completion in Mobile Device   | `code_gemma_2b_en` |
| 7B              | Pretrained        | Desktop computers and small servers| `gemma_7b_en`          |
| 7B              | Instruction tuned | Desktop computers and small servers| `gemma_1.1_instruct_7b_en` |
| 7B              | Instruction tuned | Code Completion in Desktop computers| `code_gemma_7b_en` |

In this notebook, we will utilize the `Gemma 1.1 2b-it` model from KerasNLP's pretrained models to solve the math olympiad questions. We are using the ""Instruction tuned"" model instead of the ""Pretrained"" one because it is easier for the model to fine-tune on the prepared dataset. 

To explore other available models, you can simply adjust the `preset` value in the `CFG` (config). You can find a list of other pretrained models on the [KerasNLP website](https://keras.io/api/keras_nlp/models/).
## Gemma Causal LM

The code below will build an end-to-end Gemma model for causal language modeling (hence the name `GemmaCausalLM`). A causal language model (LM) predicts the next token based on previous tokens. This task setup can be used to train the model unsupervised on plain text input or to autoregressively generate plain text similar to the data used for training. This task can be used for pre-training or fine-tuning a Gemma model simply by calling `fit()`.

This model has a `generate()` method, which generates text based on a prompt. The generation strategy used is controlled by an additional sampler argument on `compile()`. You can recompile the model with different `keras_nlp.samplers` objects to control the generation. By default, `""greedy""` sampling will be used.

> The `from_preset` method instantiates the model from a preset architecture and weights.
## Gemma LM Preprocessor

An important part of the Gemma model is the **Preprocessor** layer, which under the hood uses **Tokenizer**.

**What it does:** The preprocessor takes input strings and transforms them into a dictionary (`token_ids`, `padding_mask`) containing preprocessed tensors. This process starts with tokenization, where input strings are converted into sequences of token IDs.

**Why it's important:** Initially, raw text data is complex and challenging for modeling due to its high dimensionality. By converting text into a compact set of tokens, such as transforming `""The quick brown fox""` into `[""the"", ""qu"", ""##ick"", ""br"", ""##own"", ""fox""]`, we simplify the data. Many models rely on special tokens and additional tensors to understand input. These tokens help divide input and identify padding, among other tasks. Making all sequences the same length through padding boosts computational efficiency, making subsequent steps smoother.

Explore the following pages to access the available preprocessing and tokenizer layers in **KerasNLP**:
- [Preprocessing](https://keras.io/api/keras_nlp/preprocessing_layers/)
- [Tokenizers](https://keras.io/api/keras_nlp/tokenizers/)
This preprocessing layer will take in batches of strings, and return outputs in a `(x, y, sample_weight)` format, where the `y` label is the next token id in the `x` sequence.

From the code below, we can see that, after the preprocessor, the data shape is `(num_samples, sequence_length)`.
# Inference before Fine-Tuning

Before we do fine-tuning, let's see how Gemma model responds with some prepared prompts.

> As this model is not yet fine-tuned for instruction, you will notice that the model's responses are inaccurate.
## Sample 1
## Sample 2
# Fine-tuning with LoRA

To get better responses from the model, we will fine-tune the model with Low Rank Adaptation (LoRA).

**What exactly is LoRA?**

LoRA is a method used to fine-tune large language models (LLMs) in an efficient way. It involves freezing the weights of the LLM and injecting trainable rank-decomposition matrices.

Imagine in an LLM, we have a pre-trained dense layer, represented by a $d \times d$ weight matrix, denoted as $W_0$. We then initialize two additional dense layers, labeled as $A$ and $B$, with shapes $d \times r$ and $r \times d$, respectively. Here, $r$ denotes the rank, which is typically **much smaller than** $d$. Prior to LoRA, the model's output was computed using the equation $output = W_0 \cdot x + b_0$, where $x$ represents the input and $b_0$ denotes the bias term associated with the original dense layer, which remains frozen. After applying LoRA, the equation becomes $output = (W_0 \cdot x + b_0) + (B \cdot A \cdot x)$, where $A$ and $B$ denote the trainable rank-decomposition matrices that have been introduced.

<center><img src=""https://i.ibb.co/DWsbhLg/LoRA.png"" width=""300""><br/>
Credit: <a href=""https://arxiv.org/abs/2106.09685"">LoRA: Low-Rank Adaptation of Large Language Models</a> Paper</center>


In the LoRA paper, $A$ is initialized with $\mathcal{N} (0, \sigma^2)$ and $B$ with $0$, where $\mathcal{N}$ denotes the normal distribution, and $\sigma^2$ is the variance.

**Why does LoRA save memory?**

Even though we're adding more layers to the model with LoRA, it actually helps save memory. This is because the smaller layers (A and B) have fewer parameters to learn compared to the big model and fewer trainable parameters mean fewer optimizer variables to store. So, even though the overall model might seem bigger, it's actually more efficient in terms of memory usage. 

> This notebook uses a LoRA rank of `4`. A higher rank means more detailed changes are possible, but also means more trainable parameters.
**Notice** that, the number of trainable parameters is reduced from ~$2.5$ billions to ~$1.3$ millions after enabling LoRA.
## Training
# Inference after fine-tuning

Let's see how our fine-tuned model responds to the same questions we asked before fine-tuning the model.
## Sample 1
## Sample 2
# AIMO Data

So far we have inferred our model on **Math** dataset but now let's see how our model perform on AIMO (competition) dataset.
## Utilities
## Inference on AIMO Data
# Submission
## Infer on Test Data
## Prepare Submission File

While preparing the submission file, we must keep in mind that, the answer must be between `0-999`. This can easily handled by using `remainder (%)` operation. For this notebook, this step is already applied in the inference stage while extracting `answer` from `solution`. So, we don't need to separately apply it heer.
# Conclusion

We can see that after fine-tuning, the model is following instructions more accurately. However, it may still struggle to solve problems accurately, which can be attributed to its small size. Nevertheless, there is ample room for improvement. Here are some tips to enhance performance:

- Train on the full data instead of first `1000` samples.
- Try using the non-instruction-tuned version of Gemma.
- Increase the `sequence_length`.
- Experiment with advanced prompt engineering techniques.
- Implement augmentation to increase the number of samples.
- Utilize a learning rate scheduler.
# Reference
* [Fine-tune Gemma models in Keras using LoRA](https://www.kaggle.com/code/nilaychauhan/fine-tune-gemma-models-in-keras-using-lora)
* [Parameter-efficient fine-tuning of GPT-2 with LoRA](https://keras.io/examples/nlp/parameter_efficient_finetuning_of_gpt2_with_lora/)
* [Gemma - KerasNLP](https://keras.io/api/keras_nlp/models/gemma/)
","['AI Mathematical Olympiad - Progress Prize 1', 'Keras Lib Dataset', 'Math QSA Dataset']","['os', 'keras', 'keras_nlp', 'numpy', 'pandas', 'tqdm.notebook', 'plotly.graph_objs', 'plotly.express', 'IPython.display', 're']","You are working on fine-tuning a pre-trained language model using Low-Rank Adaptation (LoRA). LoRA is a method used to efficiently fine-tune large language models by freezing the weights of the original model and injecting trainable rank-decomposition matrices.

In this code, you are using LoRA with a rank of 4, which means that the additional layers added to the model have fewer parameters to learn compared to the original model. This helps save memory usage while still allowing for some fine-tuning to occur.

The advantages of using LoRA include:

1. Reduced memory usage: The additional layers added by LoRA have fewer parameters to learn, which reduces the overall memory usage.
2. Improved accuracy: Fine-tuning a pre-trained model with LoRA can improve its accuracy on specific tasks or datasets.
3. Flexibility: LoRA allows you to fine-tune specific parts of the model while keeping other parts frozen, giving you more control over the fine-tuning process.

To summarize, LoRA is a technique that helps reduce memory usage and improves accuracy by adding trainable rank-decomposition matrices to a pre-trained language model."
AIMO - Let's Learn Together,https://www.kaggle.com/code/dschettler8845/aimo-let-s-learn-together,,,gold,124,3590,417.8s - GPU T4 x2,11 days,"# Run this to enable CSS types
from IPython.core.display import HTML

# Font stuff
font_to_use = ""Lato"" # ""Verdana""
fallback = ""Verdana""
font_import_str = f""""""
@import url('https://fonts.googleapis.com/css2?family={font_to_use.replace(' ', '+')}:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap');
""""""

def css_styling(verbose=True):
    styles = open(""/kaggle/input/my-css-styles/kaggle_styles.css"", ""r"").read().replace('Verdana', font_to_use) #+f"", {fallback}"")
    html_str = ""<style>""+font_import_str+styles+""</style>""
    if verbose: print(html_str)
    return HTML(html_str)

css_styling(False)
<br>

<center><img src=""https://aimoprize.com/logo-dark.png"" width=50% style=""padding: 0 0 !important; margin: 0 0 !important;""></center>

<br style=""margin: 15px;"">

<h2 style=""text-align: center; font-size: 30px; font-style: normal; font-weight: 800; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">
    <span style=""text-decoration: underline;"">
        <font color=#799cb7>L</font>ET'S 
        <font color=#799cb7>L</font>EARN 
        <font color=#799cb7>T</font>OGETHER !
    </span><br><br><br style=""margin: 15px;"">
<span style=""font-size: 22px; letter-spacing: 1px;"">
    <font color=#799cb7>U</font>NDERSTANDING    
    <font color=#799cb7>T</font>HROUGH
    <font color=#799cb7>E</font>XPLORATION
</span><br style=""margin: 15px;""></h2>

<p style=""text-align: center; font-size: 15px; font-style: normal; font-weight: bold; text-decoration: None; text-transform: none; letter-spacing: 1px; color: black; background-color: #ffffff;"">CREATED BY: DARIEN SCHETTLER</p>

<hr>

<center><div class=""alert alert-block alert-danger"" style=""margin: 2em; line-height: 1.7em;"">
    <b style=""font-size: 18px;"">🛑 &nbsp; WARNING:</b><br><br><b>THIS IS A WORK IN PROGRESS</b><br>
</div></center>

<center><div class=""alert alert-block alert-warning"" style=""margin: 2em; line-height: 1.7em;"">
    <b style=""font-size: 16px;"">👏 &nbsp; IF YOU FORK THIS OR FIND THIS HELPFUL &nbsp; 👏</b><br><br><b style=""font-size: 22px; color: darkorange"">PLEASE UPVOTE!</b><br><br>This was a lot of work for me and while it may seem silly, it makes me feel appreciated when others like my work. 😅
</div></center>

<hr>
<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; color: #192a51; background-color: #ffffff;"">
    CHANGELOG
</h1>

<i>Before version 12 this was not tracked rigorously and is a rough approximation. After version 11 it should be better.</i>

<ul>
    <li>
        <b>Version 1-2</b>
        <ul>
            <li>Initial Version</li>
            <li>Cells up to and including the visualization for Art of Problem Solving (AOPS) dataset</li>
        </ul>
    </li>
    <li>
        <b>Version 3-7</b>
        <ul>
            <li>This is me getting the submission to work</li>
            <li>While the visualization and exploration of the other external datasets works here... I disable it for version 7 to work.</li>
        </ul>
    </li>
    <li>
        <b>Version 8-10</b>
        <ul>
            <li>Create my own dataset to prevent having to retrieve the answers in the external GSM8K and MATH datasets.</li>
            <li>Cleanup markdown, structureand modify functions to be more understandable (to me)</li>
            <li>Experimentation with various inference flows</li>
        </ul>
    </li>
    <li>
        <b>Version 11 – <font color=""red"">[LB: 12]</font></b>
        <ul>
            <li>Add a class structure to hold the inference code functionality... <b>I don't love it... may discard</b></li>
            <li>Test inference with self-consistency, fallback if all -1 and more complex prompt.</li>
            <li>Update aggregation logic and add test cases.</li>
        </ul>
    </li>
    <li>
        <b>Version 12 – <font color=""red"">[LB: 15]</font></b>
        <ul>
            <li>Disable quantization like all the popular kids...</li>
            <li><b>Fix(?)</b> the way I'm passing the prompt (no apply_chat_template previously) and see if it improves performance</li>
            <li>Add changelog</li>
            <li>Increase repetition count for submission inference based on timing</li>
            <li>Reenable the override of non-valid code scores with boxed scores</li>
        </ul>
    </li>
    <li>
        <b>Version 13 – <font color=""red"">[LB: N/A]</font></b>
        <ul>
            <li>Replace regular inference with vLLM inference. Thanks to <b><a href=""https://www.kaggle.com/bsmit1659"">Brian Smith</a></b>. Original <b><a href=""https://www.kaggle.com/code/bsmit1659/aimo-vllm-accelerated-tot-sc-deepseekmath/input"">Notebook Here</a></b></li>
            <li>Add support for vLLM in a transformers like fashion (aka pipleine)</li>
            <li>Remove pieces of functionality around falling back if 'complex' prompt or all fails.</li>
            <li><s>Try to set tensor parallel to 2 to squeeze 2xT4. Note you have to reset ray ... this is a known issue.</s> <b>Still not working...</b></li>
            <li>Increase number of repetitions in demo and remove different number for private/public</li>
            <li>Remove complex tool instruction completely</li>
        </ul>
    </li>
    <li>
        <b>Version 14-21 – <font color=""red"">[LB: PENDING]</font></b>
        <ul>
            <li>Update submissions to support new submission API</li>
            <li>Create debug class to mimic submission API</li>
            <li>Update code to leverage 2xT4 with updated ray and grcpio libraries</li>
        </ul>
    </li>
</ul>

<br>
<p id=""toc""></p>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; color: #192a51; background-color: #ffffff;"">
    TABLE OF CONTENTS
</h1>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#introduction"" style=""text-decoration: none; color: #799cb7;"">1&nbsp;&nbsp;&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#background_information"" style=""text-decoration: none; color: #799cb7;"">2&nbsp;&nbsp;&nbsp;&nbsp;BACKGROUND INFORMATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#imports"" style=""text-decoration: none; color: #799cb7;"">3&nbsp;&nbsp;&nbsp;&nbsp;IMPORTS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#setup"" style=""text-decoration: none; color: #799cb7;"">4&nbsp;&nbsp;&nbsp;&nbsp;SETUP AND HELPER FUNCTIONS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#eda"" style=""text-decoration: none; color: #799cb7;"">5&nbsp;&nbsp;&nbsp;&nbsp;EXPLORATORY DATA ANALYSIS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#baseline"" style=""text-decoration: none; color: #799cb7;"">6&nbsp;&nbsp;&nbsp;&nbsp;BASELINE SUBMISSION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#cv"" style=""text-decoration: none; color: #799cb7;"">7&nbsp;&nbsp;&nbsp;&nbsp;CROSS VALIDATION</a></h3>

<hr>
<br>

<a id=""introduction""></a>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""introduction"">1&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.1 <b>WHAT</b> IS THIS?</h3>
<hr>

<ul>
    <li>This notebook will follow the authors learning path and highlight relevant terms, information, and useful content about the competition.</li>
    <li>This notebook will conduct an <b>E</b>xploratory <b>D</b>ata <b>A</b>nalysis for the competition.</li>
    <li>This notebook <i>may</i> propose an open-source baseline solution.</li>
</ul>
<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.2 <b>WHY</b> IS THIS?</h3>
<hr>

<ul>
    <li>Writing and sharing my learning path and the resulting exploratory data analysis can help improve my own understanding of the competition and the data.</li>
    <li>Sharing my work may help others who are interested in the competition (or the data). This help may take the form of:
        <ul>
            <li>Better understanding the problem and potential common solutions (incl. my baseline).</li>
            <li>Better understanding of the provided dataset.</li>
            <li>Better understanding of the background information and research.</li>
            <li>Better ability to hypothesize new solutions.</li>
        </ul>
    </li>
    <li>Exploratory data analysis is a critical step in any data science project. Sharing my EDA might help others in the competition.</li>
    <li>Writing and sharing my work is often a fun and rewarding experience! It not only allows me to explore and try different techniques, ideas, and visualizations but also encourages and supports other learners and participants.</li>
</ul>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.3 <b>WHO</b> IS THIS FOR?</h3>
<hr>


<ul>
    <li>The primary purpose of this notebook is to educate <b>MYSELF</b>, however, my review/learning might be beneficial to others:
        <ul>
            <li>Other Kagglers (aka. current and future competition participants).</li>
            <li>Anyone interested in learning more about using artificial intelligence to tackle mathematics.</li>
        </ul>
    </li>
</ul>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.4 <b>HOW</b> WILL THIS WORK?</h3>
<hr>


<p>I'm going to assemble some markdown cells (like this one) at the beginning of the notebook to go over some concepts/details/etc.</p>

<p>Following this, I will attempt to walk through the data and understand it better prior to composing a baseline solution.</p>
<br>

<a id=""background_information""></a>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""background_information"">2&nbsp;&nbsp;BACKGROUND INFORMATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

The <b><a href=""https://www.imo-official.org/"">International Mathematical Olympiad</a> (IMO)</b> is a prestigious global high school maths competition. Countries enter teams of six students, who each individually attempt six highly challenging problems over two days, under exam conditions. Answers are marked by an expert panel, which awards individual <b>gold, silver and bronze medals</b>

A gold medal in the IMO is a benchmark for exceptional mathematical achievement and a strong predictor of future success. <b>IMO gold medallists are 50 times more likely to win a <a href=""https://en.wikipedia.org/wiki/Fields_Medal"">Fields Medal</a> than a typical Cambridge PhD graduate</b>. Indeed, half of all Fields medallists participated in the IMO in their youth.

Building on these traditions, the <b><a href=""https://aimoprize.com/"">AIMO Prize</a></b> has been established to spur the open development of AI models that can reason mathematically to solve problems. This is a new frontier of knowledge and scientific discovery, for which the AIMO Prize could represent a new Turing Test.

<b>The <a href=""https://aimoprize.com/"">AIMO Prize</a> is proposing three initial design principles:</b>

<ol>
    <li>AI models must consume <b><mark>problems in the same format as human contestants</mark></b> and must <b><mark>produce human readable solutions</mark></b> that <b><mark>can be graded by an expert panel, using standard Olympiad criteria.</mark></b></li>
    <li>The grand prize will be awarded for performance in an AIMO approved competition that is at a <b><mark>standard equivalent to a gold medal in the IMO.</mark></b></li>
    <li>To be eligible to win prizes, participants must have <b><mark>adhered to the AIMO public sharing protocol</mark></b> by the time the prize is awarded.</li>
</ol>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.1 <b>UNDERSTANDING</b> THE <b>AIMO</b> PROGRESS PRIZE #1</h3>
<hr>

The First Progress Prize is designed to incentivise the achievement of key milestones towards the grand prize, and opened in April 2024. This prize will be for participation and performance in the Kaggle competition found <b><a href=""https://www.kaggle.com/competitions/ai-mathematical-olympiad-prize"">here</a></b>.

The goal of this competition is to create algorithms and models that can <mark><b>solve tricky math problems</b></mark> written in <mark><b>LaTeX format</b></mark>.
<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.2 <b>COMPETITION OVERVIEW</b></h3>
<hr>

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">PRIMARY TASK DESCRIPTION</b>
<br>
<br>
Develop AI models capable of performing as well as top human participants in the International Mathematical Olympiad (IMO) on a dataset of 110 novel math problems. The Gemma 7B benchmark is 3/50 on public and private test sets.

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">HOST TASK DESCRIPTION</b>
<br>
<br>
The goal of this competition is to create algorithms and models that can solve tricky math problems written in LaTeX format. Your participation will help to advance AI models’ mathematical reasoning skills and drive frontier knowledge.

The AI Mathematical Olympiad (AIMO) Prize is a new <b>10mn</b> prize fund to spur the open development of AI models capable of performing as well as top human participants in the International Mathematical Olympiad (IMO).
This competition includes 110 problems similar to an intermediate-level high school math challenge. The Gemma 7B benchmark for these problems is 3/50 on the public and private test sets.

The assessment of AI models' mathematical reasoning skills faces a significant hurdle, the issue of train-test leakage. Models trained on Internet-scale datasets may inadvertently encounter test questions during training, skewing the evaluation process.

To address this challenge, this competition uses a dataset of 110 novel math problems, created by an international team of problem solvers, recognizing the need for a transparent and fair evaluation framework. The dataset encompasses a range of difficulty levels, from simple arithmetic to algebraic thinking and geometric reasoning. This will help to strengthen the benchmarks for assessing AI models' mathematical reasoning skills, without the risk of contamination from training data.

This competition offers an exciting opportunity to benchmark open AI models against each other and foster healthy competition and innovation in the field. By addressing this initial benchmarking problem, you will contribute to advancing AI capabilities and help to ensure that its potential benefits outweigh the risks.

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">PRIZE FUND (IT IS WORTH MENTIONING AGAIN)</b>
<br>
<br>
The AIMO Prize offers a <b>10 million dollar (\$USD) prize</b> fund to spur open AI development in mathematical reasoning.

* **Prizes for Top-Ranking Teams in this Competition**
    * 1st Place: \$131,072
    * 2nd Place: \$65,536
    * 3rd Place: \$32,768
    * 4th Place: \$16,384
    * 5th Place: \$8,192
* **Overall Progress Prize Winner:**
    * The Overall Progress Prize Winner shall be the highest ranking team that achieves a score of at least 47/50 on both public and private test sets. 
    * After any prizes for the five top-ranking teams have been awarded, the remainder of the total fund shall be awarded to the Overall Progress Prize Winner.
    * If a team is named the Overall Progress Prize Winner in this competition, the prize will be at least \$794,624. 
    * If no team is named the Overall Progress Prize Winner in this competition, the remainder of the total fund shall roll over to the next competition, where the same prize allocation will apply.
* **Early Sharing Prize**: \$10,000. 
    * An additional 10,000 dollar cash prize will be awarded for sharing high-scoring public notebooks early in the competition to encourage participants to share information earlier and help the community make more progress over the course of the competition.
    * To be eligible for the Early Sharing Prize, you will need to:
        * Be the first to publish a public notebook scoring at least 20/50 on the leaderboard before April 22, 2024 11:59PM UTC.
        * Keep the notebooks and any datasets it uses publicly available until the prize is awarded at the end of the competition.

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">VISUAL TASK DESCRIPTION</b>
<br>
<br>
Here is an example of what we have to do. This reasoning trace was generated by <b>Claude Opus</b>... we have to do something similar to get the final answer (integer between 0-1000) but using a much smaller (more tractable) model:

<div style=""background-color: #f5f5f5; border-radius: 10px; padding: 20px; margin: 20px;"">
    <b>PROBLEM:</b>
    <br>
    <br>
    <br>
    Let $k, l > 0$ be parameters.
    <br>
    The parabola $y = kx^2 - 2kx + l$ intersects the line $y = 4$ at two points $A$ and $B$.
    <br>
    These points are distance 6 apart. 
    <br><br>
    What is the sum of the squares of the distances from $A$ and $B$ to the origin?
</div>

<div style=""background-color: #e9fce9; border-radius: 10px; padding: 20px; margin: 20px;"">
    <b>SOLUTION REASONING TRACE:</b>
    <br>
    <br>
    <br>
    <b>Problem Statement:</b>
    <br>
    <br>
    Given a parabola defined by \( y = kx^2 - 2kx + l \) and a line \( y = 4 \), where \( k, l > 0 \), find the sum of the squares of the distances from the points of intersection, \( A \) and \( B \), to the origin. These points are known to be 6 units apart.
    <br>
    <br>
    <br>
    <b>Solution:</b>
    <br>
    <br>
    <br>
    1. <b>Set Up the Intersection Equation:</b>
    <br>
    <br>
       Start by setting the parabola equal to the line to find the x-coordinates of points \( A \) and \( B \):
       <br><br>
       \[
       kx^2 - 2kx + l = 4
       \]
       <br>
       Rearrange to form a standard quadratic equation:
       <br><br>
       \[
       kx^2 - 2kx + (l - 4) = 0
       \]
    <br>
    <br>
    <br>
    2. <b>Solve the Quadratic Equation:</b>
    <br>
    <br>
       Apply the quadratic formula \( x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \) to solve for \( x \):
    <br><br>
       \[
       x = \frac{2k \pm \sqrt{4k^2 - 4k(l - 4)}}{2k} = 1 \pm \sqrt{1 - \frac{l - 4}{k}}
       \]
    <br>
       Let \( x_A = 1 + \sqrt{1 - \frac{l-4}{k}} \) and \( x_B = 1 - \sqrt{1 - \frac{l-4}{k}} \).
    <br>
    <br>
    <br>
    3. <b>Distance Between Points \( A \) and \( B \):</b>
    <br>
    <br>
       Given \( |x_A - x_B| = 6 \), compute:
    <br><br>
       \[
       \left|2\sqrt{1 - \frac{l - 4}{k}}\right| = 6 \implies \sqrt{1 - \frac{l - 4}{k}} = 3
       \]
    <br>
       Solving for \( l \) and \( k \):
    <br><br>
       \[
       1 - \frac{l - 4}{k} = 9 \implies \frac{l - 4}{k} = -8 \implies l - 4 = -8k \implies l = -8k + 4
       \]
    <br>
    <br>
    <br>
    4. <b>Calculate Distances from Origin:</b>
    <br>
    <br>
       Using the x-coordinates \( x_A = 4 \) and \( x_B = -2 \) and y-coordinate \( y = 4 \):
    <br>
    <br>
       \[
       d_A = \sqrt{x_A^2 + 4^2} = \sqrt{16 + 16} = \sqrt{32} = 4\sqrt{2}
       \]
    <br>
       \[
       d_B = \sqrt{x_B^2 + 4^2} = \sqrt{4 + 16} = \sqrt{20} = 2\sqrt{5}
       \]
    <br>
    <br>
    <br>
    5. <b>Sum of Squares of Distances:</b>
    <br>
    <br>
       Compute the sum of squares:
    <br><br>
       \[
       d_A^2 + d_B^2 = (4\sqrt{2})^2 + (2\sqrt{5})^2 = 32 + 20 = 52
       \]
    <br>
    <br>
    <br>
    <b>Conclusion:</b>
    <br><br>
    The sum of the squares of the distances from points \( A \) and \( B \) to the origin is \( 52 \).
</div>

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">COMPETITION HOST(S)/CONTRIBUTOR(S)</b>
    <br>

<b><u>XTX Markets</u></b> is a leading algorithmic trading company and has over 200 employees based in London, Paris, New York, Mumbai, Yerevan and Singapore. XTX provides liquidity in the Equity, FX, Fixed Income and Commodity markets and trades over 250bn a day across markets.
<br><br>
XTX Markets' expansive research cluster contains 100,000 cores and 20,000 A/V100 GPUs and is growing. It also has 390 petabytes of usable storage and 7.5 petabytes of RAM. Alongside rich datasets and advanced technological infrastructure we are at the forefront of the crossover of finance and technology.
<br><br>
XTX Markets’ philanthropy focuses on maths and science education and research, alongside other areas such as academic sanctuaries, carbon removal and an employee matching programme. Since 2017, XTX Markets has donated over £100mn to charities and good causes, establishing it as a major donor in the UK and globally.
<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.3 <b>DATASET INFORMATION</b></h3>

<hr>

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">HIGH LEVEL DATA SUMMARY</b>

The AI Mathematical Olympiad (AIMO) Prize competition is designed to enhance the mathematical reasoning capabilities of AI by engaging models in a set of 110 mathematics problems similar to those found in high school competitions like the AIME. The competition challenges AI to predict integer solutions to these problems, with solutions constrained to values between 0 and 999. This initiative provides a rigorous platform for assessing AI mathematical reasoning in a controlled environment, devoid of the typical train-test data leakage issues.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">DATA COMPOSITION</b>

The dataset consists of 110 math problems divided across a training set of 10 problems and two test sets, each containing 50 unique problems. These problems span various mathematical subjects including arithmetic, algebra, and geometry, presented in text format with mathematical expressions formatted in LaTeX.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">DATA FILE DESCRIPTIONS</b>

<b><code>train.csv</code>:</b>
* Contains 10 problems used for training models. Each record includes:
    - <b><code>id</code> (string):</b> A unique identifier for each problem.
    - <b><code>problem</code> (string):</b> The text of the problem, including LaTeX for mathematical notation.
    - <b><code>answer</code> (int):</b> The integer answer for the problem, between 0 and 999.

<b><code>test.csv</code>:</b>
* Contains 50 placeholder problems for submission trials; these will be replaced with the actual problems during the scoring phase. Each record contains:
    - <b><code>id</code> (string):</b> A unique identifier corresponding to each problem.
    - <b><code>problem</code> (string):</b> Placeholder text of the problem; not representative of the final test problems.

<b><code>sample_submission.csv</code>:</b>
* Provides a format template for submissions. Each record includes:
    - <b><code>id</code> (string):</b> The problem identifier.
    - <b><code>answer</code> (int):</b> Participants must fill in their predicted integer answer for each problem.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">UNIQUE ASPECTS OF THE DATASET</b>

This dataset is specifically engineered to avoid overlap with publicly available data, thus eliminating the risk of train-test leakage. This clean separation ensures a fair evaluation of a model's capability to solve mathematical problems from scratch. Additionally, all responses must be reported modulo 1000, introducing a unique element of complexity to the answering process.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">DATASET CHALLENGES AND OPPORTUNITIES</b>

The dataset's limited size poses a challenge for model training, requiring efficient generalization from minimal examples. The range of problem complexity, from basic arithmetic to advanced geometric reasoning without visual aids, demands robust textual and numerical interpretation capabilities from participating AI models. These challenges, however, provide valuable opportunities for breakthroughs in AI's mathematical reasoning and its applications in mathematically intensive fields.
<a id=""imports""></a>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""imports"">3&nbsp;&nbsp;IMPORTS&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

print(""\n... PIP INSTALLS STARTING ...\n"")
!pip uninstall -y torch
!pip install -U --no-index --find-links=/kaggle/input/vllm-whl -U vllm
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl
!pip install -U --upgrade /kaggle/input/vllm-t4-fix/grpcio-1.62.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl
!pip install -U --upgrade /kaggle/input/vllm-t4-fix/ray-2.11.0-cp310-cp310-manylinux2014_x86_64.whl
print(""\n... PIP INSTALLS COMPLETE ...\n"")

print(""\n... IMPORTS STARTING ...\n"")
print(""\n\tVERSION INFORMATION"")
# Competition Specific Imports from HF and torch
from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    BitsAndBytesConfig, 
    AutoConfig,
    pipeline,
    set_seed as transformers_set_seed
)
from vllm import LLM, SamplingParams
import torch; torch.backends.cuda.enable_mem_efficient_sdp(False)
import aimo

## Patch issue from https://github.com/vllm-project/vllm/issues/1116
# if torch.cuda.device_count()>1:
#     import ray
#     ray.shutdown()
#     ray.init(num_gpus=torch.cuda.device_count())

import pandas as pd; pd.options.mode.chained_assignment = None; pd.set_option('display.max_columns', None);
import numpy as np; print(f""\t\t– NUMPY VERSION: {np.__version__}"");
import sympy as sp; print(f""\t\t– SYMPY VERSION: {sp.__version__}"");
from sympy.parsing.latex import parse_latex
import sklearn; print(f""\t\t– SKLEARN VERSION: {sklearn.__version__}"");

# Built-In Imports (mostly don't worry about these)
from typing import Iterable, Any, Callable, Generator
from kaggle_datasets import KaggleDatasets
from dataclasses import dataclass
from collections import Counter
from datetime import datetime
from zipfile import ZipFile
from glob import glob
import subprocess
import warnings
import requests
import textwrap
import hashlib
import imageio
import IPython
import urllib
import zipfile
import pickle
import random
import shutil
import string
import json
import copy
import math
import time
import gzip
import ast
import sys
import io
import gc
import re
import os

# Visualization Imports (overkill)
from IPython.core.display import HTML, Markdown
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm; tqdm.pandas();
import plotly.express as px
import seaborn as sns
from PIL import Image, ImageEnhance; Image.MAX_IMAGE_PIXELS = 5_000_000_000;
import matplotlib; print(f""\t\t– MATPLOTLIB VERSION: {matplotlib.__version__}"");
import plotly
import PIL

def seed_it_all(seed=7):
    """""" Attempt to be Reproducible """"""
    os.environ['PYTHONHASHSEED'] = str(seed)
    random.seed(seed)
    np.random.seed(seed)
    # tf.random.set_seed(seed)
    
seed_it_all()

print(""\n\n... IMPORTS COMPLETE ...\n"")
<a id=""setup""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""setup"">4&nbsp;&nbsp;SETUP & HELPER FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.0 FUNCTIONS FROM <b>OTHER KAGGLERS</b> 🩵</h3>
<hr><br>

**Give me time to populate this... I am using rewritten variants of quite a few functions and will update with acknowledgement later on... For now I will list a few notebooks to go give upvotes to**
* https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
* https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
* https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
* https://www.kaggle.com/code/bsmit1659/aimo-vllm-accelerated-tot-sc-deepseekmath/notebook

<br>

<b>Thanks to <a href=""https://www.kaggle.com/olyatsimboy"">Olga Tsymboi </a></b> for the information on how to run 2xT4 with vLLM</b>

<br>
<br>

**DETAILS OF `sampling_params`**

```
n: Number of output sequences to return for the given prompt.

best_of: Number of output sequences that are generated from the prompt.
         From these `best_of` sequences, the top `n` sequences are returned.
         `best_of` must be greater than or equal to `n`. This is treated as
         the beam width when `use_beam_search` is True. By default, `best_of`
         is set to `n`.

presence_penalty: Float that penalizes new tokens based on whether they
                  appear in the generated text so far. Values > 0 encourage the model
                  to use new tokens, while values < 0 encourage the model to repeat
                  tokens.

frequency_penalty: Float that penalizes new tokens based on their
                   frequency in the generated text so far. Values > 0 encourage the
                   model to use new tokens, while values < 0 encourage the model to
                   repeat tokens.

repetition_penalty: Float that penalizes new tokens based on whether
                    they appear in the prompt and the generated text so far. Values > 1
                    encourage the model to use new tokens, while values < 1 encourage
                    the model to repeat tokens.

temperature: Float that controls the randomness of the sampling. Lower
             values make the model more deterministic, while higher values make
             the model more random. Zero means greedy sampling.

top_p: Float that controls the cumulative probability of the top tokens
       to consider. Must be in (0, 1]. Set to 1 to consider all tokens.

top_k: Integer that controls the number of top tokens to consider. Set
       to -1 to consider all tokens.

min_p: Float that represents the minimum probability for a token to be
       considered, relative to the probability of the most likely token.
       Must be in [0, 1]. Set to 0 to disable this.

seed: Random seed to use for the generation.

use_beam_search: Whether to use beam search instead of sampling.

length_penalty: Float that penalizes sequences based on their length.
                Used in beam search.

early_stopping: Controls the stopping condition for beam search. It
                accepts the following values: `True`, where the generation stops as
                soon as there are `best_of` complete candidates; `False`, where an
                heuristic is applied and the generation stops when is it very
                unlikely to find better candidates; `""never""`, where the beam search
                procedure only stops when there cannot be better candidates
                (canonical beam search algorithm).

stop: List of strings that stop the generation when they are generated.
      The returned output will not contain the stop strings.

stop_token_ids: List of tokens that stop the generation when they are
                generated. The returned output will contain the stop tokens unless
                the stop tokens are special tokens.

include_stop_str_in_output: Whether to include the stop strings in
                            output text. Defaults to False.

ignore_eos: Whether to ignore the EOS token and continue generating
            tokens after the EOS token is generated.

max_tokens: Maximum number of tokens to generate per output sequence.

min_tokens: Minimum number of tokens to generate per output sequence
            before EOS or stop_token_ids can be generated

logprobs: Number of log probabilities to return per output token.
          Note that the implementation follows the OpenAI API: The return
          result includes the log probabilities on the `logprobs` most likely
          tokens, as well the chosen tokens. The API will always return the
          log probability of the sampled token, so there  may be up to
          `logprobs+1` elements in the response.

prompt_logprobs: Number of log probabilities to return per prompt token.

detokenize: Whether to detokenize the output. Defaults to True.

skip_special_tokens: Whether to skip special tokens in the output.

spaces_between_special_tokens: Whether to add spaces between special
                               tokens in the output.  Defaults to True.

logits_processors: List of functions that modify logits based on
                   previously generated tokens.

truncate_prompt_tokens: If set to an integer k, will use only the last k
                        tokens from the prompt (i.e., left truncation). Defaults to None
                        (i.e., no truncation).
```
def load_vllm_model_and_tokenizer(
    model_path: str, 
    model_dtype: str = ""half"", 
    enforce_eager: bool = True, 
    gpu_memory_utilization: float = 0.999, 
    swap_space: int = 4, 
    max_model_len: int = 1024, 
    kv_cache_dtype: str = ""fp8_e5m2"", 
    tensor_parallel_size: int | str = ""system"",
):
    """"""Initializes and returns the specified language model and its associated tokenizer.
    
    This is primarily used in the context of this competition for the DeepSeek Math RL model.
    
    While the function and descriptions are mine, the underlying code comes from this notebook: 
        https://www.kaggle.com/code/bsmit1659/aimo-vllm-accelerated-tot-sc-deepseekmath/notebook

    Args:
        model_path (str): 
            The path to the pre-trained model's checkpoint file on the local filesystem.
            This file contains the learned weights and parameters of the language model.
        model_dtype (str, optional): 
            The data type to use for the model's computations.
            Defaults to ""half"" which represents 16-bit half-precision floating-point format.
            This can help reduce memory usage and improve performance on GPUs.
        enforce_eager (bool, optional): 
            Whether to enforce eager execution mode for the model.
            Eager execution allows for immediate evaluation of operations without building a computational graph.
        gpu_memory_utilization (float, optional): 
            The fraction of available GPU memory to allocate for the model.
            This controls the trade-off between memory usage and performance. Higher values allocate more memory
            to the model, potentially improving performance but limiting the available memory for other tasks.
        swap_space (int, optional): 
            The size of the swap space (in GB) to use for model loading.
            Swap space is used when the model's memory requirements exceed the available GPU memory.
            It allows the model to be loaded by swapping data between GPU memory and CPU memory.
        max_model_len (int, optional): 
            The maximum sequence length (in tokens) that the model can process.
            This determines the maximum context size the model can handle in a single forward pass.
            Longer sequences will be truncated to fit within this limit.
        kv_cache_dtype (str, optional): 
            The data type to use for the key-value cache in the model.
            The key-value cache stores intermediate activations to speed up computation.
            This can help reduce memory usage while maintaining acceptable precision.
            Defaults to ""fp8_e5m2"" which represents:
                - an 8-bit floating-point format 
                - with exponent bias (5)
                - and mantissa size (2)            
        tensor_parallel_size (int | str, optional): 
            The number of GPU devices to use for tensor parallelism.
            Tensor parallelism splits the model across multiple GPUs to distribute the computation.
            Defaults to 1, which means no tensor parallelism is used. Use 2 for 2xT4.
            If set to ""system"" than torch.cuda.device_count() will be used.

    Returns:
        tuple: 
            A tuple containing the initialized DeepSeek language model (LLM) and its associated tokenizer.
                - llm (LLM): The initialized DeepSeek language model.
                - tokenizer (Tokenizer): The tokenizer associated with the language model.
    """"""
    _llm = LLM(
        model=model_path,
        dtype=model_dtype,
        enforce_eager=enforce_eager,
        gpu_memory_utilization=gpu_memory_utilization,
        swap_space=swap_space,
        max_model_len=max_model_len,
        kv_cache_dtype=kv_cache_dtype,
        tensor_parallel_size=tensor_parallel_size if isinstance(tensor_parallel_size, int) else torch.cuda.device_count()
    )
    _tokenizer = _llm.get_tokenizer()
    return _llm, _tokenizer


# https://www.kaggle.com/code/simjeg/platypus2-70b-with-wikipedia-rag
def clean_memory() -> None:
    """"""Function to clean RAM & vRAM""""""
    gc.collect()
    ctypes.CDLL(""libc.so.6"").malloc_trim(0)
    torch.cuda.empty_cache()
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.1 GENERIC HELPER FUNCTIONS</h3>
<hr><br>

These are some functions I carry around with me that I find commonly helpful.

**There are also a few dataset loading functions included here just to ensure they fall before the setup cell**

<br>
def flatten_l_o_l(nested_list):
    """""" Flatten a list of lists into a single list.

    Args:
        nested_list (Iterable): 
            – A list of lists (or iterables) to be flattened.

    Returns:
        A flattened list containing all items from the input list of lists.
    """"""
    return [item for sublist in nested_list for item in sublist]


def print_ln(symbol=""-"", line_len=110, newline_before=False, newline_after=False):
    """""" Print a horizontal line of a specified length and symbol.

    Args:
        symbol (str, optional): 
            – The symbol to use for the horizontal line
        line_len (int, optional): 
            – The length of the horizontal line in characters
        newline_before (bool, optional): 
            – Whether to print a newline character before the line
        newline_after (bool, optional): 
            – Whether to print a newline character after the line
            
    Returns:
        None; A divider with pre/post new-lines (optional) is printed
    """"""
    if newline_before: print();
    print(symbol * line_len)
    if newline_after: print();
        
        
def display_hr(newline_before=False, newline_after=False):
    """""" Renders a HTML <hr>

    Args:
        newline_before (bool, optional): 
            – Whether to print a newline character before the line
        newline_after (bool, optional): 
            – Whether to print a newline character after the line
            
    Returns:
        None; A divider with pre/post new-lines (optional) is printed
    """"""
    if newline_before: print();
    display(HTML(""<hr>""))
    if newline_after: print();


def wrap_text(text, width=88):
    """"""Wrap text to a specified width.

    Args:
        text (str): 
            - The text to wrap.
        width (int): 
            - The maximum width of a line. Default is 88.

    Returns:
        str: The wrapped text.
    """"""
    return textwrap.fill(text, width)


def wrap_text_by_paragraphs(text, width=88):
    """"""Wrap text by paragraphs to a specified width.

    Args:
        text (str): 
            - The text containing multiple paragraphs to wrap.
        width (int): 
            - The maximum width of a line. Default is 88.

    Returns:
        str: The wrapped text with preserved paragraph separation.
    """"""
    paragraphs = text.split('\n')  # Assuming paragraphs are separated by newlines
    wrapped_paragraphs = [textwrap.fill(paragraph, width) for paragraph in paragraphs]
    return '\n\n'.join(wrapped_paragraphs)


def hide_asy_text(text: str) -> tuple[str, dict[str, str]]:
    """"""Replaces text within [asy]...[/asy] blocks with unique placeholders.

    Args:
        text (str): 
            The original text containing blocks to be hidden.

    Returns:
        tuple[str, dict[str, str]]: 
            A tuple containing the modified text with placeholders
            and a dictionary mapping placeholders to the original text blocks.
    """"""
    pattern = r'\[asy\](.*?)\[/asy\]'
    placeholders = {}

    def _replacer(match: re.Match) -> tuple[str, dict[str, str]]:
        """"""This function is used to replace the text within [asy]...[/asy] blocks.

        It replaces the text with a unique placeholder and stores the original text.

        Args:
            match (re.Match): The matched object.

        Returns:
            str: The original text corresponding to the placeholder.
        """"""
        original = match.group(1)
        placeholder = f""UNIQUE_STRING_{len(placeholders)}""
        placeholders[placeholder] = original
        return f""[asy]{placeholder}[/asy]""

    modified_text = re.sub(pattern, _replacer, text)
    return modified_text, placeholders


def unhide_asy_text(text: str, placeholders: dict[str, str]) -> str:
    """"""Restores the original text blocks within [asy]...[/asy] from the placeholders.

    Args:
        text (str):
            The text with placeholders to be restored.
        placeholders (dict[str, str]):
            A dictionary mapping placeholders back to the original text.

    Returns:
        str: The text with all placeholders restored to their original content.
    """"""
    pattern = r'\[asy\](UNIQUE_STRING_\d+)\[/asy\]'

    def _replacer(match: re.Match) -> str:
        """"""This function is used to replace the placeholders with the original text.

        Args:
            match (re.Match): The matched object.

        Returns:
            str: The original text corresponding to the placeholder.
        """"""
        placeholder = match.group(1)
        return f""[asy]{placeholders.get(placeholder, 'ERROR: Text not found')}[/asy]""

    restored_text = re.sub(pattern, _replacer, text)
    return restored_text


def load_aops_dataset_as_df(
        csv_path: str,
        coerce_answers: bool = True,
        drop_diagram_questions: bool = True,
        remove_asy_blocks_from_solution: bool = True
) -> pd.DataFrame:
    """"""This will return a dataframe for the Art of Problem Solving Dataset based on various options.

    Options include:
        - Fixing the answer column by coercing values
            - removing lfill 0s
            - replacing periods added to the right side incorrectly
            - removing commas
        - Removing problems with Asymptote diagrams in problem description (as no diagrams are found in test set)
        - Removing parts Asymptote diagrams from solution description (as no diagrams are found in test set)

    Args:
        csv_path (str): The path to the csv file
        coerce_answers (bool): Whether to fix the answer column
        drop_diagram_questions (bool): Whether to drop questions with Asymptote diagrams
        remove_asy_blocks_from_solution (bool): Whether to remove Asymptote blocks from solution

    Returns:
        pd.DataFrame: The loaded dataset
    """"""
    _df = pd.read_csv(csv_path)
    
    if coerce_answers:
        _df[""answer""] = _df[""answer""].apply(lambda x: x[:-1] if str(x)[-1]==""."" else x)
        _df[""answer""] = _df[""answer""].apply(lambda x: x.replace("","", """"))
        _df[""answer""] = _df[""answer""].apply(lambda x: int(x) if str(x).startswith(""0"") and ""."" not in str(x) else x)
    
    if drop_diagram_questions:
        _df = _df[_df.solution.str.lower().str.contains(""[asy]"")]
    
    if remove_asy_blocks_from_solution:
        _df[""solution""] = _df[""solution""].apply(lambda text: re.sub(r'\[asy\](.*?)\[/asy\]', '', text))
        
    return _df.reset_index(drop=True)
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.2 <b>LOAD</b> THE DATASET(S)</h3>
<hr><br>

We also define path information and other constants that are helpful in establishing early.

<br>

**SIDE NOTE:** `.asy` or `[asy]` refers to the <b><a href=""https://asymptote.sourceforge.io/"">Asymptote</a></b> vector plotting language. I couldn't figure out a way to plot it inline. We generally want to remove/ignore these questions anyway...
# ROOT PATHS
WORKING_DIR = ""/kaggle/working""
INPUT_DIR = ""/kaggle/input""
COMPETITION_DIR = os.path.join(INPUT_DIR, ""ai-mathematical-olympiad-prize"")
EXT_DATASET_DIR = os.path.join(INPUT_DIR, ""/kaggle/input/external-datasets-after-preprocessing-for-aimo"")

# COMPETITION FILE PATHS
SS_CSV_PATH = os.path.join(COMPETITION_DIR, ""sample_submission.csv"")
COMP_TRAIN_CSV_PATH = os.path.join(COMPETITION_DIR, ""train.csv"")
COMP_TEST_CSV_PATH = os.path.join(COMPETITION_DIR, ""test.csv"")

# DEFINE COMPETITION DATAFRAMES
print(""\n\n... SAMPLE SUBMISSION DATAFRAME ...\n"")
ss_df = pd.read_csv(SS_CSV_PATH)
display(ss_df)

print(""\n\n... COMPETITION TRAIN DATAFRAME ...\n"")
comp_train_df = pd.read_csv(COMP_TRAIN_CSV_PATH)
display(comp_train_df)

if os.path.isfile(COMP_TEST_CSV_PATH):
    print(""\n\n... COMPETITION TEST DATAFRAME ...\n"")
    comp_test_df = pd.read_csv(COMP_TEST_CSV_PATH)
    display(comp_test_df)
else:
    comp_test_df = comp_train_df.iloc[:1]
    
# DEFINE EXTERNAL DATASET PATHS

EXT_AIMO_1 = os.path.join(INPUT_DIR, ""aimo-external-dataset"", ""external_df.csv"")  # GSM8K and MATH
EXT_AIMO_2 = os.path.join(INPUT_DIR, ""amio-parsed-art-of-problem-solving-website"", ""parsed_ArtOfProblemSolving.csv"")  # Art of Problem Solving Website

# DEFINE EXTERNAL DATASET DATAFRAMES
print(""\n\n... EXTERNAL DATASET 1 DATAFRAME - GSM8K and MATH ...\n"")
ext_aimo_1_df = pd.read_csv(EXT_AIMO_1)
display(ext_aimo_1_df)

print(""\n\n... EXTERNAL DATASET 2 DATAFRAME - Art of Problem Solving Website ...\n"")
ext_aimo_2_df = load_aops_dataset_as_df(EXT_AIMO_2)
display(ext_aimo_2_df)

# DEFINE MODEL PATHS
DEEPSEEK_PATH = os.path.join(INPUT_DIR, ""deepseek-math"")
MISTRAL_PATH = os.path.join(INPUT_DIR, ""open-math-mistral"")
<a id=""eda""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""eda"">5&nbsp;&nbsp;EXPLORATORY DATA ANALYSIS&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.1 <b>EXPLORE</b> THE ART OF PROBLEM SOLVING EXTERNAL DATASET</h3>
<hr><br>

We also define some helpful functions along the way
def get_problem(df: pd.DataFrame, problem_id: str = None, problem_str: str = None, problem_link: str = None) -> pd.DataFrame:
    """"""This function will retrieve a dataframe subset of the aops_df that matches the desired problem.
    
    If no problem specifier is provided then a random problem will be retrieved.
    
    Args:
        df (pd.DataFrame): The dataframe containing problem information.
        problem_id (str, optional): The specific problem ID to filter by.
        problem_str (str, optional): A substring of the problem text to filter by.
        problem_link (str, optional): The specific problem link to filter by.
    
    Raises:
        ValueError: If no criteria are provided and the dataframe is empty.
    
    Returns:
        pd.DataFrame: A subset of `aops_df` based on the provided criteria or a single random problem if no criteria are provided.
    """"""
    # Create a copy to avoid modifying the original dataframe
    _df = copy.deepcopy(df)
    
    # Check if any criteria is provided
    if problem_id is not None:
        _df = _df[_df['problem_id'] == problem_id]
    if problem_str is not None:
        _df = _df[_df['problem'].str.contains(problem_str, case=False, na=False)]
    if problem_link is not None:
        _df = _df[_df['link'] == problem_link]

    # If no criteria is specified, select a random problem
    if problem_id is None and problem_str is None and problem_link is None:
        if _df.empty:
            raise ValueError(""The input dataframe is empty. Cannot select a random problem."")
        _df = get_problem(_df, problem_id=_df.problem_id.sample(1).values[0])
    return _df.reset_index(drop=True)


def problem_to_html(
    problem_str: str,
    problem_link: str | None = None, 
    problem_id: str | None = None,
    bg_color: str = ""#f5f5f5""
) -> HTML:
    """"""Generates an HTML representation of a problem description, optionally including a link.

    Args:
        problem_str (str): The text describing the problem.
        problem_link (Optional[str]): A URL linking to further details about the problem, defaults to None.
        bg_color (str): The background color for the HTML div element, defaults to ""#f5f5f5"".

    Returns:
        HTML: An HTML object suitable for display in IPython environments.
    """"""
    # Remove ASY text as we don't want to adjust it's formatting
    problem_str, placeholders = hide_asy_text(problem_str)
    
    #  -- Prettify  --
    _html_str = f'<div style=""background-color: {bg_color}; border-radius: 10px; padding: 20px; margin: 20px;""> <b>PROBLEM:</b><br><br>{problem_str.replace(""..."", ""...<br><br>"").replace(""."", "".<br><br>"")}</div>'
    if problem_link is not None and not pd.isna(problem_link):
        _html_str = _html_str.replace(""PROBLEM:"", 'PROBLEM  <a href=""'+problem_link+'"">[LINK]</a>:')
    if problem_id is not None:
        _html_str = _html_str.replace(""PROBLEM"", f""PROBLEM ID: {problem_id}"")
    
    # Put the ASY text back in
    _html_str = unhide_asy_text(_html_str, placeholders)
    
    return HTML(_html_str)
                
                
# Basic Hex Colour for Success is #e9fce9
def solution_to_html(solution_str: str, solution_num: int | str | None = None, solution_value: int | float | str | None = None, bg_color: list[str] | str = ""pastel""):
    """"""Generates an HTML representation of a solution with dynamic background colors and optional details.

    Args:
        solution_str (str): 
            The text describing the solution.
        solution_num (int | str, optional): 
            A number or identifier for the solution, defaults to None.
        solution_value (int | float | str, optional): 
            A value associated with the solution.
        bg_color (list[str] | str, optional): 
            The background color(s) for the HTML div element. 
            This can be a hex color, a list of hex colors, or a seaborn palette name, defaults to ""pastel"".

    Returns:
        HTML: An HTML object suitable for display in IPython environments.

    """"""
    def get_colors(color_input: str | list[str]) -> list[str]:
        """"""Resolves the background color input into a list of hexadecimal color codes.

        Args:
            color_input (str | list[str]): 
                A hex color, a list of hex colors, or a seaborn palette name.

        Returns:
            list[str]: A list of hexadecimal color codes.
        """"""
        if isinstance(color_input, str) and color_input.startswith(""#""):
            return [color_input]
        elif isinstance(color_input, list) and all(isinstance(item, str) for item in color_input):
            return color_input
        else:
            return sns.color_palette(color_input).as_hex()
    
    # Remove ASY text as we don't want to adjust it's formatting
    solution_str, placeholders = hide_asy_text(solution_str)
    
    # -- Prettify --
    # Resolve background colors using the internal function
    colors = get_colors(bg_color)
    # Generate the main HTML string for the solution
    color_index = solution_num % len(colors) if solution_num is not None else 0
    _html_str = f'<div style=""background-color: {colors[color_index]}; border-radius: 10px; padding: 20px; margin: 20px;""> <b>SOLUTION:</b><br><br>{solution_str.replace(""..."", ""...<br><br>"").replace(""."", "".<br><br>"")}</div>'
    # Add solution number if specified
    if solution_num is not None:
        _html_str = _html_str.replace(""SOLUTION:"", f""SOLUTION #{solution_num}:"")
    if solution_value is not None:
        _html_str=_html_str.replace(""</div>"", f'<br><br><b>SOLUTION VALUE: <font color=""red"">{solution_value}</font></b><br><br></div>')
    
    # Put the ASY text back in
    _html_str = unhide_asy_text(_html_str, placeholders)
    _html_str = _html_str.replace(r""\["", r""<br><br>\["").replace(r""\]"", r""\]<br><br>"")
    return HTML(_html_str)


def review_problem(df: pd.DataFrame, problem_id: str | None = None, show_all_solutions: bool = False):
    """"""This function will retrieve a dataframe subset of the aops_df that matches the desired problem.
    
    It will then iterate over the provided solutions and display the example in an asthetically pleasing way.    
    If no problem specifier is provided then a random problem will be retrieved.
    
    Args:
        _df (pd.DataFrame): The dataframe containing problem information.
        problem_id (str, optional): The specific problem ID to filter by.
        show_all_solutions (bool, optional): Whether to show all or just the first solution
        
    Raises:
        ValueError: If no criteria are provided and the dataframe is empty.
    
    Returns:
        pd.DataFrame: A subset of `aops_df` based on the provided criteria or a single random problem if no criteria are provided.
    """"""
    _df = get_problem(df, problem_id=problem_id)
    _df_link = _df.link[0] if ""link"" in _df.columns else None
    display(problem_to_html(_df.problem[0], _df_link, _df.problem_id[0]))

    for i, (_, row) in enumerate(_df.iterrows()):
        display(solution_to_html(row.solution, i+1, row.answer))
        if not show_all_solutions:
            break
    
    return _df

### Review a random problem
# df = review_problem(ext_aimo_2_df)

N_EX = 2
print(f""\n... SHOWING {N_EX} RANDOM QUESTIONS (OUT OF A POSSIBLE {len(ext_aimo_2_df)}) FROM THE AMIO PARSED ART OF PROBLEM SOLVING DATASET ...\n"")
for i in range(N_EX):
    df = review_problem(ext_aimo_2_df, show_all_solutions=False)
    display(df)
    display_hr(newline_after=True, newline_before=True)
    print(""\n\n"")
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.2 <b>EXPLORE</b> THE GSM8K+MATH EXTERNAL DATASET</h3>
<hr><br>

**NOTE: I am loading my version of the external aimo dataset in the cell below... I have left the commented out code showing how I generated it though**
* If you run this code the `extract_and_evaluate_solution` will hang on example `4557`... I have to manually kill and continue after this... I discard it after this.

def extract_and_evaluate_solution(text: str, re_pattern: str | None = r""\\boxed{((?:[^{}]+|{[^{}]*})*)}"", verbose: bool=False) -> int | float | None:
    """"""Extracts a LaTeX expression from a given text and evaluates it numerically.
    
    If a regex is provided but no match is found... the parsing will assume full text requires evaluation.
    
    Args:
        text (str): 
            The text containing the LaTeX expression.
        re_pattern (str, optional): 
            A regular expression pattern to extract the LaTeX expression enclosed in specific LaTeX commands like \\boxed{}. 
            If None, evaluates the entire text as a LaTeX expression.

    Returns:
        int | float | None: The evaluated numerical result as an integer or float, or None if no expression is found or an error occurs in parsing.
    """"""
    # Use the provided regular expression pattern, or default to the entire text
    latex_expression = text
    if re_pattern:
        match = re.search(re_pattern, text)
        if match:
            latex_expression = match.group(1)
    else:
        latex_expression = text
    
    try:
        # Convert LaTeX to a sympy expression
        sympy_expression = sp.sympify(parse_latex(latex_expression))

        # Evaluate the expression to a numerical result and determine type
        evaluated_expression = sympy_expression.evalf()
        if evaluated_expression.is_Integer:
            return int(evaluated_expression)
        else:
            return float(evaluated_expression)
    except Exception as e:
        if verbose:
            print(f""Error parsing or evaluating the expression: {e}"")
        return -1.0
    
    
# extract_and_evaluate_solution(""\\frac{211}{243}"")    

######### THE FOLLOWING CODE IS HOW I PROCESSED THE ORIGINAL DATASET INTO MY CURRENT DATASET I LOAD FROM DIRECTLY #########
# ext_aimo_1_df[""answer""] = -1.0
# ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""GSM8K"", ""answer""] = ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""GSM8K""][""solution""].apply(lambda x: float(x.rsplit(""####"", 1)[-1].replace("","", """").strip()))
#
# extracted_answers = []
# _start_idx = _0
# for i, x in enumerate(tqdm(ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""MATH""][""solution""].values[_start_idx:])):
#     _idx = _start_idx+i
#     extracted_answers.append(extract_and_evaluate_solution(x.replace(""pi"", ""3.14159"")))
#
# ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""MATH"", ""answer""] = extracted_answers
# ext_aimo_1_df[""answer""] = ext_aimo_1_df[""answer""].apply(lambda x: int(x) if ""."" in str(x) and float(x)==float(int(x)) else float(x))
# ext_aimo_1_df = ext_aimo_1_df[ext_aimo_1_df[""answer""]!=-1].reset_index(drop=True)
# ext_aimo_1_df.insert(0, ""problem_id"", pd.Series(ext_aimo_1_df.index.astype(str)).apply(lambda x: f""{x:>05}"")+""_""+ext_aimo_1_df.source+""_""+ext_aimo_1_df.stage)
#
# ext_aimo_1_df.to_csv(""ext_aimo_1_preprocessed.csv"", index=False)
# ext_aimo_2_df.to_csv(""ext_aimo_2_preprocessed.csv"", index=False)

# ext_aimo_df = pd.concat([ext_aimo_2_df, ext_aimo_1_df])[[""problem_id"", ""problem"", ""solution"", ""answer"", ""link"", ""source"", ""level"", ""type"", ""stage"", ""letter""]].reset_index(drop=True)
# ext_aimo_df[""source""] = ext_aimo_df[""source""].fillna(""AOPS"")
# ext_aimo_df[""stage""] = ext_aimo_df[""stage""].fillna(""train"")
# ext_aimo_df.to_csv(""ext_aimo_preprocessed.csv"", index=False)
#################################################################################################################

ext_aimo_df = pd.read_csv(os.path.join(EXT_DATASET_DIR, ""ext_aimo_preprocessed.csv""))
ext_aimo_1_df = pd.read_csv(os.path.join(EXT_DATASET_DIR, ""ext_aimo_1_preprocessed.csv""))
ext_aimo_2_df = pd.read_csv(os.path.join(EXT_DATASET_DIR, ""ext_aimo_2_preprocessed.csv""))
                            
display(ext_aimo_df)
N_EX = 2
print(f""\n... SHOWING {N_EX} RANDOM QUESTIONS (OUT OF A POSSIBLE {len(ext_aimo_1_df)}) FROM THE AMIO EXTERNAL DATASET (GSM8K AND MATH) ...\n"")
for i in range(N_EX):
    df = review_problem(ext_aimo_1_df)
    display(df)
    display_hr(newline_after=True, newline_before=True)
    print(""\n\n"")
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.3 <b>FILTER</b> AND FIX THE EXTERNAL DATASETS</h3>
<hr><br>

We want to remove/improve examples that do not match the requirements as defined in this competition. Specifically:
- Positive integer answer (drop offending rows)
- Remove multiple choice selection (remove text including multiple choice problems - or drop rows for simplicity)
- Remove [asy][/asy] from problems and solutions
- Rewrite #### ANSWER as //boxed{ANSWER}

We are only doing this on the joint dataset as that is what we plan to use.
def remove_multiple_choice_options_in_problem(problem_str):
    return problem_str.rsplit(""$\\textbf{(A"", 1)[0].rsplit(""$\\text{(A"", 1)[0].strip()

def remove_asy_block(text):
    if text.count(""[asy]"")>0:
        text = text.split(""[asy]"", 1)[0]+text.split(""[/asy]"", 1)[-1]
        remove_asy_block(text)
    return text.strip()

def fix_and_filter_external_data(df: pd.DataFrame, drop_non_pos_int_rows: bool = True):
    """"""""""""
    _df = df.copy()
    
    # Drop rows with infinite values in answer
    _df = _df[~_df[""answer""].replace([np.inf, -np.inf], np.nan).isna()]
    
    # Force answer to be appropriate dtype (int or float)
    _df[""answer""] =_df[""answer""].apply(lambda x: int(x) if float(int(x))==float(x) else float(x))
    
    # Remove multiple choices in problem string
    _df.loc[~pd.isna(_df[""letter""]), ""problem""] = _df.loc[~pd.isna(_df[""letter""]), ""problem""].apply(remove_multiple_choice_options_in_problem)
    
    # Replace hashtag solutions with boxed
    _df.loc[_df.solution.str.contains(""#### ""), ""solution""] = _df.loc[_df.solution.str.contains(""#### ""), ""solution""].apply(
        lambda x: x.strip().rsplit(""####"", 1)[0]+""$\\boxed{""+x.strip().rsplit(""####"", 1)[-1].strip()+""}$""
    )
    
    # Drop rows where the answer is less than 0 or non-int
    if drop_non_pos_int_rows:
        _df = _df[_df.answer.apply(lambda x: isinstance(x, int) and 0 <= x)]
        
    # Drop rows where there is 
    
    # Modulo the answer and store the original in a separate column
    _df[""original_answer""] = _df[""answer""].copy()
    _df[""answer""] = _df[""answer""].apply(lambda x: x%1000)
    
    return _df.reset_index(drop=True)
   
    
def filter_by_consensus(df: pd.DataFrame, id_col: str = 'problem_id', answer_col: str = 'answer') -> pd.DataFrame:
    """"""
    Filters a DataFrame to retain only rows where the answer has the majority consensus 
    for each unique problem identifier.

    This function groups the DataFrame by a problem identifier and determines the most frequent 
    answer for each group. Only rows where the answer matches the most frequent (mode) answer 
    for their corresponding group are retained.

    Args:
        df (pd.DataFrame): The DataFrame to filter.
        id_col (str, optional): The column name in the DataFrame that contains the problem identifiers. 
                                Defaults to 'problem_id'.
        answer_col (str, optional): The column name in the DataFrame that contains the answers. 
                                    Defaults to 'answer'.

    Returns:
        pd.DataFrame: A DataFrame containing only the rows with the majority consensus answer 
                      for each unique problem identifier.

    Example:
        >>> data = {'problem_id': ['1', '1', '1', '2', '2', '3'],
        ...         'answer': [10, 10, 4, 150, 150, 3]}
        >>> df = pd.DataFrame(data)
        >>> filtered_df = filter_by_consensus(df)
        >>> print(filtered_df)
    """"""
    _df = df.copy()
    
    # Calculate the mode of the answers for each problem_id
    mode_df = _df.groupby(id_col)[answer_col].agg(lambda x: pd.Series.mode(x)[0]).reset_index()
    mode_df.rename(columns={answer_col: 'mode_answer'}, inplace=True)

    # Merge this back with the original DataFrame to filter
    merged_df = _df.merge(mode_df, on=id_col)

    # Keep only rows where the answer matches the mode answer
    result_df = merged_df[merged_df[answer_col] == merged_df['mode_answer']]

    # Remove the temporary mode_answer column
    result_df = result_df.drop(columns=['mode_answer'])

    return result_df.reset_index(drop=True)

# Easy fixes
ext_aimo_df = fix_and_filter_external_data(ext_aimo_df)
# display(ext_aimo_df[ext_aimo_df.problem_id.isin(['00d3433e73bb281384e53ad5a87cdc86',
#        '212e80b4f9896d94a6c128f3d1726d38',
#        '33e99f18e99cdf0a415426283897830e',
#        '8655d580c2215b683eea607ff11e39ea',
#        '9194d5124ad28fd1ffc8b22d8930320e',
#        '9277096b27e0f04586690475ea517d1d',
#        '9958192892d058ab3cbc1ba71c827ac6',
#        'd59714d615a1262fb813437141ed2c62',
#        'ec2dbb5106882670665f78b963a6040c'])]
# )
# Consensus Fixes
ext_aimo_df = filter_by_consensus(ext_aimo_df)

display(ext_aimo_df)
<a id=""baseline""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""baseline"">6&nbsp;&nbsp;BASELINE SOLUTION AND EVALUATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.1 <b>DEFINE</b> THE REQUIRED FUNCTIONS TO HELP US</h3>
<hr><br>

I will attempt to attribute the base functions in the docstrings in coming versions... but please see my earlier mention of the notebooks that I used for help.
def set_seed(seed: int = 42) -> None:
    """"""Sets the seed for generating random numbers to ensure reproducibility.

    Args:
        seed (int): The seed number. Default is 42.
    """"""
    transformers_set_seed(seed)


def create_quantization_config(load_in_4bit: bool = True, 
                               quant_type: str = ""nf4"", 
                               compute_dtype = torch.bfloat16, 
                               use_double_quant: bool = True) -> BitsAndBytesConfig:
    """"""Creates a configuration for model quantization to optimize model size and inference speed.

    Args:
        load_in_4bit (bool): Whether to load models in 4-bit precision.
        quant_type (str): Type of quantization, 'nf4' for noise-free 4-bit.
        compute_dtype: Data type for computation, typically torch.bfloat16 for mixed precision.
        use_double_quant (bool): Whether to use double quantization.

    Returns:
        BitsAndBytesConfig: A configuration object for BitsAndBytes.
    """"""
    return BitsAndBytesConfig(
        load_in_4bit=load_in_4bit,
        bnb_4bit_quant_type=quant_type,
        bnb_4bit_compute_dtype=compute_dtype,
        bnb_4bit_use_double_quant=use_double_quant,
    )

def load_model_and_tokenizer(
    model_path: str = ""/kaggle/input/deepseek-math"", 
    quantization_config: BitsAndBytesConfig | None = None
) -> tuple:
    """"""Loads the tokenizer and model with specific quantization configurations.

    Args:
        model_path (str): Path to the model directory.
        quantization_config (BitsAndBytesConfig): Quantization configuration for the model.

    Returns:
        tuple: A tuple containing the loaded model and tokenizer.
    """"""
    config = AutoConfig.from_pretrained(model_path)
    config.gradient_checkpointing = True
    
    tokenizer = AutoTokenizer.from_pretrained(model_path)
    
    model = AutoModelForCausalLM.from_pretrained(
        model_path,
        device_map=""auto"",
        torch_dtype=""auto"",
        trust_remote_code=True,
        quantization_config=quantization_config,
        config=config
    )
    
    return model, tokenizer


def initialize_pipeline(model, tokenizer) -> pipeline:
    """"""Initializes a pipeline for text generation using the provided model and tokenizer.

    Args:
        model: The pre-trained model to be used for text generation.
        tokenizer: The tokenizer for text preprocessing.

    Returns:
        pipeline: A configured pipeline for text generation.
    """"""
    return pipeline(
        ""text-generation"",
        model=model,
        tokenizer=tokenizer,
        torch_dtype='auto',
        device_map=""auto""
    )


def setup_torch_backend(enable_mem_efficient_sdp: bool = False) -> None:
    """"""Configures PyTorch backend settings.

    Args:
        enable_mem_efficient_sdp (bool): Flag to enable memory efficient scatter-gather.
                                        Default is False.
    """"""
    torch.backends.cuda.enable_mem_efficient_sdp(enable_mem_efficient_sdp)
    
def naive_parse(answer: str) -> str:
    """"""Extracts the last contiguous sequence of digits from a given string.
    
    This function is based on the function that is floating around in the top scoring code notebooks.
    I'm not sure who the original author was... but once I know I will attribute accordingly.

    Args:
        answer: A string from which to extract the digit sequence.

    Returns:
        A string containing the last sequence of digits found in the input string.
        Returns an empty string if no digits are found.

    Examples:
        naive_parse(""example123test456"") returns ""456""
        naive_parse(""no digits here!"") returns """"
    """"""
    last_digits = ''
    found_digit = False

    for char in reversed(answer):
        if char.isdigit():
            last_digits += char
            found_digit = True
        elif found_digit:
            # Break the loop once the first non-digit is found after finding digits
            break
    
    # Reverse to correct the order of digits
    return last_digits[::-1]  


def postprocess_final_answer(expression: str, modulo: int = 1000) -> int:
    """"""Postprocesses the final answer by returning the rounded/modulod value.

    Args:
        expression: The mathematical expression to evaluate as a string. (raw final answer)
        modulo: The modulo value to use in the calculation.

    Returns:
        An integer result of the evaluated expression modulo the specified value.
    """"""
    try:
        result = round(float(eval(expression)))
        return result % modulo
    except Exception as e:
        print(f""Exception occured in `postprocess_final_answer`: {e}"")
        return -1

def execute_code(code: str, timeout_seconds: int = 7, filename: str = 'code_to_execute.py', modulo: int = 1000, sympy_star_import: bool = True) -> int:
    """"""Executes the given Python code snippet and processes the output.

    Args:
        code: The Python code to execute.
        timeout_seconds: Maximum allowed time for code execution in seconds.
        filename: The filename to which the code will be written before execution.
        modulo: The modulo value to use for processing the output.
        sympy_star_import: Whether to always import everything from sympy

    Returns:
        An integer result derived from the execution output or -1 if an error occurs.
    """"""
    try:
        with open(filename, 'w') as fout:
            fout.write(code if not sympy_star_import else 'from sympy import *\n'+code)

        batcmd = f'timeout {timeout_seconds} {sys.executable} {filename}'
        shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
        return postprocess_final_answer(shell_output, modulo)
    except Exception as e:
        print(f""Exception occured in `execute_code`: {e}"")
        return -1

def extract_and_process_math(result: str, modulo: int = 1000) -> int:
    """"""Extracts and evaluates the mathematical expression from the given string.

    Args:
        result: The string containing the expression in a LaTeX-like \\boxed{} format.
        modulo: The modulo value to use for the final result.

    Returns:
        An integer result of the evaluated expression or -1 if an error occurs.
    """"""
    try:
        result_output = re.findall(r'\\boxed\{(.*)\}', result)
        if result_output:
            expression = result_output[-1]
        else:
            expression = naive_parse(result)

        if expression:
            return postprocess_final_answer(expression, modulo)
        return -1
    except Exception as e:
        print(f""Exception occured in `extract_and_process_math`: {e}"")
        return -1

    
def process_output(output: str, timeout_seconds: int = 7, filename: str = 'code_to_execute.py', modulo: int = 1000) -> tuple:
    """"""Processes the provided output string to execute contained code and extract mathematical results.

    Args:
        output: The string that may contain Python code in triple backticks and/or a mathematical expression in \\boxed{}.
        timeout_seconds: Maximum allowed time for code execution in seconds.
        filename: The filename for saving and executing the Python code.
        modulo: The modulo value to use for processing the outputs.

    Returns:
        A tuple (result_output, code_output) where each is an integer result of the processing or -1 if an error occurs.
    """"""
    code_output = -1
    result_output = -1

    # Extract and execute code from output
    code_pattern = re.compile(r'```(?:\S*?\n)?(.*?)```', re.DOTALL)
    code_match = code_pattern.search(output)
    if code_match:
        code = code_match.group(1)
        code_output = execute_code(code, timeout_seconds, filename, modulo)
        # print('CODE RESULTS', code_output)

    # Extract and process mathematical result
    result_output = extract_and_process_math(output, modulo)
    # print('BOXED', result_output)

    return result_output, code_output

def prepare_problem_statement(problem: str, tool_instruction: str | None = None, tokenizer: Any = None, apply_chat_template: bool = True, use_simple: bool = False, ) -> str:
    """"""Prepares the complete problem statement by appending the tool instruction to the problem text.

    Args:
        problem (str): 
            The original problem text.
        tool_instruction (str): 
            Additional instructions or information to append to the problem.
        tokenizer ():
            The huggingface tokenizer
        apply_chat_template (bool, optional):
            Whether to apply the HF prompt template (requires )
            If no tokenizer is provided apply_chat_template will not work.
        use_simple (bool, optional):
            Whether to do 0 prompt engineering.
        
        

    Returns:
        A complete problem statement ready for processing.
    """"""
    if not use_simple and tool_instruction is not None:
        prompt_str = tool_instruction+f""\nQUESTION:\n{problem}\n\nYou must write out the logical solution in a step by step fashion before you write any python code to solve the problem.\n\nSOLUTION:\n""
    else:
        prompt_str = problem+""\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.""
    
    if apply_chat_template:
        return tokenizer.apply_chat_template(
            [{""role"": ""user"", ""content"": prompt_str}], 
            tokenize=False
        )
    else:
        return prompt_str
    

def aggregate_results(code_results: Iterable, boxed_results: Iterable, boxed_copies_over_code_fail: bool = True, use_code_and_boxed: bool = False) -> int:
    """"""Aggregates the outputs, resolves errors, and determines the most common valid output.

    Args:
        code_results: List of code outputs.
        boxed_results: List of mathematical result outputs.
        boxed_copies_over_code_fail: Whether the non-error boxed results will copy over the failed code results
        use_code_and_boxed: Whether to aggregate results from both code and boxed results initially

    Returns:
        The most common valid output among the provided answers or -1 if none are valid.
    """"""
    # So we can pop
    code_results, boxed_results = list(code_results), list(boxed_results)
    if all(x<0 for x in code_results):
        boxed_copies_over_code_fail=True
    
    # Get the results array
    if boxed_copies_over_code_fail and not use_code_and_boxed:
        results = []
        for i in range(len(code_results)-1, -1, -1):
            if code_results[i]>0:
                results.append(code_results[i])
            else:
                code_results.pop(i)
                results.append(boxed_results.pop(i))
        results = results[::-1]
    elif not boxed_copies_over_code_fail and not use_code_and_boxed:
        results = code_results
    else:
        results = code_results+boxed_results
    results = np.array(results)
    
    # Handle negatives as invalid results and handle negatives in boxed_results if needed
    results = np.where(results<0, -1, results)
    boxed_results = np.where(np.array(boxed_results)<0, -1, np.array(boxed_results))
    
    # Get most common
    most_common_results_w_counts = [x for x in Counter(results).most_common() if x[0]!=-1]
    if len(most_common_results_w_counts)==0:
        return 1
    elif len(most_common_results_w_counts)==1:
        return int(abs(most_common_results_w_counts[0][0]))
    if most_common_results_w_counts[0][1]==most_common_results_w_counts[1][1] and not use_code_and_boxed:
        most_common_results_w_counts = [x for x in Counter(np.concatenate((results, results, results, results, results, results, results, boxed_results))).most_common() if x[0]!=-1]
    return int(abs(most_common_results_w_counts[0][0]))


def run_pipeline(
        model_pipeline: Callable, 
        query_prompt: str, 
        max_new_tokens: int = 2048,
        temperature: float = 0.85, 
        num_repetitions: int = 2,
) -> list:
    """"""Executes the text-generation pipeline multiple times and collects outputs.

    Args:
        model_pipeline: The initialized text generation pipeline.
        query_prompt: Input text for the pipeline.
        max_new_tokens: Maximum number of new tokens to generate.
        temperature: Controls randomness in output generation.
        num_repetitions: Number of times to run the pipeline for each input.

    Returns:
        A list of outputs from the pipeline.
    """"""

    # Initialize the empty results list for this particular query prompt
    results = []

    # For N repetitions we will repeatedly attempt the problem.
    for _ in tqdm(range(num_repetitions)):
        try:
            raw_output = model_pipeline(
                query_prompt,
                max_new_tokens=max_new_tokens,
                do_sample=True,
                temperature=temperature,
                return_full_text=False
            )
            results.append(raw_output[0]['generated_text'])
            torch.cuda.empty_cache()
            gc.collect()
        except Exception as e:
            print(f""Exception occured in `model_pipeline`: {e}"")
            results.append(None)
    return results


class VLLMPipeline:
    def __init__(
        self, 
        model: object | None = None,
        tokenizer: object | None = None,
        stop_words: list[str] | None = None,
        model_sampling_params: dict[str, Any] | None = None,
        **kwargs,
    ) -> None:
        self.model = model
        self.tokenizer = tokenizer
        
        # Set stop words and fallback
        self.stop_words = stop_words
        if stop_words is None:
            self.stop_words = stop_words or [tokenizer.eos_token if tokenizer is not None and tokenizer.eos_token is not None else '</s>']        
        self.model_sampling_params = model_sampling_params or {}
        self.model_sampling_params[""stop""] = self.stop_words
        
    def __call__(
        self,
        query_prompt: str | list[str],
        max_new_tokens: int,
        temperature: float,
        do_sample: bool = True,
        return_full_text: bool = False,
        stop_word_overrides: list[str] | None = None,
        n_repeats: int = 1,
        sampling_kwargs: dict[str, Any] | None = None,
        batch_style: str = ""multiply"",
        do_cleanup: bool = False,
    ):
        # batch style is ""multiply"" or ""sampling_param_n""
        # Coerce into batch format
        if isinstance(query_prompt, str):
            query_prompt = [query_prompt]
        
        # Validate sampling is allowed and if not adjust temperature
        temperature = 0.0000001 if not do_sample else temperature
        
        # Get sampling parameters and update with call specific params
        sampling_params_kwargs = {**self.model_sampling_params}
        sampling_params_kwargs.update(sampling_kwargs or {})
        sampling_params_kwargs.update({""temperature"": temperature, ""max_tokens"": max_new_tokens})
        
        # Parse input batch
        if batch_style==""multiply"" and len(query_prompt)==1:
            query_prompt = query_prompt*n_repeats
        elif batch_style==""sampling_param_n"":
            sampmling_params_kwargs.update({""n"":n_repeats})
            
        # Finalize sampling params
        _sampling_params = SamplingParams(**sampling_params_kwargs)
        
        # Do inference
        model_output = model.generate(query_prompt, _sampling_params)
        
        # Parse output
        if batch_style==""multiply"":
            model_output = [output.outputs[0].text for output in model_output]
        elif batch_style==""sampling_param_n"":
            model_output = [output.text for output in model_output[0].outputs]
        
        # Cleanup
        if do_cleanup:
            torch.cuda.empty_cache()
            gc.collect()
        
        return model_output
        
    
def initialize_vllm_pipeline(
    model, 
    tokenizer, 
    stop_words: list[str] | None = None,
    model_sampling_params: dict[str, Any] | None = None,
    **kwargs,
) -> VLLMPipeline:
    """"""Artificial pipeline construct so we can mimic the transformers workflow.

    Args:
        model: The pre-trained model to be used for text generation.
        tokenizer: The tokenizer for text preprocessing.

    Returns:
        VLLMPipeline: A configured pipeline for text generation.
    """"""
    return VLLMPipeline(
        model=model,
        tokenizer=tokenizer,
        stop_words=stop_words,
        model_sampling_params=model_sampling_params,
        **kwargs
    )


def run_vllm_pipeline(
        model_pipeline: VLLMPipeline, 
        query_prompt: str, 
        max_new_tokens: int | None = None,
        temperature: float = 0.85, 
        num_repetitions: int = 2,
        sampling_kwargs: dict[str, Any] | None = None
) -> list:
    """"""Executes the text-generation pipeline multiple times and collects outputs.

    Args:
        model_pipeline: The initialized text generation pipeline.
        query_prompt: Input text for the pipeline.
        max_new_tokens: Maximum number of new tokens to generate.
        temperature: Controls randomness in output generation.
        num_repetitions: Number of times to run the pipeline for each input.

    Returns:
        A list of outputs from the pipeline.
    """"""
    try:
        model_results = model_pipeline(
            query_prompt, 
            max_new_tokens=max_new_tokens, 
            temperature=temperature, 
            n_repeats=num_repetitions,
            sampling_kwargs=sampling_kwargs
        )
    except Exception as e:
        print(f""Exception occured in `model_pipeline`: {e}"")
        model_results = ["""",]*num_repetitions
    
    return model_results
aggregate_test_cases = [{'case': 'Basic functionality, no ties', 'code_results': [1, 2, 2, 3], 'boxed_results': [1, 1, 2, 3], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Handling ties, no initial boxed inclusion, no easy break', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 4, 4], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Handling ties, no initial boxed inclusion, has easy break', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 4, 2], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Handling ties, initial boxed inclusion', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 4, 4], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': True, 'expected': 1}, {'case': 'Negative values handling', 'code_results': [1, -1, 2, -1], 'boxed_results': [1, 2, 3, 4], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'All inputs invalid', 'code_results': [-1, -1, -1, -1], 'boxed_results': [-1, -1, -1, -1], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Boxed copies over code results when code fails', 'code_results': [-1, 2, -1, 3], 'boxed_results': [6, 5, 6, 7], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 6}, {'case': 'Equal negative and positive with boxed copying', 'code_results': [1, -1, 4, -1], 'boxed_results': [2, 4, -3, -4], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 4}, {'case': 'All initial values negative', 'code_results': [-1, -1, -1, -1], 'boxed_results': [-2, -2, -2, -2], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Zero values handling', 'code_results': [0, 0, 0, 1], 'boxed_results': [0, 1, 2, 3], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 0}, {'case': 'Large array with a single valid result', 'code_results': [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2], 'boxed_results': [-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Single element array', 'code_results': [1], 'boxed_results': [-1], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Multiple ties and boxed inclusion', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 2, 2], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Boxed tries to overwhelm code', 'code_results': [1, 1, 2, 2, 4, 5, 3], 'boxed_results': [3, 3, 3, 3, 3, 3, 2], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}]
for test_case in aggregate_test_cases:
    display_hr(True, True)
    print(f""\n... CASE DESCRIPTION ...\n\t --> {repr(test_case['case'])}"")
    print(f""\n... EXPECTED OUTPUT ...\n\t --> {repr(test_case['expected'])}"")
    print(f""\n... SETTINGS ...\n\tBOXED COPIES OVER CODE FAIL --> {test_case['boxed_copies_over_code_fail']}\n\tUSE CODE AND BOXED          --> {test_case['use_code_and_boxed']}"")
    print(f""\n... INPUTS ...\n\tCODE RESULTS  --> {test_case['code_results']}\n\tBOXED RESULTS --> {test_case['boxed_results']}"")
    display_hr(True, False)
    print(f""... FUNCTION OUTPUT ...\n\t --> {repr(aggregate_results(**{k:v for k,v in test_case.items() if k not in ['case', 'expected']}))}"")
    display_hr(False, False)
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.2 <b>LOAD</b> THE MODEL, DEFINE CONSTANTS, AND CREATE THE PIPELINE</h3>
<hr>

1. Set the seed for determinism
2. Create a quantization config for double quantized 4 bit quantization with `bitsandbytes`
3. Load the model/tokenizer with the specified quantization config
4. Create a huggingfae pipeline for inferece
5. Prepare the torch backend accordingly

<br>
# I guess we aren't doing this...
USE_VLLM = True
USE_QUANTIZATION = False
MAX_NEW_TOKENS = 1024
TEMPERATURE = 0.87654321
N_REPETITIONS = 7
OTHER_SAMPLING_KWARGS = {
    ""top_k"": 30
}

# Set seed
set_seed()

if USE_VLLM:
    model, tokenizer = load_vllm_model_and_tokenizer(DEEPSEEK_PATH, max_model_len=MAX_NEW_TOKENS)
    text_gen_pipeline = initialize_vllm_pipeline(model, tokenizer, model_sampling_params=OTHER_SAMPLING_KWARGS)
else:
    model, tokenizer = load_model_and_tokenizer(
        model_path=DEEPSEEK_PATH, 
        quantization_config=create_quantization_config() if USE_QUANTIZATION else None
    )
    text_gen_pipeline = initialize_pipeline(model, tokenizer)
    setup_torch_backend()
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.3 <b>DEFINE</b> <s>COMPLEX</s> PROMPT</h3>
<hr><br>

**NOTE: I'm not using this in the vLLM versions of the notebook**

The simple prompt is:

```python
... = problem + ""\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.""
```
# Defaults

# As per https://github.com/deepseek-ai/DeepSeek-Math/tree/main/evaluation with my own engineered extra text
# TOOL_INSTRUCTIONS = """"""Please integrate natural language reasoning with programs to solve mathematical problems, and put your final answer within \\boxed{}:

# Any code you write must be placed within triple backticks like so:
# ```python
# # CODE TO SOLVE THE PROBLEM GOES HERE AND MUST BE EXECUTABLE AS A .py FILE
# ```

# Here is an example using a simple problem to show the basic structure you should follow:

# ---

# QUESTION: 
# Solve $4 + x = 4$ for $x$.

# You must write out the logical solution in a step by step fashion before you write any python code to solve the problem.

# SOLUTION:
# {step by step thoughts go here}

# FINAL ANSWER:
# {Final answer - a positive integer - goes here with the final answer in \\boxed{}}

# ---

# You are an expert in mathematics and problem solving and will do a great job solving these olympiad level problems. 
# Remember, the final answer will be a positive integer.

# Remember to integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}

# ---
# """"""
# # print(f""TOOL_INSTRUCTIONS BY ITSELF:\n{TOOL_INSTRUCTIONS}\n\n"")
TOOL_INSTRUCTIONS = None

print(f""\n\n\nFULL CHAT TEMPLATE:\n\n"")
print(prepare_problem_statement(""What is $1+1=$"", TOOL_INSTRUCTIONS, tokenizer))
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.4 <b>DEMONSTRATE</b> THE INFERENCE FLOW</h3>
<hr><br>

**TO DO**
* Clean this up
def get_aimo_examples(df, num_of_examples: int = 1, source=""AOPS"", idx: int = None):
    if idx is None:
        return df[df.source==source].sample(num_of_examples)
    else:
        return df[df.source==source].reset_index().iloc[idx:idx+num_of_examples]

# Define the demo information
#   - Pick an id for our dataset (using AIMO external from AOPS)
#   - Get the problem string
#   - Get the answer value
DEMO_IDX = 17
DEMO_ROW = get_aimo_examples(ext_aimo_df, idx=DEMO_IDX)
DEMO_PROBLEM_STR = DEMO_ROW[""problem""].values[0]
DEMO_ANSWER = DEMO_ROW[""answer""].values[0]


# For display
review_problem(ext_aimo_df, DEMO_ROW[""problem_id""].values[0])

# Inference Flow
#  1. Combine the tool instructs with the problem string to get the full input prompt
#  2. Pass the full prompt, the pipeline itself, and chosen hyperparameters into the `run_pipeline` function.
demo_full_prompt = prepare_problem_statement(DEMO_PROBLEM_STR, TOOL_INSTRUCTIONS, tokenizer)

if USE_VLLM:
    demo_results = run_vllm_pipeline(
        model_pipeline=text_gen_pipeline, 
        query_prompt=demo_full_prompt, 
        num_repetitions=N_REPETITIONS, 
        temperature=TEMPERATURE, 
        max_new_tokens=MAX_NEW_TOKENS
    )
else:
    demo_results = run_pipeline(
        model_pipeline=text_gen_pipeline, 
        query_prompt=demo_full_prompt, 
        num_repetitions=N_REPETITIONS, 
        temperature=TEMPERATURE, 
        max_new_tokens=MAX_NEW_TOKENS
    )

print(""\n\n\n... PIPELINE RAW RESULTS ...\n"")
for i, result in enumerate(demo_results):
    display_hr(True, False)
    display(HTML(f'<span style=""font-weight: bold;"">RESULT #{i+1}'))
    display_hr(False, False)
    display(Markdown(result))
    display_hr(False, True)
    
# Inference Flow Continued
#  3. Process the raw outputs: This detects any code blocks... executes them.. and then captures the code and NL boxed outputs as separate pythonic values (float/int)
#  4. Pass the full prompt, the pipeline itself, and chosen hyperparameters into the `run_pipeline` function.
#  5. Aggregate the results by overwriting failed code results with valid boxed results... in cases where both are valid we take the code results (this can be changed with parameter).
processed_demo_results = [process_output(demo_result) for demo_result in demo_results if demo_result]
demo_boxed_results, demo_code_results = zip(*processed_demo_results) if processed_demo_results else ([], [])
demo_final_answer = aggregate_results(demo_code_results, demo_boxed_results, boxed_copies_over_code_fail=True)

# Cleanup
torch.cuda.empty_cache(); gc.collect(); gc.collect()

print(f""\n... RAW CODE RESULTS        : {demo_code_results}"")
print(f""... RAW BOXED RESULTS       : {demo_boxed_results}"")
print(f""... AGGREGATED FINAL RESULT : {demo_final_answer}\n\n"")
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.5 <b>INFER</b> ON THE TEST DATA</h3>
<hr><br>

<b>We instantiate the AIMO SUBMISSION API and update our solution code to accomodate</b><br><br>

---

```python
# Set up the evaluation API
import aimo
aimo_env = aimo.make_env()
AIMO_ITER_TEST = aimo_env.iter_test()
```

<i>Note that this public version of the API does not randomize the order in which problems are served. The API used when your submission is scored will randomize the order.</i>

Example on how to use:

```python
# Iterate through the test set and use the model make predictions
for test_ex_df, submission_ex_df in AIMO_ITER_TEST:
    submission_ex_df['answer'] = model.predict(test_ex_df['problem'])
    env.predict(submission_ex_df)
```

---
class DebugSubmissionAPI:
    """"""API to manage and process problem and sample submission data for debugging purposes.
    
    Attributes:
        - source_problem_df (pd.DataFrame): The updated, internal, problem DataFrame
            - columns are 'id' and 'problem'
        - source_sample_submission_df (pd.DataFrame): The created, internal, submission DataFrame
        - submission_csv_path (str): The path to save the final .csv object to.
    """"""

    source_problem_df: pd.DataFrame
    source_sample_submission_df: pd.DataFrame
    submission_csv_path: str
    
    def __init__(self, source_problem_df: pd.DataFrame, submission_csv_path: str = ""debug_submission.csv"") -> None:
        """"""Initializes the DebugSubmissionAPI.
        
        Sets up the problem DataFrame and initializes the sample submission DataFrame.

        Args:
            problem_df (pd.DataFrame): The initial problem DataFrame.
        """"""
        # Rename the problem_id column to id
        self.source_problem_df = source_problem_df.rename(columns={""problem_id"": ""id""})
        # Create a sample submission DataFrame with id and default answer '0'
        self.source_sample_submission_df = pd.DataFrame({'id': self.source_problem_df['id'], 'answer': 0})
        self.submission_csv_path = submission_csv_path
    
    @classmethod
    def make_env(cls, problem_df: pd.DataFrame) -> 'DebugSubmissionAPI':
        """"""Sets up the environment with the problem DataFrame.

        Args:
            problem_df (pd.DataFrame): The problem DataFrame.

        Returns:
            DebugSubmissionAPI: The instance of this class.
        """"""
        if ""problem_id"" not in problem_df.columns or ""problem"" not in problem_df:
            raise ValueError(""You must initialize the DebugSubmissionAPI with a source problem dataframe containing columns for 'problem_id' and 'problem'."")
        return cls(source_problem_df=problem_df)

    def iter_test(self) -> Generator[tuple[pd.DataFrame, pd.DataFrame], None, None]:
        """"""Generates test and sample submission DataFrames for each row in the problem DataFrame.

        Yields:
            Generator[tuple[pd.DataFrame, pd.DataFrame], None, None]: 
                Tuples of test and sample submission DataFrames.
        """"""
        if self.source_problem_df is None or self.source_sample_submission_df is None:
            raise ValueError(""Source dataframes are not initialized."")
        
        for i, row in self.source_problem_df.iterrows():
            # Create a single-row DataFrame for the current test problem
            test = pd.DataFrame([row])
            # Get the corresponding row from the sample submission DataFrame
            sample_submission = self.source_sample_submission_df.iloc[[i]].copy()
            yield test, sample_submission
            
    def predict(self, sample_submission: pd.DataFrame):
        # Update the internal sample submission DataFrame with the modified row
        self.source_sample_submission_df.update(sample_submission)

    def __len__(self) -> int:
        """"""Returns the number of problems in the problem DataFrame.

        Returns:
            int: The number of problems.
        """"""
        return len(self.source_problem_df) if self.source_problem_df is not None else 0

    def __repr__(self) -> str:
        """"""Returns the string representation of the DebugSubmissionAPI instance.

        Returns:
            str: The string representation.
        """"""
        return f""<DebugSubmissionAPI with {len(self)} problems>""
    
    def __enter__(self) -> 'DebugSubmissionAPI':
        """"""Enter the runtime context related to this object.""""""
        return self

    def __exit__(self, exc_type, exc_value, traceback) -> None:
        """"""Exit the runtime context related to this object.""""""
        # Save the final submission when the context is exited
        print(f""\n... Testing Complete - Saving Submission Dataframe to\n\t--> {self.submission_csv_path}"")
        self.source_sample_submission_df.to_csv(self.submission_csv_path, index=False)
# Handle debug[public]/serverside[private] run
IS_DEBUG = len(comp_test_df)==3

# Forcing so we can make sure this works as expected... no save will be generated
FORCE_NON_DEBUG = True

# How many to show during debug... if not forcing (if forcing it will show all)
N_TO_SHOW_DURING_DEBUG = 3

if (IS_DEBUG and FORCE_NON_DEBUG==False):
    # Create the debug submission API iterable object
    aimo_env = DebugSubmissionAPI.make_env(
        problem_df = get_aimo_examples(
            ext_aimo_df, 
            num_of_examples=N_TO_SHOW_DURING_DEBUG
        )[[""problem_id"", ""problem""]].reset_index(drop=True)
    )
else:
    # Create the submission API iterable object
    aimo_env = aimo.make_env()

# Create the generator
AIMO_ITER_TEST = aimo_env.iter_test()

# Iterate over and make predictions
final_answers = []
for test_ex_df, submission_ex_df in AIMO_ITER_TEST:
    # This is for just in case....
    backup_submission_ex_df = submission_ex_df.copy()

    try:
        if (IS_DEBUG and FORCE_NON_DEBUG==False):
            _ = review_problem(df=ext_aimo_df, problem_id=str(test_ex_df[""id""].values[0]))

        full_prompt = prepare_problem_statement(
            problem=str(test_ex_df[""problem""].values[0]), 
            tool_instruction=TOOL_INSTRUCTIONS, 
            tokenizer=tokenizer, 
            use_simple=True
        )

        if USE_VLLM:
            results = run_vllm_pipeline(
                model_pipeline=text_gen_pipeline, 
                query_prompt=full_prompt, 
                num_repetitions=N_REPETITIONS, 
                temperature=TEMPERATURE, 
                max_new_tokens=MAX_NEW_TOKENS
            )
        else:
            results = run_pipeline(
                model_pipeline=text_gen_pipeline, 
                query_prompt=full_prompt, 
                num_repetitions=N_REPETITIONS, 
                temperature=TEMPERATURE, 
                max_new_tokens=MAX_NEW_TOKENS
            )   

        if IS_DEBUG:
            print(""\n\n\n... PIPELINE RAW RESULTS [SIMPLE] ...\n"")
            for i, result in enumerate(results):
                display_hr(True, False)
                display(HTML(f'<span style=""font-weight: bold;"">RESULT #{i+1}'))
                display_hr(False, False)
                display(Markdown(result))
                display_hr(False, True)

        processed_outputs = [process_output(output) for output in results if output]
        boxed_results, code_results = zip(*processed_outputs) if processed_outputs else ([], [])
        final_answer = aggregate_results(code_results, boxed_results)
        final_answers.append(final_answer)

        if IS_DEBUG:
            print(f""\n... RAW CODE RESULTS        : {code_results}"")
            print(f""... RAW BOXED RESULTS       : {boxed_results}"")
            print(f""... AGGREGATED FINAL RESULT : {final_answer}\n\n"")

        submission_ex_df[""answer""] = final_answer
        aimo_env.predict(submission_ex_df)
    except:
        backup_submission_ex_df[""answer""] = 1
        aimo_env.predict(backup_submission_ex_df)

# Show final dataframe (one that was saved)
if IS_DEBUG and not FORCE_NON_DEBUG:
    display(aimo_env.source_sample_submission_df)
# class InferenceHandler:
#     def __init__(
#         self,
#         model_path: str, 
#         tool_instructions: str | None = None,
#         max_new_tokens: int = 1536, 
#         temperature: float = 0.654321, 
#         n_repetitions: int = 3, 
#         use_simple_instruction: bool = True, 
#         boxed_copies_over_code_fail: bool = False,
#         try_again_condition: str = ""all"",
#         simple_to_complex_repetition_ratio: int = 5,
#         minimum_complex_repetitions: int = 1
#     ):
#         """"""Initializes the InferenceHandler with the necessary configurations.

#         Args:
#             model_path (str): Path to the model directory.
#             tool_instructions (str): Additional instructions or information to append to the problem.
#             max_new_tokens (int): Maximum number of new tokens to generate.
#             temperature (float): Controls randomness in output generation.
#             n_repetitions (int): Number of times to run the pipeline for each input.
#             use_simple_instruction (bool): Whether to use simple problem statements.
#             boxed_copies_over_code_fail (bool): Whether non-error boxed results will copy over failed code results.
#             try_again_condition (str, optional): What condition to try again on. One of ['all' | 'boxed' | 'code' | None]
#             simple_to_complex_repetition_ratio (int): How many simple instructions run before 1 complex instruction runs. Ignored if tool_instructions is None (simple only used)
#             minimum_complex_repetitions (int): Minimum number of complex repetitions. Ignored if tool_instructions is None (simple only used)
#         """"""
#         set_seed()
#         quant_config = create_quantization_config()
#         self.model, self.tokenizer = load_model_and_tokenizer(model_path, quant_config)
#         self.pipeline = initialize_pipeline(self.model, self.tokenizer)
#         setup_torch_backend()
        
#         self.simple_to_complex_repetition_ratio = 5
#         if tool_instructions is None and use_simple_instruction==False:
#             raise ValueError
#         self.tool_instructions = tool_instructions
#         self.max_new_tokens = max_new_tokens
#         self.temperature = temperature
#         self.n_repetitions = n_repetitions
#         self.use_simple_instruction = use_simple_instruction
#         self.boxed_copies_over_code_fail = boxed_copies_over_code_fail
#         self.try_again_condition = try_again_condition
        
#         if tool_instructions is None:
#             self.simple_n_repetitions = self.n_repetitions
#             self.complex_n_repetitions = 0
#         else:
#             self.complex_n_repetitions = max(self.n_repetitions//simple_to_complex_repetition_ratio, minimum_complex_repetitions)
#             self.simple_n_repetitions = self.n_repetitions-self.complex_n_repetitions
            
#     def run_inference(self, problem: str, use_simple_instruction: bool = None, temperature: float = None) -> tuple:
#         """"""Runs inference on a given problem and returns the processed outputs.

#         Args:
#             problem (str): The problem text to infer on.
#             use_simple_instruction (bool): Whether to use simple problem statements.
#             temperature (float, optional): An optional override value for temperature

#         Returns:
#             tuple: A tuple containing the raw results, the boxed_results and the code_results.
#         """"""
#         # Handle number of repetitions
#         if self.use_simple_instruction:
#             n_repetitions = self.simple_n_repetitions if use_simple_instruction else self.complex_n_repetitions
#         else:
#             n_repetitions = self.n_repetitions
            
#         full_prompt = prepare_problem_statement(problem, self.tool_instructions, use_simple_instruction)
#         results = run_pipeline(self.pipeline, full_prompt, self.max_new_tokens, temperature or self.temperature, n_repetitions)
#         processed_outputs = [process_output(output) for output in results if output]
#         boxed_results, code_results = zip(*processed_outputs) if processed_outputs else ([], [])
#         return results, boxed_results, code_results
    
#     def get_try_again_flag(self, boxed_results: tuple, code_results: tuple) -> bool:
#         """"""Whether or not we meet the conditions to try again
        
#         Args:
#             boxed_results (tuple): The results from the textual output
#             code_results (tuple): The results from the code output
            
#         Returns:
#             bool indicating whether or not we try again
#         """"""
#         # try again condition capture
#         try_again_flag = False
#         if self.try_again_condition==""all"":
#             try_again_flag = all(x == -1 for x in (list(boxed_results) + list(code_results))) or len((list(boxed_results) + list(code_results))) == 0
#         elif ""code"" in self.try_again_condition:
#             try_again_flag = all(x == -1 for x in list(code_results)) or len(list(code_results)) == 0
#         elif ""boxed"" in self.try_again_condition:
#             try_again_flag = all(x == -1 for x in list(boxed_results)) or len(list(boxed_results)) == 0
#         return try_again_flag
    
    
#     def infer(self, problem: str) -> int:
#         """"""Performs inference on a given problem and returns the final answer.

#         Args:
#             problem (str): The problem text to infer on.

#         Returns:
#             int: The final answer obtained from inference.
#         """"""
#         # Get the results
#         results, boxed_results, code_results = self.run_inference(problem, use_simple_instruction=True)
        
#         # If try again condition is met... here we go
#         if self.get_try_again_flag(boxed_results, code_results):
#             # Get the retried results with slightly higher temp
#             results, boxed_results, code_results = self.run_inference(problem, use_simple_instruction=True, temperature=self.temperature*1.1)
        
#         # Get complex fragment
#         if self.use_simple_instruction and self.complex_n_repetitions>0:
#             _results, _boxed_results, _code_results = self.run_inference(problem, use_simple_instruction=False, temperature=self.temperature*0.9)
#             boxed_results, code_results = list(boxed_results)+list(_boxed_results), list(code_results)+list(_code_results)
        
#         # Get final answer
#         final_answer = aggregate_results(boxed_results, code_results, self.boxed_copies_over_code_fail)
#         return final_answer

#     def infer_on_dataframe(
#         self, df: pd.DataFrame, 
#         id_col: str = ""id"", 
#         problem_col: str = ""problem"", 
#         answer_col: str = ""answer"", 
#         output_csv: str = ""submission.csv""
#     ) -> pd.DataFrame:
#         """"""
#         Performs inference on a DataFrame containing problems and saves the results to a CSV file.

#         Args:
#             df (pd.DataFrame): The DataFrame containing the problems.
#             id_col (str): The name of the column containing problem IDs. Default is ""id"".
#             problem_col (str): The name of the column containing problem texts. Default is ""problem"".
#             answer_col (str): The name of the column to store the inferred answers. Default is ""answer"".
#             output_csv (str): The path to save the output CSV file. Default is ""submission.csv"".

#         Returns:
#             pd.DataFrame: The DataFrame with the inferred answers.
#         """"""
#         final_answers = []
#         for _, row in tqdm(df.iterrows()):
#             try:
#                 final_answer = self.infer(row[problem_col])
#             except:
#                 final_answer = -1
#             final_answers.append(final_answer)
        
#         df[answer_col] = final_answers
#         df[[id_col, answer_col]].to_csv(output_csv, index=False)
#         return df
    
# demo_df = get_aimo_examples(ext_aimo_df, num_of_examples=3)[[""problem_id"", ""problem""]].reset_index(drop=True)
# display(demo_df)

# inference_handler = InferenceHandler(
#     model_path=DEEPSEEK_PATH,
#     tool_instructions=TOOL_INSTRUCTIONS,
#     max_new_tokens=MAX_NEW_TOKENS,
#     temperature=TEMPERATURE,
#     n_repetitions=N_REPETITIONS,
#     use_simple_instruction=True,
#     boxed_copies_over_code_fail=False,
#     try_again_condition = ""code"",
#     simple_to_complex_repetition_ratio = 4,
# )

# review_problem(ext_aimo_df, demo_df[""problem_id""][0])
# inference_handler.infer(demo_df[""problem""][0])
# Just in case...
try:
    if os.path.isfile(""code_to_execute.py""):
        os.remove(""code_to_execute.py"")
except:
    !rm -rf ./code_to_execute.py
<a id=""cv""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""cv"">7&nbsp;&nbsp;CROSS VALIDATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

All of our cross validation will happen within a block that only runs if we are debugging.
# N_SUBSET = 50
# if IS_DEBUG:
#     cv_df = get_aimo_examples(ext_aimo_df, num_of_examples=N_SUBSET)
#     cv_results = []
    
#     for _, row in tqdm(cv_df.iterrows(), total=N_SUBSET):
#         row_result = {""problem_id"": row.problem_id, ""problem"": row.problem, ""gt_result"": row.answer, ""gt_result_solution"": row.solution}
#         full_prompt = prepare_problem_statement(row[""problem""], TOOL_INSTRUCTIONS, tokenizer, use_simple=True)

#         if USE_VLLM:
#             results = run_vllm_pipeline(
#                 model_pipeline=text_gen_pipeline, 
#                 query_prompt=full_prompt, 
#                 num_repetitions=N_REPETITIONS, 
#                 temperature=TEMPERATURE, 
#                 max_new_tokens=MAX_NEW_TOKENS
#             )
#         else:
#             results = run_pipeline(
#                 model_pipeline=text_gen_pipeline, 
#                 query_prompt=full_prompt, 
#                 num_repetitions=N_REPETITIONS, 
#                 temperature=TEMPERATURE, 
#                 max_new_tokens=MAX_NEW_TOKENS
#             )   

#         processed_outputs = [process_output(output) for output in results if output]
#         boxed_results, code_results = zip(*processed_outputs) if processed_outputs else ([], [])
#         final_answer = aggregate_results(code_results, boxed_results)
        
#         row_result[""pred_result""] = final_answer
#         row_result[""pred_result_solutions""] = results
#         row_result[""pred_code_results""] = code_results
#         row_result[""pred_boxed_results""] = code_results
        
#         cv_results.append(row_result)

# try:
#     cv_results_df = pd.DataFrame(cv_results)
    
# except:
#     print(""try again"")

# # 12/50
# cv_results_df[cv_results_df.gt_result==cv_results_df.pred_result]

# # TBD
# cv_results_df.to_csv(""cv_results.csv"", index=False)
# cv_results_df


","# Run this to enable CSS types
from IPython.core.display import HTML

# Font stuff
font_to_use = ""Lato"" # ""Verdana""
fallback = ""Verdana""
font_import_str = f""""""
@import url('https://fonts.googleapis.com/css2?family={font_to_use.replace(' ', '+')}:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap');
""""""

def css_styling(verbose=True):
    styles = open(""/kaggle/input/my-css-styles/kaggle_styles.css"", ""r"").read().replace('Verdana', font_to_use) #+f"", {fallback}"")
    html_str = ""<style>""+font_import_str+styles+""</style>""
    if verbose: print(html_str)
    return HTML(html_str)

css_styling(False)
print(""\n... PIP INSTALLS STARTING ...\n"")
!pip uninstall -y torch
!pip install -U --no-index --find-links=/kaggle/input/vllm-whl -U vllm
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl
!pip install -U --upgrade /kaggle/input/vllm-t4-fix/grpcio-1.62.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl
!pip install -U --upgrade /kaggle/input/vllm-t4-fix/ray-2.11.0-cp310-cp310-manylinux2014_x86_64.whl
print(""\n... PIP INSTALLS COMPLETE ...\n"")

print(""\n... IMPORTS STARTING ...\n"")
print(""\n\tVERSION INFORMATION"")
# Competition Specific Imports from HF and torch
from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    BitsAndBytesConfig, 
    AutoConfig,
    pipeline,
    set_seed as transformers_set_seed
)
from vllm import LLM, SamplingParams
import torch; torch.backends.cuda.enable_mem_efficient_sdp(False)
import aimo

## Patch issue from https://github.com/vllm-project/vllm/issues/1116
# if torch.cuda.device_count()>1:
#     import ray
#     ray.shutdown()
#     ray.init(num_gpus=torch.cuda.device_count())

import pandas as pd; pd.options.mode.chained_assignment = None; pd.set_option('display.max_columns', None);
import numpy as np; print(f""\t\t– NUMPY VERSION: {np.__version__}"");
import sympy as sp; print(f""\t\t– SYMPY VERSION: {sp.__version__}"");
from sympy.parsing.latex import parse_latex
import sklearn; print(f""\t\t– SKLEARN VERSION: {sklearn.__version__}"");

# Built-In Imports (mostly don't worry about these)
from typing import Iterable, Any, Callable, Generator
from kaggle_datasets import KaggleDatasets
from dataclasses import dataclass
from collections import Counter
from datetime import datetime
from zipfile import ZipFile
from glob import glob
import subprocess
import warnings
import requests
import textwrap
import hashlib
import imageio
import IPython
import urllib
import zipfile
import pickle
import random
import shutil
import string
import json
import copy
import math
import time
import gzip
import ast
import sys
import io
import gc
import re
import os

# Visualization Imports (overkill)
from IPython.core.display import HTML, Markdown
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm; tqdm.pandas();
import plotly.express as px
import seaborn as sns
from PIL import Image, ImageEnhance; Image.MAX_IMAGE_PIXELS = 5_000_000_000;
import matplotlib; print(f""\t\t– MATPLOTLIB VERSION: {matplotlib.__version__}"");
import plotly
import PIL

def seed_it_all(seed=7):
    """""" Attempt to be Reproducible """"""
    os.environ['PYTHONHASHSEED'] = str(seed)
    random.seed(seed)
    np.random.seed(seed)
    # tf.random.set_seed(seed)
    
seed_it_all()

print(""\n\n... IMPORTS COMPLETE ...\n"")
def load_vllm_model_and_tokenizer(
    model_path: str, 
    model_dtype: str = ""half"", 
    enforce_eager: bool = True, 
    gpu_memory_utilization: float = 0.999, 
    swap_space: int = 4, 
    max_model_len: int = 1024, 
    kv_cache_dtype: str = ""fp8_e5m2"", 
    tensor_parallel_size: int | str = ""system"",
):
    """"""Initializes and returns the specified language model and its associated tokenizer.
    
    This is primarily used in the context of this competition for the DeepSeek Math RL model.
    
    While the function and descriptions are mine, the underlying code comes from this notebook: 
        https://www.kaggle.com/code/bsmit1659/aimo-vllm-accelerated-tot-sc-deepseekmath/notebook

    Args:
        model_path (str): 
            The path to the pre-trained model's checkpoint file on the local filesystem.
            This file contains the learned weights and parameters of the language model.
        model_dtype (str, optional): 
            The data type to use for the model's computations.
            Defaults to ""half"" which represents 16-bit half-precision floating-point format.
            This can help reduce memory usage and improve performance on GPUs.
        enforce_eager (bool, optional): 
            Whether to enforce eager execution mode for the model.
            Eager execution allows for immediate evaluation of operations without building a computational graph.
        gpu_memory_utilization (float, optional): 
            The fraction of available GPU memory to allocate for the model.
            This controls the trade-off between memory usage and performance. Higher values allocate more memory
            to the model, potentially improving performance but limiting the available memory for other tasks.
        swap_space (int, optional): 
            The size of the swap space (in GB) to use for model loading.
            Swap space is used when the model's memory requirements exceed the available GPU memory.
            It allows the model to be loaded by swapping data between GPU memory and CPU memory.
        max_model_len (int, optional): 
            The maximum sequence length (in tokens) that the model can process.
            This determines the maximum context size the model can handle in a single forward pass.
            Longer sequences will be truncated to fit within this limit.
        kv_cache_dtype (str, optional): 
            The data type to use for the key-value cache in the model.
            The key-value cache stores intermediate activations to speed up computation.
            This can help reduce memory usage while maintaining acceptable precision.
            Defaults to ""fp8_e5m2"" which represents:
                - an 8-bit floating-point format 
                - with exponent bias (5)
                - and mantissa size (2)            
        tensor_parallel_size (int | str, optional): 
            The number of GPU devices to use for tensor parallelism.
            Tensor parallelism splits the model across multiple GPUs to distribute the computation.
            Defaults to 1, which means no tensor parallelism is used. Use 2 for 2xT4.
            If set to ""system"" than torch.cuda.device_count() will be used.

    Returns:
        tuple: 
            A tuple containing the initialized DeepSeek language model (LLM) and its associated tokenizer.
                - llm (LLM): The initialized DeepSeek language model.
                - tokenizer (Tokenizer): The tokenizer associated with the language model.
    """"""
    _llm = LLM(
        model=model_path,
        dtype=model_dtype,
        enforce_eager=enforce_eager,
        gpu_memory_utilization=gpu_memory_utilization,
        swap_space=swap_space,
        max_model_len=max_model_len,
        kv_cache_dtype=kv_cache_dtype,
        tensor_parallel_size=tensor_parallel_size if isinstance(tensor_parallel_size, int) else torch.cuda.device_count()
    )
    _tokenizer = _llm.get_tokenizer()
    return _llm, _tokenizer


# https://www.kaggle.com/code/simjeg/platypus2-70b-with-wikipedia-rag
def clean_memory() -> None:
    """"""Function to clean RAM & vRAM""""""
    gc.collect()
    ctypes.CDLL(""libc.so.6"").malloc_trim(0)
    torch.cuda.empty_cache()
def flatten_l_o_l(nested_list):
    """""" Flatten a list of lists into a single list.

    Args:
        nested_list (Iterable): 
            – A list of lists (or iterables) to be flattened.

    Returns:
        A flattened list containing all items from the input list of lists.
    """"""
    return [item for sublist in nested_list for item in sublist]


def print_ln(symbol=""-"", line_len=110, newline_before=False, newline_after=False):
    """""" Print a horizontal line of a specified length and symbol.

    Args:
        symbol (str, optional): 
            – The symbol to use for the horizontal line
        line_len (int, optional): 
            – The length of the horizontal line in characters
        newline_before (bool, optional): 
            – Whether to print a newline character before the line
        newline_after (bool, optional): 
            – Whether to print a newline character after the line
            
    Returns:
        None; A divider with pre/post new-lines (optional) is printed
    """"""
    if newline_before: print();
    print(symbol * line_len)
    if newline_after: print();
        
        
def display_hr(newline_before=False, newline_after=False):
    """""" Renders a HTML <hr>

    Args:
        newline_before (bool, optional): 
            – Whether to print a newline character before the line
        newline_after (bool, optional): 
            – Whether to print a newline character after the line
            
    Returns:
        None; A divider with pre/post new-lines (optional) is printed
    """"""
    if newline_before: print();
    display(HTML(""<hr>""))
    if newline_after: print();


def wrap_text(text, width=88):
    """"""Wrap text to a specified width.

    Args:
        text (str): 
            - The text to wrap.
        width (int): 
            - The maximum width of a line. Default is 88.

    Returns:
        str: The wrapped text.
    """"""
    return textwrap.fill(text, width)


def wrap_text_by_paragraphs(text, width=88):
    """"""Wrap text by paragraphs to a specified width.

    Args:
        text (str): 
            - The text containing multiple paragraphs to wrap.
        width (int): 
            - The maximum width of a line. Default is 88.

    Returns:
        str: The wrapped text with preserved paragraph separation.
    """"""
    paragraphs = text.split('\n')  # Assuming paragraphs are separated by newlines
    wrapped_paragraphs = [textwrap.fill(paragraph, width) for paragraph in paragraphs]
    return '\n\n'.join(wrapped_paragraphs)


def hide_asy_text(text: str) -> tuple[str, dict[str, str]]:
    """"""Replaces text within [asy]...[/asy] blocks with unique placeholders.

    Args:
        text (str): 
            The original text containing blocks to be hidden.

    Returns:
        tuple[str, dict[str, str]]: 
            A tuple containing the modified text with placeholders
            and a dictionary mapping placeholders to the original text blocks.
    """"""
    pattern = r'\[asy\](.*?)\[/asy\]'
    placeholders = {}

    def _replacer(match: re.Match) -> tuple[str, dict[str, str]]:
        """"""This function is used to replace the text within [asy]...[/asy] blocks.

        It replaces the text with a unique placeholder and stores the original text.

        Args:
            match (re.Match): The matched object.

        Returns:
            str: The original text corresponding to the placeholder.
        """"""
        original = match.group(1)
        placeholder = f""UNIQUE_STRING_{len(placeholders)}""
        placeholders[placeholder] = original
        return f""[asy]{placeholder}[/asy]""

    modified_text = re.sub(pattern, _replacer, text)
    return modified_text, placeholders


def unhide_asy_text(text: str, placeholders: dict[str, str]) -> str:
    """"""Restores the original text blocks within [asy]...[/asy] from the placeholders.

    Args:
        text (str):
            The text with placeholders to be restored.
        placeholders (dict[str, str]):
            A dictionary mapping placeholders back to the original text.

    Returns:
        str: The text with all placeholders restored to their original content.
    """"""
    pattern = r'\[asy\](UNIQUE_STRING_\d+)\[/asy\]'

    def _replacer(match: re.Match) -> str:
        """"""This function is used to replace the placeholders with the original text.

        Args:
            match (re.Match): The matched object.

        Returns:
            str: The original text corresponding to the placeholder.
        """"""
        placeholder = match.group(1)
        return f""[asy]{placeholders.get(placeholder, 'ERROR: Text not found')}[/asy]""

    restored_text = re.sub(pattern, _replacer, text)
    return restored_text


def load_aops_dataset_as_df(
        csv_path: str,
        coerce_answers: bool = True,
        drop_diagram_questions: bool = True,
        remove_asy_blocks_from_solution: bool = True
) -> pd.DataFrame:
    """"""This will return a dataframe for the Art of Problem Solving Dataset based on various options.

    Options include:
        - Fixing the answer column by coercing values
            - removing lfill 0s
            - replacing periods added to the right side incorrectly
            - removing commas
        - Removing problems with Asymptote diagrams in problem description (as no diagrams are found in test set)
        - Removing parts Asymptote diagrams from solution description (as no diagrams are found in test set)

    Args:
        csv_path (str): The path to the csv file
        coerce_answers (bool): Whether to fix the answer column
        drop_diagram_questions (bool): Whether to drop questions with Asymptote diagrams
        remove_asy_blocks_from_solution (bool): Whether to remove Asymptote blocks from solution

    Returns:
        pd.DataFrame: The loaded dataset
    """"""
    _df = pd.read_csv(csv_path)
    
    if coerce_answers:
        _df[""answer""] = _df[""answer""].apply(lambda x: x[:-1] if str(x)[-1]==""."" else x)
        _df[""answer""] = _df[""answer""].apply(lambda x: x.replace("","", """"))
        _df[""answer""] = _df[""answer""].apply(lambda x: int(x) if str(x).startswith(""0"") and ""."" not in str(x) else x)
    
    if drop_diagram_questions:
        _df = _df[_df.solution.str.lower().str.contains(""[asy]"")]
    
    if remove_asy_blocks_from_solution:
        _df[""solution""] = _df[""solution""].apply(lambda text: re.sub(r'\[asy\](.*?)\[/asy\]', '', text))
        
    return _df.reset_index(drop=True)
# ROOT PATHS
WORKING_DIR = ""/kaggle/working""
INPUT_DIR = ""/kaggle/input""
COMPETITION_DIR = os.path.join(INPUT_DIR, ""ai-mathematical-olympiad-prize"")
EXT_DATASET_DIR = os.path.join(INPUT_DIR, ""/kaggle/input/external-datasets-after-preprocessing-for-aimo"")

# COMPETITION FILE PATHS
SS_CSV_PATH = os.path.join(COMPETITION_DIR, ""sample_submission.csv"")
COMP_TRAIN_CSV_PATH = os.path.join(COMPETITION_DIR, ""train.csv"")
COMP_TEST_CSV_PATH = os.path.join(COMPETITION_DIR, ""test.csv"")

# DEFINE COMPETITION DATAFRAMES
print(""\n\n... SAMPLE SUBMISSION DATAFRAME ...\n"")
ss_df = pd.read_csv(SS_CSV_PATH)
display(ss_df)

print(""\n\n... COMPETITION TRAIN DATAFRAME ...\n"")
comp_train_df = pd.read_csv(COMP_TRAIN_CSV_PATH)
display(comp_train_df)

if os.path.isfile(COMP_TEST_CSV_PATH):
    print(""\n\n... COMPETITION TEST DATAFRAME ...\n"")
    comp_test_df = pd.read_csv(COMP_TEST_CSV_PATH)
    display(comp_test_df)
else:
    comp_test_df = comp_train_df.iloc[:1]
    
# DEFINE EXTERNAL DATASET PATHS

EXT_AIMO_1 = os.path.join(INPUT_DIR, ""aimo-external-dataset"", ""external_df.csv"")  # GSM8K and MATH
EXT_AIMO_2 = os.path.join(INPUT_DIR, ""amio-parsed-art-of-problem-solving-website"", ""parsed_ArtOfProblemSolving.csv"")  # Art of Problem Solving Website

# DEFINE EXTERNAL DATASET DATAFRAMES
print(""\n\n... EXTERNAL DATASET 1 DATAFRAME - GSM8K and MATH ...\n"")
ext_aimo_1_df = pd.read_csv(EXT_AIMO_1)
display(ext_aimo_1_df)

print(""\n\n... EXTERNAL DATASET 2 DATAFRAME - Art of Problem Solving Website ...\n"")
ext_aimo_2_df = load_aops_dataset_as_df(EXT_AIMO_2)
display(ext_aimo_2_df)

# DEFINE MODEL PATHS
DEEPSEEK_PATH = os.path.join(INPUT_DIR, ""deepseek-math"")
MISTRAL_PATH = os.path.join(INPUT_DIR, ""open-math-mistral"")
def get_problem(df: pd.DataFrame, problem_id: str = None, problem_str: str = None, problem_link: str = None) -> pd.DataFrame:
    """"""This function will retrieve a dataframe subset of the aops_df that matches the desired problem.
    
    If no problem specifier is provided then a random problem will be retrieved.
    
    Args:
        df (pd.DataFrame): The dataframe containing problem information.
        problem_id (str, optional): The specific problem ID to filter by.
        problem_str (str, optional): A substring of the problem text to filter by.
        problem_link (str, optional): The specific problem link to filter by.
    
    Raises:
        ValueError: If no criteria are provided and the dataframe is empty.
    
    Returns:
        pd.DataFrame: A subset of `aops_df` based on the provided criteria or a single random problem if no criteria are provided.
    """"""
    # Create a copy to avoid modifying the original dataframe
    _df = copy.deepcopy(df)
    
    # Check if any criteria is provided
    if problem_id is not None:
        _df = _df[_df['problem_id'] == problem_id]
    if problem_str is not None:
        _df = _df[_df['problem'].str.contains(problem_str, case=False, na=False)]
    if problem_link is not None:
        _df = _df[_df['link'] == problem_link]

    # If no criteria is specified, select a random problem
    if problem_id is None and problem_str is None and problem_link is None:
        if _df.empty:
            raise ValueError(""The input dataframe is empty. Cannot select a random problem."")
        _df = get_problem(_df, problem_id=_df.problem_id.sample(1).values[0])
    return _df.reset_index(drop=True)


def problem_to_html(
    problem_str: str,
    problem_link: str | None = None, 
    problem_id: str | None = None,
    bg_color: str = ""#f5f5f5""
) -> HTML:
    """"""Generates an HTML representation of a problem description, optionally including a link.

    Args:
        problem_str (str): The text describing the problem.
        problem_link (Optional[str]): A URL linking to further details about the problem, defaults to None.
        bg_color (str): The background color for the HTML div element, defaults to ""#f5f5f5"".

    Returns:
        HTML: An HTML object suitable for display in IPython environments.
    """"""
    # Remove ASY text as we don't want to adjust it's formatting
    problem_str, placeholders = hide_asy_text(problem_str)
    
    #  -- Prettify  --
    _html_str = f'<div style=""background-color: {bg_color}; border-radius: 10px; padding: 20px; margin: 20px;""> <b>PROBLEM:</b><br><br>{problem_str.replace(""..."", ""...<br><br>"").replace(""."", "".<br><br>"")}</div>'
    if problem_link is not None and not pd.isna(problem_link):
        _html_str = _html_str.replace(""PROBLEM:"", 'PROBLEM  <a href=""'+problem_link+'"">[LINK]</a>:')
    if problem_id is not None:
        _html_str = _html_str.replace(""PROBLEM"", f""PROBLEM ID: {problem_id}"")
    
    # Put the ASY text back in
    _html_str = unhide_asy_text(_html_str, placeholders)
    
    return HTML(_html_str)
                
                
# Basic Hex Colour for Success is #e9fce9
def solution_to_html(solution_str: str, solution_num: int | str | None = None, solution_value: int | float | str | None = None, bg_color: list[str] | str = ""pastel""):
    """"""Generates an HTML representation of a solution with dynamic background colors and optional details.

    Args:
        solution_str (str): 
            The text describing the solution.
        solution_num (int | str, optional): 
            A number or identifier for the solution, defaults to None.
        solution_value (int | float | str, optional): 
            A value associated with the solution.
        bg_color (list[str] | str, optional): 
            The background color(s) for the HTML div element. 
            This can be a hex color, a list of hex colors, or a seaborn palette name, defaults to ""pastel"".

    Returns:
        HTML: An HTML object suitable for display in IPython environments.

    """"""
    def get_colors(color_input: str | list[str]) -> list[str]:
        """"""Resolves the background color input into a list of hexadecimal color codes.

        Args:
            color_input (str | list[str]): 
                A hex color, a list of hex colors, or a seaborn palette name.

        Returns:
            list[str]: A list of hexadecimal color codes.
        """"""
        if isinstance(color_input, str) and color_input.startswith(""#""):
            return [color_input]
        elif isinstance(color_input, list) and all(isinstance(item, str) for item in color_input):
            return color_input
        else:
            return sns.color_palette(color_input).as_hex()
    
    # Remove ASY text as we don't want to adjust it's formatting
    solution_str, placeholders = hide_asy_text(solution_str)
    
    # -- Prettify --
    # Resolve background colors using the internal function
    colors = get_colors(bg_color)
    # Generate the main HTML string for the solution
    color_index = solution_num % len(colors) if solution_num is not None else 0
    _html_str = f'<div style=""background-color: {colors[color_index]}; border-radius: 10px; padding: 20px; margin: 20px;""> <b>SOLUTION:</b><br><br>{solution_str.replace(""..."", ""...<br><br>"").replace(""."", "".<br><br>"")}</div>'
    # Add solution number if specified
    if solution_num is not None:
        _html_str = _html_str.replace(""SOLUTION:"", f""SOLUTION #{solution_num}:"")
    if solution_value is not None:
        _html_str=_html_str.replace(""</div>"", f'<br><br><b>SOLUTION VALUE: <font color=""red"">{solution_value}</font></b><br><br></div>')
    
    # Put the ASY text back in
    _html_str = unhide_asy_text(_html_str, placeholders)
    _html_str = _html_str.replace(r""\["", r""<br><br>\["").replace(r""\]"", r""\]<br><br>"")
    return HTML(_html_str)


def review_problem(df: pd.DataFrame, problem_id: str | None = None, show_all_solutions: bool = False):
    """"""This function will retrieve a dataframe subset of the aops_df that matches the desired problem.
    
    It will then iterate over the provided solutions and display the example in an asthetically pleasing way.    
    If no problem specifier is provided then a random problem will be retrieved.
    
    Args:
        _df (pd.DataFrame): The dataframe containing problem information.
        problem_id (str, optional): The specific problem ID to filter by.
        show_all_solutions (bool, optional): Whether to show all or just the first solution
        
    Raises:
        ValueError: If no criteria are provided and the dataframe is empty.
    
    Returns:
        pd.DataFrame: A subset of `aops_df` based on the provided criteria or a single random problem if no criteria are provided.
    """"""
    _df = get_problem(df, problem_id=problem_id)
    _df_link = _df.link[0] if ""link"" in _df.columns else None
    display(problem_to_html(_df.problem[0], _df_link, _df.problem_id[0]))

    for i, (_, row) in enumerate(_df.iterrows()):
        display(solution_to_html(row.solution, i+1, row.answer))
        if not show_all_solutions:
            break
    
    return _df

### Review a random problem
# df = review_problem(ext_aimo_2_df)

N_EX = 2
print(f""\n... SHOWING {N_EX} RANDOM QUESTIONS (OUT OF A POSSIBLE {len(ext_aimo_2_df)}) FROM THE AMIO PARSED ART OF PROBLEM SOLVING DATASET ...\n"")
for i in range(N_EX):
    df = review_problem(ext_aimo_2_df, show_all_solutions=False)
    display(df)
    display_hr(newline_after=True, newline_before=True)
    print(""\n\n"")
def extract_and_evaluate_solution(text: str, re_pattern: str | None = r""\\boxed{((?:[^{}]+|{[^{}]*})*)}"", verbose: bool=False) -> int | float | None:
    """"""Extracts a LaTeX expression from a given text and evaluates it numerically.
    
    If a regex is provided but no match is found... the parsing will assume full text requires evaluation.
    
    Args:
        text (str): 
            The text containing the LaTeX expression.
        re_pattern (str, optional): 
            A regular expression pattern to extract the LaTeX expression enclosed in specific LaTeX commands like \\boxed{}. 
            If None, evaluates the entire text as a LaTeX expression.

    Returns:
        int | float | None: The evaluated numerical result as an integer or float, or None if no expression is found or an error occurs in parsing.
    """"""
    # Use the provided regular expression pattern, or default to the entire text
    latex_expression = text
    if re_pattern:
        match = re.search(re_pattern, text)
        if match:
            latex_expression = match.group(1)
    else:
        latex_expression = text
    
    try:
        # Convert LaTeX to a sympy expression
        sympy_expression = sp.sympify(parse_latex(latex_expression))

        # Evaluate the expression to a numerical result and determine type
        evaluated_expression = sympy_expression.evalf()
        if evaluated_expression.is_Integer:
            return int(evaluated_expression)
        else:
            return float(evaluated_expression)
    except Exception as e:
        if verbose:
            print(f""Error parsing or evaluating the expression: {e}"")
        return -1.0
    
    
# extract_and_evaluate_solution(""\\frac{211}{243}"")    

######### THE FOLLOWING CODE IS HOW I PROCESSED THE ORIGINAL DATASET INTO MY CURRENT DATASET I LOAD FROM DIRECTLY #########
# ext_aimo_1_df[""answer""] = -1.0
# ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""GSM8K"", ""answer""] = ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""GSM8K""][""solution""].apply(lambda x: float(x.rsplit(""####"", 1)[-1].replace("","", """").strip()))
#
# extracted_answers = []
# _start_idx = _0
# for i, x in enumerate(tqdm(ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""MATH""][""solution""].values[_start_idx:])):
#     _idx = _start_idx+i
#     extracted_answers.append(extract_and_evaluate_solution(x.replace(""pi"", ""3.14159"")))
#
# ext_aimo_1_df.loc[ext_aimo_1_df[""source""]==""MATH"", ""answer""] = extracted_answers
# ext_aimo_1_df[""answer""] = ext_aimo_1_df[""answer""].apply(lambda x: int(x) if ""."" in str(x) and float(x)==float(int(x)) else float(x))
# ext_aimo_1_df = ext_aimo_1_df[ext_aimo_1_df[""answer""]!=-1].reset_index(drop=True)
# ext_aimo_1_df.insert(0, ""problem_id"", pd.Series(ext_aimo_1_df.index.astype(str)).apply(lambda x: f""{x:>05}"")+""_""+ext_aimo_1_df.source+""_""+ext_aimo_1_df.stage)
#
# ext_aimo_1_df.to_csv(""ext_aimo_1_preprocessed.csv"", index=False)
# ext_aimo_2_df.to_csv(""ext_aimo_2_preprocessed.csv"", index=False)

# ext_aimo_df = pd.concat([ext_aimo_2_df, ext_aimo_1_df])[[""problem_id"", ""problem"", ""solution"", ""answer"", ""link"", ""source"", ""level"", ""type"", ""stage"", ""letter""]].reset_index(drop=True)
# ext_aimo_df[""source""] = ext_aimo_df[""source""].fillna(""AOPS"")
# ext_aimo_df[""stage""] = ext_aimo_df[""stage""].fillna(""train"")
# ext_aimo_df.to_csv(""ext_aimo_preprocessed.csv"", index=False)
#################################################################################################################

ext_aimo_df = pd.read_csv(os.path.join(EXT_DATASET_DIR, ""ext_aimo_preprocessed.csv""))
ext_aimo_1_df = pd.read_csv(os.path.join(EXT_DATASET_DIR, ""ext_aimo_1_preprocessed.csv""))
ext_aimo_2_df = pd.read_csv(os.path.join(EXT_DATASET_DIR, ""ext_aimo_2_preprocessed.csv""))
                            
display(ext_aimo_df)
N_EX = 2
print(f""\n... SHOWING {N_EX} RANDOM QUESTIONS (OUT OF A POSSIBLE {len(ext_aimo_1_df)}) FROM THE AMIO EXTERNAL DATASET (GSM8K AND MATH) ...\n"")
for i in range(N_EX):
    df = review_problem(ext_aimo_1_df)
    display(df)
    display_hr(newline_after=True, newline_before=True)
    print(""\n\n"")
def remove_multiple_choice_options_in_problem(problem_str):
    return problem_str.rsplit(""$\\textbf{(A"", 1)[0].rsplit(""$\\text{(A"", 1)[0].strip()

def remove_asy_block(text):
    if text.count(""[asy]"")>0:
        text = text.split(""[asy]"", 1)[0]+text.split(""[/asy]"", 1)[-1]
        remove_asy_block(text)
    return text.strip()

def fix_and_filter_external_data(df: pd.DataFrame, drop_non_pos_int_rows: bool = True):
    """"""""""""
    _df = df.copy()
    
    # Drop rows with infinite values in answer
    _df = _df[~_df[""answer""].replace([np.inf, -np.inf], np.nan).isna()]
    
    # Force answer to be appropriate dtype (int or float)
    _df[""answer""] =_df[""answer""].apply(lambda x: int(x) if float(int(x))==float(x) else float(x))
    
    # Remove multiple choices in problem string
    _df.loc[~pd.isna(_df[""letter""]), ""problem""] = _df.loc[~pd.isna(_df[""letter""]), ""problem""].apply(remove_multiple_choice_options_in_problem)
    
    # Replace hashtag solutions with boxed
    _df.loc[_df.solution.str.contains(""#### ""), ""solution""] = _df.loc[_df.solution.str.contains(""#### ""), ""solution""].apply(
        lambda x: x.strip().rsplit(""####"", 1)[0]+""$\\boxed{""+x.strip().rsplit(""####"", 1)[-1].strip()+""}$""
    )
    
    # Drop rows where the answer is less than 0 or non-int
    if drop_non_pos_int_rows:
        _df = _df[_df.answer.apply(lambda x: isinstance(x, int) and 0 <= x)]
        
    # Drop rows where there is 
    
    # Modulo the answer and store the original in a separate column
    _df[""original_answer""] = _df[""answer""].copy()
    _df[""answer""] = _df[""answer""].apply(lambda x: x%1000)
    
    return _df.reset_index(drop=True)
   
    
def filter_by_consensus(df: pd.DataFrame, id_col: str = 'problem_id', answer_col: str = 'answer') -> pd.DataFrame:
    """"""
    Filters a DataFrame to retain only rows where the answer has the majority consensus 
    for each unique problem identifier.

    This function groups the DataFrame by a problem identifier and determines the most frequent 
    answer for each group. Only rows where the answer matches the most frequent (mode) answer 
    for their corresponding group are retained.

    Args:
        df (pd.DataFrame): The DataFrame to filter.
        id_col (str, optional): The column name in the DataFrame that contains the problem identifiers. 
                                Defaults to 'problem_id'.
        answer_col (str, optional): The column name in the DataFrame that contains the answers. 
                                    Defaults to 'answer'.

    Returns:
        pd.DataFrame: A DataFrame containing only the rows with the majority consensus answer 
                      for each unique problem identifier.

    Example:
        >>> data = {'problem_id': ['1', '1', '1', '2', '2', '3'],
        ...         'answer': [10, 10, 4, 150, 150, 3]}
        >>> df = pd.DataFrame(data)
        >>> filtered_df = filter_by_consensus(df)
        >>> print(filtered_df)
    """"""
    _df = df.copy()
    
    # Calculate the mode of the answers for each problem_id
    mode_df = _df.groupby(id_col)[answer_col].agg(lambda x: pd.Series.mode(x)[0]).reset_index()
    mode_df.rename(columns={answer_col: 'mode_answer'}, inplace=True)

    # Merge this back with the original DataFrame to filter
    merged_df = _df.merge(mode_df, on=id_col)

    # Keep only rows where the answer matches the mode answer
    result_df = merged_df[merged_df[answer_col] == merged_df['mode_answer']]

    # Remove the temporary mode_answer column
    result_df = result_df.drop(columns=['mode_answer'])

    return result_df.reset_index(drop=True)

# Easy fixes
ext_aimo_df = fix_and_filter_external_data(ext_aimo_df)
# display(ext_aimo_df[ext_aimo_df.problem_id.isin(['00d3433e73bb281384e53ad5a87cdc86',
#        '212e80b4f9896d94a6c128f3d1726d38',
#        '33e99f18e99cdf0a415426283897830e',
#        '8655d580c2215b683eea607ff11e39ea',
#        '9194d5124ad28fd1ffc8b22d8930320e',
#        '9277096b27e0f04586690475ea517d1d',
#        '9958192892d058ab3cbc1ba71c827ac6',
#        'd59714d615a1262fb813437141ed2c62',
#        'ec2dbb5106882670665f78b963a6040c'])]
# )
# Consensus Fixes
ext_aimo_df = filter_by_consensus(ext_aimo_df)

display(ext_aimo_df)
def set_seed(seed: int = 42) -> None:
    """"""Sets the seed for generating random numbers to ensure reproducibility.

    Args:
        seed (int): The seed number. Default is 42.
    """"""
    transformers_set_seed(seed)


def create_quantization_config(load_in_4bit: bool = True, 
                               quant_type: str = ""nf4"", 
                               compute_dtype = torch.bfloat16, 
                               use_double_quant: bool = True) -> BitsAndBytesConfig:
    """"""Creates a configuration for model quantization to optimize model size and inference speed.

    Args:
        load_in_4bit (bool): Whether to load models in 4-bit precision.
        quant_type (str): Type of quantization, 'nf4' for noise-free 4-bit.
        compute_dtype: Data type for computation, typically torch.bfloat16 for mixed precision.
        use_double_quant (bool): Whether to use double quantization.

    Returns:
        BitsAndBytesConfig: A configuration object for BitsAndBytes.
    """"""
    return BitsAndBytesConfig(
        load_in_4bit=load_in_4bit,
        bnb_4bit_quant_type=quant_type,
        bnb_4bit_compute_dtype=compute_dtype,
        bnb_4bit_use_double_quant=use_double_quant,
    )

def load_model_and_tokenizer(
    model_path: str = ""/kaggle/input/deepseek-math"", 
    quantization_config: BitsAndBytesConfig | None = None
) -> tuple:
    """"""Loads the tokenizer and model with specific quantization configurations.

    Args:
        model_path (str): Path to the model directory.
        quantization_config (BitsAndBytesConfig): Quantization configuration for the model.

    Returns:
        tuple: A tuple containing the loaded model and tokenizer.
    """"""
    config = AutoConfig.from_pretrained(model_path)
    config.gradient_checkpointing = True
    
    tokenizer = AutoTokenizer.from_pretrained(model_path)
    
    model = AutoModelForCausalLM.from_pretrained(
        model_path,
        device_map=""auto"",
        torch_dtype=""auto"",
        trust_remote_code=True,
        quantization_config=quantization_config,
        config=config
    )
    
    return model, tokenizer


def initialize_pipeline(model, tokenizer) -> pipeline:
    """"""Initializes a pipeline for text generation using the provided model and tokenizer.

    Args:
        model: The pre-trained model to be used for text generation.
        tokenizer: The tokenizer for text preprocessing.

    Returns:
        pipeline: A configured pipeline for text generation.
    """"""
    return pipeline(
        ""text-generation"",
        model=model,
        tokenizer=tokenizer,
        torch_dtype='auto',
        device_map=""auto""
    )


def setup_torch_backend(enable_mem_efficient_sdp: bool = False) -> None:
    """"""Configures PyTorch backend settings.

    Args:
        enable_mem_efficient_sdp (bool): Flag to enable memory efficient scatter-gather.
                                        Default is False.
    """"""
    torch.backends.cuda.enable_mem_efficient_sdp(enable_mem_efficient_sdp)
    
def naive_parse(answer: str) -> str:
    """"""Extracts the last contiguous sequence of digits from a given string.
    
    This function is based on the function that is floating around in the top scoring code notebooks.
    I'm not sure who the original author was... but once I know I will attribute accordingly.

    Args:
        answer: A string from which to extract the digit sequence.

    Returns:
        A string containing the last sequence of digits found in the input string.
        Returns an empty string if no digits are found.

    Examples:
        naive_parse(""example123test456"") returns ""456""
        naive_parse(""no digits here!"") returns """"
    """"""
    last_digits = ''
    found_digit = False

    for char in reversed(answer):
        if char.isdigit():
            last_digits += char
            found_digit = True
        elif found_digit:
            # Break the loop once the first non-digit is found after finding digits
            break
    
    # Reverse to correct the order of digits
    return last_digits[::-1]  


def postprocess_final_answer(expression: str, modulo: int = 1000) -> int:
    """"""Postprocesses the final answer by returning the rounded/modulod value.

    Args:
        expression: The mathematical expression to evaluate as a string. (raw final answer)
        modulo: The modulo value to use in the calculation.

    Returns:
        An integer result of the evaluated expression modulo the specified value.
    """"""
    try:
        result = round(float(eval(expression)))
        return result % modulo
    except Exception as e:
        print(f""Exception occured in `postprocess_final_answer`: {e}"")
        return -1

def execute_code(code: str, timeout_seconds: int = 7, filename: str = 'code_to_execute.py', modulo: int = 1000, sympy_star_import: bool = True) -> int:
    """"""Executes the given Python code snippet and processes the output.

    Args:
        code: The Python code to execute.
        timeout_seconds: Maximum allowed time for code execution in seconds.
        filename: The filename to which the code will be written before execution.
        modulo: The modulo value to use for processing the output.
        sympy_star_import: Whether to always import everything from sympy

    Returns:
        An integer result derived from the execution output or -1 if an error occurs.
    """"""
    try:
        with open(filename, 'w') as fout:
            fout.write(code if not sympy_star_import else 'from sympy import *\n'+code)

        batcmd = f'timeout {timeout_seconds} {sys.executable} {filename}'
        shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
        return postprocess_final_answer(shell_output, modulo)
    except Exception as e:
        print(f""Exception occured in `execute_code`: {e}"")
        return -1

def extract_and_process_math(result: str, modulo: int = 1000) -> int:
    """"""Extracts and evaluates the mathematical expression from the given string.

    Args:
        result: The string containing the expression in a LaTeX-like \\boxed{} format.
        modulo: The modulo value to use for the final result.

    Returns:
        An integer result of the evaluated expression or -1 if an error occurs.
    """"""
    try:
        result_output = re.findall(r'\\boxed\{(.*)\}', result)
        if result_output:
            expression = result_output[-1]
        else:
            expression = naive_parse(result)

        if expression:
            return postprocess_final_answer(expression, modulo)
        return -1
    except Exception as e:
        print(f""Exception occured in `extract_and_process_math`: {e}"")
        return -1

    
def process_output(output: str, timeout_seconds: int = 7, filename: str = 'code_to_execute.py', modulo: int = 1000) -> tuple:
    """"""Processes the provided output string to execute contained code and extract mathematical results.

    Args:
        output: The string that may contain Python code in triple backticks and/or a mathematical expression in \\boxed{}.
        timeout_seconds: Maximum allowed time for code execution in seconds.
        filename: The filename for saving and executing the Python code.
        modulo: The modulo value to use for processing the outputs.

    Returns:
        A tuple (result_output, code_output) where each is an integer result of the processing or -1 if an error occurs.
    """"""
    code_output = -1
    result_output = -1

    # Extract and execute code from output
    code_pattern = re.compile(r'```(?:\S*?\n)?(.*?)```', re.DOTALL)
    code_match = code_pattern.search(output)
    if code_match:
        code = code_match.group(1)
        code_output = execute_code(code, timeout_seconds, filename, modulo)
        # print('CODE RESULTS', code_output)

    # Extract and process mathematical result
    result_output = extract_and_process_math(output, modulo)
    # print('BOXED', result_output)

    return result_output, code_output

def prepare_problem_statement(problem: str, tool_instruction: str | None = None, tokenizer: Any = None, apply_chat_template: bool = True, use_simple: bool = False, ) -> str:
    """"""Prepares the complete problem statement by appending the tool instruction to the problem text.

    Args:
        problem (str): 
            The original problem text.
        tool_instruction (str): 
            Additional instructions or information to append to the problem.
        tokenizer ():
            The huggingface tokenizer
        apply_chat_template (bool, optional):
            Whether to apply the HF prompt template (requires )
            If no tokenizer is provided apply_chat_template will not work.
        use_simple (bool, optional):
            Whether to do 0 prompt engineering.
        
        

    Returns:
        A complete problem statement ready for processing.
    """"""
    if not use_simple and tool_instruction is not None:
        prompt_str = tool_instruction+f""\nQUESTION:\n{problem}\n\nYou must write out the logical solution in a step by step fashion before you write any python code to solve the problem.\n\nSOLUTION:\n""
    else:
        prompt_str = problem+""\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.""
    
    if apply_chat_template:
        return tokenizer.apply_chat_template(
            [{""role"": ""user"", ""content"": prompt_str}], 
            tokenize=False
        )
    else:
        return prompt_str
    

def aggregate_results(code_results: Iterable, boxed_results: Iterable, boxed_copies_over_code_fail: bool = True, use_code_and_boxed: bool = False) -> int:
    """"""Aggregates the outputs, resolves errors, and determines the most common valid output.

    Args:
        code_results: List of code outputs.
        boxed_results: List of mathematical result outputs.
        boxed_copies_over_code_fail: Whether the non-error boxed results will copy over the failed code results
        use_code_and_boxed: Whether to aggregate results from both code and boxed results initially

    Returns:
        The most common valid output among the provided answers or -1 if none are valid.
    """"""
    # So we can pop
    code_results, boxed_results = list(code_results), list(boxed_results)
    if all(x<0 for x in code_results):
        boxed_copies_over_code_fail=True
    
    # Get the results array
    if boxed_copies_over_code_fail and not use_code_and_boxed:
        results = []
        for i in range(len(code_results)-1, -1, -1):
            if code_results[i]>0:
                results.append(code_results[i])
            else:
                code_results.pop(i)
                results.append(boxed_results.pop(i))
        results = results[::-1]
    elif not boxed_copies_over_code_fail and not use_code_and_boxed:
        results = code_results
    else:
        results = code_results+boxed_results
    results = np.array(results)
    
    # Handle negatives as invalid results and handle negatives in boxed_results if needed
    results = np.where(results<0, -1, results)
    boxed_results = np.where(np.array(boxed_results)<0, -1, np.array(boxed_results))
    
    # Get most common
    most_common_results_w_counts = [x for x in Counter(results).most_common() if x[0]!=-1]
    if len(most_common_results_w_counts)==0:
        return 1
    elif len(most_common_results_w_counts)==1:
        return int(abs(most_common_results_w_counts[0][0]))
    if most_common_results_w_counts[0][1]==most_common_results_w_counts[1][1] and not use_code_and_boxed:
        most_common_results_w_counts = [x for x in Counter(np.concatenate((results, results, results, results, results, results, results, boxed_results))).most_common() if x[0]!=-1]
    return int(abs(most_common_results_w_counts[0][0]))


def run_pipeline(
        model_pipeline: Callable, 
        query_prompt: str, 
        max_new_tokens: int = 2048,
        temperature: float = 0.85, 
        num_repetitions: int = 2,
) -> list:
    """"""Executes the text-generation pipeline multiple times and collects outputs.

    Args:
        model_pipeline: The initialized text generation pipeline.
        query_prompt: Input text for the pipeline.
        max_new_tokens: Maximum number of new tokens to generate.
        temperature: Controls randomness in output generation.
        num_repetitions: Number of times to run the pipeline for each input.

    Returns:
        A list of outputs from the pipeline.
    """"""

    # Initialize the empty results list for this particular query prompt
    results = []

    # For N repetitions we will repeatedly attempt the problem.
    for _ in tqdm(range(num_repetitions)):
        try:
            raw_output = model_pipeline(
                query_prompt,
                max_new_tokens=max_new_tokens,
                do_sample=True,
                temperature=temperature,
                return_full_text=False
            )
            results.append(raw_output[0]['generated_text'])
            torch.cuda.empty_cache()
            gc.collect()
        except Exception as e:
            print(f""Exception occured in `model_pipeline`: {e}"")
            results.append(None)
    return results


class VLLMPipeline:
    def __init__(
        self, 
        model: object | None = None,
        tokenizer: object | None = None,
        stop_words: list[str] | None = None,
        model_sampling_params: dict[str, Any] | None = None,
        **kwargs,
    ) -> None:
        self.model = model
        self.tokenizer = tokenizer
        
        # Set stop words and fallback
        self.stop_words = stop_words
        if stop_words is None:
            self.stop_words = stop_words or [tokenizer.eos_token if tokenizer is not None and tokenizer.eos_token is not None else '</s>']        
        self.model_sampling_params = model_sampling_params or {}
        self.model_sampling_params[""stop""] = self.stop_words
        
    def __call__(
        self,
        query_prompt: str | list[str],
        max_new_tokens: int,
        temperature: float,
        do_sample: bool = True,
        return_full_text: bool = False,
        stop_word_overrides: list[str] | None = None,
        n_repeats: int = 1,
        sampling_kwargs: dict[str, Any] | None = None,
        batch_style: str = ""multiply"",
        do_cleanup: bool = False,
    ):
        # batch style is ""multiply"" or ""sampling_param_n""
        # Coerce into batch format
        if isinstance(query_prompt, str):
            query_prompt = [query_prompt]
        
        # Validate sampling is allowed and if not adjust temperature
        temperature = 0.0000001 if not do_sample else temperature
        
        # Get sampling parameters and update with call specific params
        sampling_params_kwargs = {**self.model_sampling_params}
        sampling_params_kwargs.update(sampling_kwargs or {})
        sampling_params_kwargs.update({""temperature"": temperature, ""max_tokens"": max_new_tokens})
        
        # Parse input batch
        if batch_style==""multiply"" and len(query_prompt)==1:
            query_prompt = query_prompt*n_repeats
        elif batch_style==""sampling_param_n"":
            sampmling_params_kwargs.update({""n"":n_repeats})
            
        # Finalize sampling params
        _sampling_params = SamplingParams(**sampling_params_kwargs)
        
        # Do inference
        model_output = model.generate(query_prompt, _sampling_params)
        
        # Parse output
        if batch_style==""multiply"":
            model_output = [output.outputs[0].text for output in model_output]
        elif batch_style==""sampling_param_n"":
            model_output = [output.text for output in model_output[0].outputs]
        
        # Cleanup
        if do_cleanup:
            torch.cuda.empty_cache()
            gc.collect()
        
        return model_output
        
    
def initialize_vllm_pipeline(
    model, 
    tokenizer, 
    stop_words: list[str] | None = None,
    model_sampling_params: dict[str, Any] | None = None,
    **kwargs,
) -> VLLMPipeline:
    """"""Artificial pipeline construct so we can mimic the transformers workflow.

    Args:
        model: The pre-trained model to be used for text generation.
        tokenizer: The tokenizer for text preprocessing.

    Returns:
        VLLMPipeline: A configured pipeline for text generation.
    """"""
    return VLLMPipeline(
        model=model,
        tokenizer=tokenizer,
        stop_words=stop_words,
        model_sampling_params=model_sampling_params,
        **kwargs
    )


def run_vllm_pipeline(
        model_pipeline: VLLMPipeline, 
        query_prompt: str, 
        max_new_tokens: int | None = None,
        temperature: float = 0.85, 
        num_repetitions: int = 2,
        sampling_kwargs: dict[str, Any] | None = None
) -> list:
    """"""Executes the text-generation pipeline multiple times and collects outputs.

    Args:
        model_pipeline: The initialized text generation pipeline.
        query_prompt: Input text for the pipeline.
        max_new_tokens: Maximum number of new tokens to generate.
        temperature: Controls randomness in output generation.
        num_repetitions: Number of times to run the pipeline for each input.

    Returns:
        A list of outputs from the pipeline.
    """"""
    try:
        model_results = model_pipeline(
            query_prompt, 
            max_new_tokens=max_new_tokens, 
            temperature=temperature, 
            n_repeats=num_repetitions,
            sampling_kwargs=sampling_kwargs
        )
    except Exception as e:
        print(f""Exception occured in `model_pipeline`: {e}"")
        model_results = ["""",]*num_repetitions
    
    return model_results
aggregate_test_cases = [{'case': 'Basic functionality, no ties', 'code_results': [1, 2, 2, 3], 'boxed_results': [1, 1, 2, 3], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Handling ties, no initial boxed inclusion, no easy break', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 4, 4], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Handling ties, no initial boxed inclusion, has easy break', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 4, 2], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Handling ties, initial boxed inclusion', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 4, 4], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': True, 'expected': 1}, {'case': 'Negative values handling', 'code_results': [1, -1, 2, -1], 'boxed_results': [1, 2, 3, 4], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'All inputs invalid', 'code_results': [-1, -1, -1, -1], 'boxed_results': [-1, -1, -1, -1], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Boxed copies over code results when code fails', 'code_results': [-1, 2, -1, 3], 'boxed_results': [6, 5, 6, 7], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 6}, {'case': 'Equal negative and positive with boxed copying', 'code_results': [1, -1, 4, -1], 'boxed_results': [2, 4, -3, -4], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 4}, {'case': 'All initial values negative', 'code_results': [-1, -1, -1, -1], 'boxed_results': [-2, -2, -2, -2], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Zero values handling', 'code_results': [0, 0, 0, 1], 'boxed_results': [0, 1, 2, 3], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 0}, {'case': 'Large array with a single valid result', 'code_results': [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2], 'boxed_results': [-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Single element array', 'code_results': [1], 'boxed_results': [-1], 'boxed_copies_over_code_fail': True, 'use_code_and_boxed': False, 'expected': 1}, {'case': 'Multiple ties and boxed inclusion', 'code_results': [1, 1, 2, 2], 'boxed_results': [3, 3, 2, 2], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}, {'case': 'Boxed tries to overwhelm code', 'code_results': [1, 1, 2, 2, 4, 5, 3], 'boxed_results': [3, 3, 3, 3, 3, 3, 2], 'boxed_copies_over_code_fail': False, 'use_code_and_boxed': False, 'expected': 2}]
for test_case in aggregate_test_cases:
    display_hr(True, True)
    print(f""\n... CASE DESCRIPTION ...\n\t --> {repr(test_case['case'])}"")
    print(f""\n... EXPECTED OUTPUT ...\n\t --> {repr(test_case['expected'])}"")
    print(f""\n... SETTINGS ...\n\tBOXED COPIES OVER CODE FAIL --> {test_case['boxed_copies_over_code_fail']}\n\tUSE CODE AND BOXED          --> {test_case['use_code_and_boxed']}"")
    print(f""\n... INPUTS ...\n\tCODE RESULTS  --> {test_case['code_results']}\n\tBOXED RESULTS --> {test_case['boxed_results']}"")
    display_hr(True, False)
    print(f""... FUNCTION OUTPUT ...\n\t --> {repr(aggregate_results(**{k:v for k,v in test_case.items() if k not in ['case', 'expected']}))}"")
    display_hr(False, False)
# I guess we aren't doing this...
USE_VLLM = True
USE_QUANTIZATION = False
MAX_NEW_TOKENS = 1024
TEMPERATURE = 0.87654321
N_REPETITIONS = 7
OTHER_SAMPLING_KWARGS = {
    ""top_k"": 30
}

# Set seed
set_seed()

if USE_VLLM:
    model, tokenizer = load_vllm_model_and_tokenizer(DEEPSEEK_PATH, max_model_len=MAX_NEW_TOKENS)
    text_gen_pipeline = initialize_vllm_pipeline(model, tokenizer, model_sampling_params=OTHER_SAMPLING_KWARGS)
else:
    model, tokenizer = load_model_and_tokenizer(
        model_path=DEEPSEEK_PATH, 
        quantization_config=create_quantization_config() if USE_QUANTIZATION else None
    )
    text_gen_pipeline = initialize_pipeline(model, tokenizer)
    setup_torch_backend()
# Defaults

# As per https://github.com/deepseek-ai/DeepSeek-Math/tree/main/evaluation with my own engineered extra text
# TOOL_INSTRUCTIONS = """"""Please integrate natural language reasoning with programs to solve mathematical problems, and put your final answer within \\boxed{}:

# Any code you write must be placed within triple backticks like so:
# ```python
# # CODE TO SOLVE THE PROBLEM GOES HERE AND MUST BE EXECUTABLE AS A .py FILE
# ```

# Here is an example using a simple problem to show the basic structure you should follow:

# ---

# QUESTION: 
# Solve $4 + x = 4$ for $x$.

# You must write out the logical solution in a step by step fashion before you write any python code to solve the problem.

# SOLUTION:
# {step by step thoughts go here}

# FINAL ANSWER:
# {Final answer - a positive integer - goes here with the final answer in \\boxed{}}

# ---

# You are an expert in mathematics and problem solving and will do a great job solving these olympiad level problems. 
# Remember, the final answer will be a positive integer.

# Remember to integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}

# ---
# """"""
# # print(f""TOOL_INSTRUCTIONS BY ITSELF:\n{TOOL_INSTRUCTIONS}\n\n"")
TOOL_INSTRUCTIONS = None

print(f""\n\n\nFULL CHAT TEMPLATE:\n\n"")
print(prepare_problem_statement(""What is $1+1=$"", TOOL_INSTRUCTIONS, tokenizer))
def get_aimo_examples(df, num_of_examples: int = 1, source=""AOPS"", idx: int = None):
    if idx is None:
        return df[df.source==source].sample(num_of_examples)
    else:
        return df[df.source==source].reset_index().iloc[idx:idx+num_of_examples]

# Define the demo information
#   - Pick an id for our dataset (using AIMO external from AOPS)
#   - Get the problem string
#   - Get the answer value
DEMO_IDX = 17
DEMO_ROW = get_aimo_examples(ext_aimo_df, idx=DEMO_IDX)
DEMO_PROBLEM_STR = DEMO_ROW[""problem""].values[0]
DEMO_ANSWER = DEMO_ROW[""answer""].values[0]


# For display
review_problem(ext_aimo_df, DEMO_ROW[""problem_id""].values[0])

# Inference Flow
#  1. Combine the tool instructs with the problem string to get the full input prompt
#  2. Pass the full prompt, the pipeline itself, and chosen hyperparameters into the `run_pipeline` function.
demo_full_prompt = prepare_problem_statement(DEMO_PROBLEM_STR, TOOL_INSTRUCTIONS, tokenizer)

if USE_VLLM:
    demo_results = run_vllm_pipeline(
        model_pipeline=text_gen_pipeline, 
        query_prompt=demo_full_prompt, 
        num_repetitions=N_REPETITIONS, 
        temperature=TEMPERATURE, 
        max_new_tokens=MAX_NEW_TOKENS
    )
else:
    demo_results = run_pipeline(
        model_pipeline=text_gen_pipeline, 
        query_prompt=demo_full_prompt, 
        num_repetitions=N_REPETITIONS, 
        temperature=TEMPERATURE, 
        max_new_tokens=MAX_NEW_TOKENS
    )

print(""\n\n\n... PIPELINE RAW RESULTS ...\n"")
for i, result in enumerate(demo_results):
    display_hr(True, False)
    display(HTML(f'<span style=""font-weight: bold;"">RESULT #{i+1}'))
    display_hr(False, False)
    display(Markdown(result))
    display_hr(False, True)
    
# Inference Flow Continued
#  3. Process the raw outputs: This detects any code blocks... executes them.. and then captures the code and NL boxed outputs as separate pythonic values (float/int)
#  4. Pass the full prompt, the pipeline itself, and chosen hyperparameters into the `run_pipeline` function.
#  5. Aggregate the results by overwriting failed code results with valid boxed results... in cases where both are valid we take the code results (this can be changed with parameter).
processed_demo_results = [process_output(demo_result) for demo_result in demo_results if demo_result]
demo_boxed_results, demo_code_results = zip(*processed_demo_results) if processed_demo_results else ([], [])
demo_final_answer = aggregate_results(demo_code_results, demo_boxed_results, boxed_copies_over_code_fail=True)

# Cleanup
torch.cuda.empty_cache(); gc.collect(); gc.collect()

print(f""\n... RAW CODE RESULTS        : {demo_code_results}"")
print(f""... RAW BOXED RESULTS       : {demo_boxed_results}"")
print(f""... AGGREGATED FINAL RESULT : {demo_final_answer}\n\n"")
class DebugSubmissionAPI:
    """"""API to manage and process problem and sample submission data for debugging purposes.
    
    Attributes:
        - source_problem_df (pd.DataFrame): The updated, internal, problem DataFrame
            - columns are 'id' and 'problem'
        - source_sample_submission_df (pd.DataFrame): The created, internal, submission DataFrame
        - submission_csv_path (str): The path to save the final .csv object to.
    """"""

    source_problem_df: pd.DataFrame
    source_sample_submission_df: pd.DataFrame
    submission_csv_path: str
    
    def __init__(self, source_problem_df: pd.DataFrame, submission_csv_path: str = ""debug_submission.csv"") -> None:
        """"""Initializes the DebugSubmissionAPI.
        
        Sets up the problem DataFrame and initializes the sample submission DataFrame.

        Args:
            problem_df (pd.DataFrame): The initial problem DataFrame.
        """"""
        # Rename the problem_id column to id
        self.source_problem_df = source_problem_df.rename(columns={""problem_id"": ""id""})
        # Create a sample submission DataFrame with id and default answer '0'
        self.source_sample_submission_df = pd.DataFrame({'id': self.source_problem_df['id'], 'answer': 0})
        self.submission_csv_path = submission_csv_path
    
    @classmethod
    def make_env(cls, problem_df: pd.DataFrame) -> 'DebugSubmissionAPI':
        """"""Sets up the environment with the problem DataFrame.

        Args:
            problem_df (pd.DataFrame): The problem DataFrame.

        Returns:
            DebugSubmissionAPI: The instance of this class.
        """"""
        if ""problem_id"" not in problem_df.columns or ""problem"" not in problem_df:
            raise ValueError(""You must initialize the DebugSubmissionAPI with a source problem dataframe containing columns for 'problem_id' and 'problem'."")
        return cls(source_problem_df=problem_df)

    def iter_test(self) -> Generator[tuple[pd.DataFrame, pd.DataFrame], None, None]:
        """"""Generates test and sample submission DataFrames for each row in the problem DataFrame.

        Yields:
            Generator[tuple[pd.DataFrame, pd.DataFrame], None, None]: 
                Tuples of test and sample submission DataFrames.
        """"""
        if self.source_problem_df is None or self.source_sample_submission_df is None:
            raise ValueError(""Source dataframes are not initialized."")
        
        for i, row in self.source_problem_df.iterrows():
            # Create a single-row DataFrame for the current test problem
            test = pd.DataFrame([row])
            # Get the corresponding row from the sample submission DataFrame
            sample_submission = self.source_sample_submission_df.iloc[[i]].copy()
            yield test, sample_submission
            
    def predict(self, sample_submission: pd.DataFrame):
        # Update the internal sample submission DataFrame with the modified row
        self.source_sample_submission_df.update(sample_submission)

    def __len__(self) -> int:
        """"""Returns the number of problems in the problem DataFrame.

        Returns:
            int: The number of problems.
        """"""
        return len(self.source_problem_df) if self.source_problem_df is not None else 0

    def __repr__(self) -> str:
        """"""Returns the string representation of the DebugSubmissionAPI instance.

        Returns:
            str: The string representation.
        """"""
        return f""<DebugSubmissionAPI with {len(self)} problems>""
    
    def __enter__(self) -> 'DebugSubmissionAPI':
        """"""Enter the runtime context related to this object.""""""
        return self

    def __exit__(self, exc_type, exc_value, traceback) -> None:
        """"""Exit the runtime context related to this object.""""""
        # Save the final submission when the context is exited
        print(f""\n... Testing Complete - Saving Submission Dataframe to\n\t--> {self.submission_csv_path}"")
        self.source_sample_submission_df.to_csv(self.submission_csv_path, index=False)
# Handle debug[public]/serverside[private] run
IS_DEBUG = len(comp_test_df)==3

# Forcing so we can make sure this works as expected... no save will be generated
FORCE_NON_DEBUG = True

# How many to show during debug... if not forcing (if forcing it will show all)
N_TO_SHOW_DURING_DEBUG = 3

if (IS_DEBUG and FORCE_NON_DEBUG==False):
    # Create the debug submission API iterable object
    aimo_env = DebugSubmissionAPI.make_env(
        problem_df = get_aimo_examples(
            ext_aimo_df, 
            num_of_examples=N_TO_SHOW_DURING_DEBUG
        )[[""problem_id"", ""problem""]].reset_index(drop=True)
    )
else:
    # Create the submission API iterable object
    aimo_env = aimo.make_env()

# Create the generator
AIMO_ITER_TEST = aimo_env.iter_test()

# Iterate over and make predictions
final_answers = []
for test_ex_df, submission_ex_df in AIMO_ITER_TEST:
    # This is for just in case....
    backup_submission_ex_df = submission_ex_df.copy()

    try:
        if (IS_DEBUG and FORCE_NON_DEBUG==False):
            _ = review_problem(df=ext_aimo_df, problem_id=str(test_ex_df[""id""].values[0]))

        full_prompt = prepare_problem_statement(
            problem=str(test_ex_df[""problem""].values[0]), 
            tool_instruction=TOOL_INSTRUCTIONS, 
            tokenizer=tokenizer, 
            use_simple=True
        )

        if USE_VLLM:
            results = run_vllm_pipeline(
                model_pipeline=text_gen_pipeline, 
                query_prompt=full_prompt, 
                num_repetitions=N_REPETITIONS, 
                temperature=TEMPERATURE, 
                max_new_tokens=MAX_NEW_TOKENS
            )
        else:
            results = run_pipeline(
                model_pipeline=text_gen_pipeline, 
                query_prompt=full_prompt, 
                num_repetitions=N_REPETITIONS, 
                temperature=TEMPERATURE, 
                max_new_tokens=MAX_NEW_TOKENS
            )   

        if IS_DEBUG:
            print(""\n\n\n... PIPELINE RAW RESULTS [SIMPLE] ...\n"")
            for i, result in enumerate(results):
                display_hr(True, False)
                display(HTML(f'<span style=""font-weight: bold;"">RESULT #{i+1}'))
                display_hr(False, False)
                display(Markdown(result))
                display_hr(False, True)

        processed_outputs = [process_output(output) for output in results if output]
        boxed_results, code_results = zip(*processed_outputs) if processed_outputs else ([], [])
        final_answer = aggregate_results(code_results, boxed_results)
        final_answers.append(final_answer)

        if IS_DEBUG:
            print(f""\n... RAW CODE RESULTS        : {code_results}"")
            print(f""... RAW BOXED RESULTS       : {boxed_results}"")
            print(f""... AGGREGATED FINAL RESULT : {final_answer}\n\n"")

        submission_ex_df[""answer""] = final_answer
        aimo_env.predict(submission_ex_df)
    except:
        backup_submission_ex_df[""answer""] = 1
        aimo_env.predict(backup_submission_ex_df)

# Show final dataframe (one that was saved)
if IS_DEBUG and not FORCE_NON_DEBUG:
    display(aimo_env.source_sample_submission_df)
# class InferenceHandler:
#     def __init__(
#         self,
#         model_path: str, 
#         tool_instructions: str | None = None,
#         max_new_tokens: int = 1536, 
#         temperature: float = 0.654321, 
#         n_repetitions: int = 3, 
#         use_simple_instruction: bool = True, 
#         boxed_copies_over_code_fail: bool = False,
#         try_again_condition: str = ""all"",
#         simple_to_complex_repetition_ratio: int = 5,
#         minimum_complex_repetitions: int = 1
#     ):
#         """"""Initializes the InferenceHandler with the necessary configurations.

#         Args:
#             model_path (str): Path to the model directory.
#             tool_instructions (str): Additional instructions or information to append to the problem.
#             max_new_tokens (int): Maximum number of new tokens to generate.
#             temperature (float): Controls randomness in output generation.
#             n_repetitions (int): Number of times to run the pipeline for each input.
#             use_simple_instruction (bool): Whether to use simple problem statements.
#             boxed_copies_over_code_fail (bool): Whether non-error boxed results will copy over failed code results.
#             try_again_condition (str, optional): What condition to try again on. One of ['all' | 'boxed' | 'code' | None]
#             simple_to_complex_repetition_ratio (int): How many simple instructions run before 1 complex instruction runs. Ignored if tool_instructions is None (simple only used)
#             minimum_complex_repetitions (int): Minimum number of complex repetitions. Ignored if tool_instructions is None (simple only used)
#         """"""
#         set_seed()
#         quant_config = create_quantization_config()
#         self.model, self.tokenizer = load_model_and_tokenizer(model_path, quant_config)
#         self.pipeline = initialize_pipeline(self.model, self.tokenizer)
#         setup_torch_backend()
        
#         self.simple_to_complex_repetition_ratio = 5
#         if tool_instructions is None and use_simple_instruction==False:
#             raise ValueError
#         self.tool_instructions = tool_instructions
#         self.max_new_tokens = max_new_tokens
#         self.temperature = temperature
#         self.n_repetitions = n_repetitions
#         self.use_simple_instruction = use_simple_instruction
#         self.boxed_copies_over_code_fail = boxed_copies_over_code_fail
#         self.try_again_condition = try_again_condition
        
#         if tool_instructions is None:
#             self.simple_n_repetitions = self.n_repetitions
#             self.complex_n_repetitions = 0
#         else:
#             self.complex_n_repetitions = max(self.n_repetitions//simple_to_complex_repetition_ratio, minimum_complex_repetitions)
#             self.simple_n_repetitions = self.n_repetitions-self.complex_n_repetitions
            
#     def run_inference(self, problem: str, use_simple_instruction: bool = None, temperature: float = None) -> tuple:
#         """"""Runs inference on a given problem and returns the processed outputs.

#         Args:
#             problem (str): The problem text to infer on.
#             use_simple_instruction (bool): Whether to use simple problem statements.
#             temperature (float, optional): An optional override value for temperature

#         Returns:
#             tuple: A tuple containing the raw results, the boxed_results and the code_results.
#         """"""
#         # Handle number of repetitions
#         if self.use_simple_instruction:
#             n_repetitions = self.simple_n_repetitions if use_simple_instruction else self.complex_n_repetitions
#         else:
#             n_repetitions = self.n_repetitions
            
#         full_prompt = prepare_problem_statement(problem, self.tool_instructions, use_simple_instruction)
#         results = run_pipeline(self.pipeline, full_prompt, self.max_new_tokens, temperature or self.temperature, n_repetitions)
#         processed_outputs = [process_output(output) for output in results if output]
#         boxed_results, code_results = zip(*processed_outputs) if processed_outputs else ([], [])
#         return results, boxed_results, code_results
    
#     def get_try_again_flag(self, boxed_results: tuple, code_results: tuple) -> bool:
#         """"""Whether or not we meet the conditions to try again
        
#         Args:
#             boxed_results (tuple): The results from the textual output
#             code_results (tuple): The results from the code output
            
#         Returns:
#             bool indicating whether or not we try again
#         """"""
#         # try again condition capture
#         try_again_flag = False
#         if self.try_again_condition==""all"":
#             try_again_flag = all(x == -1 for x in (list(boxed_results) + list(code_results))) or len((list(boxed_results) + list(code_results))) == 0
#         elif ""code"" in self.try_again_condition:
#             try_again_flag = all(x == -1 for x in list(code_results)) or len(list(code_results)) == 0
#         elif ""boxed"" in self.try_again_condition:
#             try_again_flag = all(x == -1 for x in list(boxed_results)) or len(list(boxed_results)) == 0
#         return try_again_flag
    
    
#     def infer(self, problem: str) -> int:
#         """"""Performs inference on a given problem and returns the final answer.

#         Args:
#             problem (str): The problem text to infer on.

#         Returns:
#             int: The final answer obtained from inference.
#         """"""
#         # Get the results
#         results, boxed_results, code_results = self.run_inference(problem, use_simple_instruction=True)
        
#         # If try again condition is met... here we go
#         if self.get_try_again_flag(boxed_results, code_results):
#             # Get the retried results with slightly higher temp
#             results, boxed_results, code_results = self.run_inference(problem, use_simple_instruction=True, temperature=self.temperature*1.1)
        
#         # Get complex fragment
#         if self.use_simple_instruction and self.complex_n_repetitions>0:
#             _results, _boxed_results, _code_results = self.run_inference(problem, use_simple_instruction=False, temperature=self.temperature*0.9)
#             boxed_results, code_results = list(boxed_results)+list(_boxed_results), list(code_results)+list(_code_results)
        
#         # Get final answer
#         final_answer = aggregate_results(boxed_results, code_results, self.boxed_copies_over_code_fail)
#         return final_answer

#     def infer_on_dataframe(
#         self, df: pd.DataFrame, 
#         id_col: str = ""id"", 
#         problem_col: str = ""problem"", 
#         answer_col: str = ""answer"", 
#         output_csv: str = ""submission.csv""
#     ) -> pd.DataFrame:
#         """"""
#         Performs inference on a DataFrame containing problems and saves the results to a CSV file.

#         Args:
#             df (pd.DataFrame): The DataFrame containing the problems.
#             id_col (str): The name of the column containing problem IDs. Default is ""id"".
#             problem_col (str): The name of the column containing problem texts. Default is ""problem"".
#             answer_col (str): The name of the column to store the inferred answers. Default is ""answer"".
#             output_csv (str): The path to save the output CSV file. Default is ""submission.csv"".

#         Returns:
#             pd.DataFrame: The DataFrame with the inferred answers.
#         """"""
#         final_answers = []
#         for _, row in tqdm(df.iterrows()):
#             try:
#                 final_answer = self.infer(row[problem_col])
#             except:
#                 final_answer = -1
#             final_answers.append(final_answer)
        
#         df[answer_col] = final_answers
#         df[[id_col, answer_col]].to_csv(output_csv, index=False)
#         return df
    
# demo_df = get_aimo_examples(ext_aimo_df, num_of_examples=3)[[""problem_id"", ""problem""]].reset_index(drop=True)
# display(demo_df)

# inference_handler = InferenceHandler(
#     model_path=DEEPSEEK_PATH,
#     tool_instructions=TOOL_INSTRUCTIONS,
#     max_new_tokens=MAX_NEW_TOKENS,
#     temperature=TEMPERATURE,
#     n_repetitions=N_REPETITIONS,
#     use_simple_instruction=True,
#     boxed_copies_over_code_fail=False,
#     try_again_condition = ""code"",
#     simple_to_complex_repetition_ratio = 4,
# )

# review_problem(ext_aimo_df, demo_df[""problem_id""][0])
# inference_handler.infer(demo_df[""problem""][0])
# Just in case...
try:
    if os.path.isfile(""code_to_execute.py""):
        os.remove(""code_to_execute.py"")
except:
    !rm -rf ./code_to_execute.py
# N_SUBSET = 50
# if IS_DEBUG:
#     cv_df = get_aimo_examples(ext_aimo_df, num_of_examples=N_SUBSET)
#     cv_results = []
    
#     for _, row in tqdm(cv_df.iterrows(), total=N_SUBSET):
#         row_result = {""problem_id"": row.problem_id, ""problem"": row.problem, ""gt_result"": row.answer, ""gt_result_solution"": row.solution}
#         full_prompt = prepare_problem_statement(row[""problem""], TOOL_INSTRUCTIONS, tokenizer, use_simple=True)

#         if USE_VLLM:
#             results = run_vllm_pipeline(
#                 model_pipeline=text_gen_pipeline, 
#                 query_prompt=full_prompt, 
#                 num_repetitions=N_REPETITIONS, 
#                 temperature=TEMPERATURE, 
#                 max_new_tokens=MAX_NEW_TOKENS
#             )
#         else:
#             results = run_pipeline(
#                 model_pipeline=text_gen_pipeline, 
#                 query_prompt=full_prompt, 
#                 num_repetitions=N_REPETITIONS, 
#                 temperature=TEMPERATURE, 
#                 max_new_tokens=MAX_NEW_TOKENS
#             )   

#         processed_outputs = [process_output(output) for output in results if output]
#         boxed_results, code_results = zip(*processed_outputs) if processed_outputs else ([], [])
#         final_answer = aggregate_results(code_results, boxed_results)
        
#         row_result[""pred_result""] = final_answer
#         row_result[""pred_result_solutions""] = results
#         row_result[""pred_code_results""] = code_results
#         row_result[""pred_boxed_results""] = code_results
        
#         cv_results.append(row_result)

# try:
#     cv_results_df = pd.DataFrame(cv_results)
    
# except:
#     print(""try again"")

# # 12/50
# cv_results_df[cv_results_df.gt_result==cv_results_df.pred_result]

# # TBD
# cv_results_df.to_csv(""cv_results.csv"", index=False)
# cv_results_df


","<br>

<center><img src=""https://aimoprize.com/logo-dark.png"" width=50% style=""padding: 0 0 !important; margin: 0 0 !important;""></center>

<br style=""margin: 15px;"">

<h2 style=""text-align: center; font-size: 30px; font-style: normal; font-weight: 800; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">
    <span style=""text-decoration: underline;"">
        <font color=#799cb7>L</font>ET'S 
        <font color=#799cb7>L</font>EARN 
        <font color=#799cb7>T</font>OGETHER !
    </span><br><br><br style=""margin: 15px;"">
<span style=""font-size: 22px; letter-spacing: 1px;"">
    <font color=#799cb7>U</font>NDERSTANDING    
    <font color=#799cb7>T</font>HROUGH
    <font color=#799cb7>E</font>XPLORATION
</span><br style=""margin: 15px;""></h2>

<p style=""text-align: center; font-size: 15px; font-style: normal; font-weight: bold; text-decoration: None; text-transform: none; letter-spacing: 1px; color: black; background-color: #ffffff;"">CREATED BY: DARIEN SCHETTLER</p>

<hr>

<center><div class=""alert alert-block alert-danger"" style=""margin: 2em; line-height: 1.7em;"">
    <b style=""font-size: 18px;"">🛑 &nbsp; WARNING:</b><br><br><b>THIS IS A WORK IN PROGRESS</b><br>
</div></center>

<center><div class=""alert alert-block alert-warning"" style=""margin: 2em; line-height: 1.7em;"">
    <b style=""font-size: 16px;"">👏 &nbsp; IF YOU FORK THIS OR FIND THIS HELPFUL &nbsp; 👏</b><br><br><b style=""font-size: 22px; color: darkorange"">PLEASE UPVOTE!</b><br><br>This was a lot of work for me and while it may seem silly, it makes me feel appreciated when others like my work. 😅
</div></center>

<hr>
<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; color: #192a51; background-color: #ffffff;"">
    CHANGELOG
</h1>

<i>Before version 12 this was not tracked rigorously and is a rough approximation. After version 11 it should be better.</i>

<ul>
    <li>
        <b>Version 1-2</b>
        <ul>
            <li>Initial Version</li>
            <li>Cells up to and including the visualization for Art of Problem Solving (AOPS) dataset</li>
        </ul>
    </li>
    <li>
        <b>Version 3-7</b>
        <ul>
            <li>This is me getting the submission to work</li>
            <li>While the visualization and exploration of the other external datasets works here... I disable it for version 7 to work.</li>
        </ul>
    </li>
    <li>
        <b>Version 8-10</b>
        <ul>
            <li>Create my own dataset to prevent having to retrieve the answers in the external GSM8K and MATH datasets.</li>
            <li>Cleanup markdown, structureand modify functions to be more understandable (to me)</li>
            <li>Experimentation with various inference flows</li>
        </ul>
    </li>
    <li>
        <b>Version 11 – <font color=""red"">[LB: 12]</font></b>
        <ul>
            <li>Add a class structure to hold the inference code functionality... <b>I don't love it... may discard</b></li>
            <li>Test inference with self-consistency, fallback if all -1 and more complex prompt.</li>
            <li>Update aggregation logic and add test cases.</li>
        </ul>
    </li>
    <li>
        <b>Version 12 – <font color=""red"">[LB: 15]</font></b>
        <ul>
            <li>Disable quantization like all the popular kids...</li>
            <li><b>Fix(?)</b> the way I'm passing the prompt (no apply_chat_template previously) and see if it improves performance</li>
            <li>Add changelog</li>
            <li>Increase repetition count for submission inference based on timing</li>
            <li>Reenable the override of non-valid code scores with boxed scores</li>
        </ul>
    </li>
    <li>
        <b>Version 13 – <font color=""red"">[LB: N/A]</font></b>
        <ul>
            <li>Replace regular inference with vLLM inference. Thanks to <b><a href=""https://www.kaggle.com/bsmit1659"">Brian Smith</a></b>. Original <b><a href=""https://www.kaggle.com/code/bsmit1659/aimo-vllm-accelerated-tot-sc-deepseekmath/input"">Notebook Here</a></b></li>
            <li>Add support for vLLM in a transformers like fashion (aka pipleine)</li>
            <li>Remove pieces of functionality around falling back if 'complex' prompt or all fails.</li>
            <li><s>Try to set tensor parallel to 2 to squeeze 2xT4. Note you have to reset ray ... this is a known issue.</s> <b>Still not working...</b></li>
            <li>Increase number of repetitions in demo and remove different number for private/public</li>
            <li>Remove complex tool instruction completely</li>
        </ul>
    </li>
    <li>
        <b>Version 14-21 – <font color=""red"">[LB: PENDING]</font></b>
        <ul>
            <li>Update submissions to support new submission API</li>
            <li>Create debug class to mimic submission API</li>
            <li>Update code to leverage 2xT4 with updated ray and grcpio libraries</li>
        </ul>
    </li>
</ul>

<br>
<p id=""toc""></p>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; color: #192a51; background-color: #ffffff;"">
    TABLE OF CONTENTS
</h1>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#introduction"" style=""text-decoration: none; color: #799cb7;"">1&nbsp;&nbsp;&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#background_information"" style=""text-decoration: none; color: #799cb7;"">2&nbsp;&nbsp;&nbsp;&nbsp;BACKGROUND INFORMATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#imports"" style=""text-decoration: none; color: #799cb7;"">3&nbsp;&nbsp;&nbsp;&nbsp;IMPORTS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#setup"" style=""text-decoration: none; color: #799cb7;"">4&nbsp;&nbsp;&nbsp;&nbsp;SETUP AND HELPER FUNCTIONS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#eda"" style=""text-decoration: none; color: #799cb7;"">5&nbsp;&nbsp;&nbsp;&nbsp;EXPLORATORY DATA ANALYSIS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#baseline"" style=""text-decoration: none; color: #799cb7;"">6&nbsp;&nbsp;&nbsp;&nbsp;BASELINE SUBMISSION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#cv"" style=""text-decoration: none; color: #799cb7;"">7&nbsp;&nbsp;&nbsp;&nbsp;CROSS VALIDATION</a></h3>

<hr>
<br>

<a id=""introduction""></a>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""introduction"">1&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.1 <b>WHAT</b> IS THIS?</h3>
<hr>

<ul>
    <li>This notebook will follow the authors learning path and highlight relevant terms, information, and useful content about the competition.</li>
    <li>This notebook will conduct an <b>E</b>xploratory <b>D</b>ata <b>A</b>nalysis for the competition.</li>
    <li>This notebook <i>may</i> propose an open-source baseline solution.</li>
</ul>
<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.2 <b>WHY</b> IS THIS?</h3>
<hr>

<ul>
    <li>Writing and sharing my learning path and the resulting exploratory data analysis can help improve my own understanding of the competition and the data.</li>
    <li>Sharing my work may help others who are interested in the competition (or the data). This help may take the form of:
        <ul>
            <li>Better understanding the problem and potential common solutions (incl. my baseline).</li>
            <li>Better understanding of the provided dataset.</li>
            <li>Better understanding of the background information and research.</li>
            <li>Better ability to hypothesize new solutions.</li>
        </ul>
    </li>
    <li>Exploratory data analysis is a critical step in any data science project. Sharing my EDA might help others in the competition.</li>
    <li>Writing and sharing my work is often a fun and rewarding experience! It not only allows me to explore and try different techniques, ideas, and visualizations but also encourages and supports other learners and participants.</li>
</ul>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.3 <b>WHO</b> IS THIS FOR?</h3>
<hr>


<ul>
    <li>The primary purpose of this notebook is to educate <b>MYSELF</b>, however, my review/learning might be beneficial to others:
        <ul>
            <li>Other Kagglers (aka. current and future competition participants).</li>
            <li>Anyone interested in learning more about using artificial intelligence to tackle mathematics.</li>
        </ul>
    </li>
</ul>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.4 <b>HOW</b> WILL THIS WORK?</h3>
<hr>


<p>I'm going to assemble some markdown cells (like this one) at the beginning of the notebook to go over some concepts/details/etc.</p>

<p>Following this, I will attempt to walk through the data and understand it better prior to composing a baseline solution.</p>
<br>

<a id=""background_information""></a>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""background_information"">2&nbsp;&nbsp;BACKGROUND INFORMATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

The <b><a href=""https://www.imo-official.org/"">International Mathematical Olympiad</a> (IMO)</b> is a prestigious global high school maths competition. Countries enter teams of six students, who each individually attempt six highly challenging problems over two days, under exam conditions. Answers are marked by an expert panel, which awards individual <b>gold, silver and bronze medals</b>

A gold medal in the IMO is a benchmark for exceptional mathematical achievement and a strong predictor of future success. <b>IMO gold medallists are 50 times more likely to win a <a href=""https://en.wikipedia.org/wiki/Fields_Medal"">Fields Medal</a> than a typical Cambridge PhD graduate</b>. Indeed, half of all Fields medallists participated in the IMO in their youth.

Building on these traditions, the <b><a href=""https://aimoprize.com/"">AIMO Prize</a></b> has been established to spur the open development of AI models that can reason mathematically to solve problems. This is a new frontier of knowledge and scientific discovery, for which the AIMO Prize could represent a new Turing Test.

<b>The <a href=""https://aimoprize.com/"">AIMO Prize</a> is proposing three initial design principles:</b>

<ol>
    <li>AI models must consume <b><mark>problems in the same format as human contestants</mark></b> and must <b><mark>produce human readable solutions</mark></b> that <b><mark>can be graded by an expert panel, using standard Olympiad criteria.</mark></b></li>
    <li>The grand prize will be awarded for performance in an AIMO approved competition that is at a <b><mark>standard equivalent to a gold medal in the IMO.</mark></b></li>
    <li>To be eligible to win prizes, participants must have <b><mark>adhered to the AIMO public sharing protocol</mark></b> by the time the prize is awarded.</li>
</ol>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.1 <b>UNDERSTANDING</b> THE <b>AIMO</b> PROGRESS PRIZE #1</h3>
<hr>

The First Progress Prize is designed to incentivise the achievement of key milestones towards the grand prize, and opened in April 2024. This prize will be for participation and performance in the Kaggle competition found <b><a href=""https://www.kaggle.com/competitions/ai-mathematical-olympiad-prize"">here</a></b>.

The goal of this competition is to create algorithms and models that can <mark><b>solve tricky math problems</b></mark> written in <mark><b>LaTeX format</b></mark>.
<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.2 <b>COMPETITION OVERVIEW</b></h3>
<hr>

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">PRIMARY TASK DESCRIPTION</b>
<br>
<br>
Develop AI models capable of performing as well as top human participants in the International Mathematical Olympiad (IMO) on a dataset of 110 novel math problems. The Gemma 7B benchmark is 3/50 on public and private test sets.

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">HOST TASK DESCRIPTION</b>
<br>
<br>
The goal of this competition is to create algorithms and models that can solve tricky math problems written in LaTeX format. Your participation will help to advance AI models’ mathematical reasoning skills and drive frontier knowledge.

The AI Mathematical Olympiad (AIMO) Prize is a new <b>10mn</b> prize fund to spur the open development of AI models capable of performing as well as top human participants in the International Mathematical Olympiad (IMO).
This competition includes 110 problems similar to an intermediate-level high school math challenge. The Gemma 7B benchmark for these problems is 3/50 on the public and private test sets.

The assessment of AI models' mathematical reasoning skills faces a significant hurdle, the issue of train-test leakage. Models trained on Internet-scale datasets may inadvertently encounter test questions during training, skewing the evaluation process.

To address this challenge, this competition uses a dataset of 110 novel math problems, created by an international team of problem solvers, recognizing the need for a transparent and fair evaluation framework. The dataset encompasses a range of difficulty levels, from simple arithmetic to algebraic thinking and geometric reasoning. This will help to strengthen the benchmarks for assessing AI models' mathematical reasoning skills, without the risk of contamination from training data.

This competition offers an exciting opportunity to benchmark open AI models against each other and foster healthy competition and innovation in the field. By addressing this initial benchmarking problem, you will contribute to advancing AI capabilities and help to ensure that its potential benefits outweigh the risks.

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">PRIZE FUND (IT IS WORTH MENTIONING AGAIN)</b>
<br>
<br>
The AIMO Prize offers a <b>10 million dollar (\$USD) prize</b> fund to spur open AI development in mathematical reasoning.

* **Prizes for Top-Ranking Teams in this Competition**
    * 1st Place: \$131,072
    * 2nd Place: \$65,536
    * 3rd Place: \$32,768
    * 4th Place: \$16,384
    * 5th Place: \$8,192
* **Overall Progress Prize Winner:**
    * The Overall Progress Prize Winner shall be the highest ranking team that achieves a score of at least 47/50 on both public and private test sets. 
    * After any prizes for the five top-ranking teams have been awarded, the remainder of the total fund shall be awarded to the Overall Progress Prize Winner.
    * If a team is named the Overall Progress Prize Winner in this competition, the prize will be at least \$794,624. 
    * If no team is named the Overall Progress Prize Winner in this competition, the remainder of the total fund shall roll over to the next competition, where the same prize allocation will apply.
* **Early Sharing Prize**: \$10,000. 
    * An additional 10,000 dollar cash prize will be awarded for sharing high-scoring public notebooks early in the competition to encourage participants to share information earlier and help the community make more progress over the course of the competition.
    * To be eligible for the Early Sharing Prize, you will need to:
        * Be the first to publish a public notebook scoring at least 20/50 on the leaderboard before April 22, 2024 11:59PM UTC.
        * Keep the notebooks and any datasets it uses publicly available until the prize is awarded at the end of the competition.

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">VISUAL TASK DESCRIPTION</b>
<br>
<br>
Here is an example of what we have to do. This reasoning trace was generated by <b>Claude Opus</b>... we have to do something similar to get the final answer (integer between 0-1000) but using a much smaller (more tractable) model:

<div style=""background-color: #f5f5f5; border-radius: 10px; padding: 20px; margin: 20px;"">
    <b>PROBLEM:</b>
    <br>
    <br>
    <br>
    Let $k, l > 0$ be parameters.
    <br>
    The parabola $y = kx^2 - 2kx + l$ intersects the line $y = 4$ at two points $A$ and $B$.
    <br>
    These points are distance 6 apart. 
    <br><br>
    What is the sum of the squares of the distances from $A$ and $B$ to the origin?
</div>

<div style=""background-color: #e9fce9; border-radius: 10px; padding: 20px; margin: 20px;"">
    <b>SOLUTION REASONING TRACE:</b>
    <br>
    <br>
    <br>
    <b>Problem Statement:</b>
    <br>
    <br>
    Given a parabola defined by \( y = kx^2 - 2kx + l \) and a line \( y = 4 \), where \( k, l > 0 \), find the sum of the squares of the distances from the points of intersection, \( A \) and \( B \), to the origin. These points are known to be 6 units apart.
    <br>
    <br>
    <br>
    <b>Solution:</b>
    <br>
    <br>
    <br>
    1. <b>Set Up the Intersection Equation:</b>
    <br>
    <br>
       Start by setting the parabola equal to the line to find the x-coordinates of points \( A \) and \( B \):
       <br><br>
       \[
       kx^2 - 2kx + l = 4
       \]
       <br>
       Rearrange to form a standard quadratic equation:
       <br><br>
       \[
       kx^2 - 2kx + (l - 4) = 0
       \]
    <br>
    <br>
    <br>
    2. <b>Solve the Quadratic Equation:</b>
    <br>
    <br>
       Apply the quadratic formula \( x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} \) to solve for \( x \):
    <br><br>
       \[
       x = \frac{2k \pm \sqrt{4k^2 - 4k(l - 4)}}{2k} = 1 \pm \sqrt{1 - \frac{l - 4}{k}}
       \]
    <br>
       Let \( x_A = 1 + \sqrt{1 - \frac{l-4}{k}} \) and \( x_B = 1 - \sqrt{1 - \frac{l-4}{k}} \).
    <br>
    <br>
    <br>
    3. <b>Distance Between Points \( A \) and \( B \):</b>
    <br>
    <br>
       Given \( |x_A - x_B| = 6 \), compute:
    <br><br>
       \[
       \left|2\sqrt{1 - \frac{l - 4}{k}}\right| = 6 \implies \sqrt{1 - \frac{l - 4}{k}} = 3
       \]
    <br>
       Solving for \( l \) and \( k \):
    <br><br>
       \[
       1 - \frac{l - 4}{k} = 9 \implies \frac{l - 4}{k} = -8 \implies l - 4 = -8k \implies l = -8k + 4
       \]
    <br>
    <br>
    <br>
    4. <b>Calculate Distances from Origin:</b>
    <br>
    <br>
       Using the x-coordinates \( x_A = 4 \) and \( x_B = -2 \) and y-coordinate \( y = 4 \):
    <br>
    <br>
       \[
       d_A = \sqrt{x_A^2 + 4^2} = \sqrt{16 + 16} = \sqrt{32} = 4\sqrt{2}
       \]
    <br>
       \[
       d_B = \sqrt{x_B^2 + 4^2} = \sqrt{4 + 16} = \sqrt{20} = 2\sqrt{5}
       \]
    <br>
    <br>
    <br>
    5. <b>Sum of Squares of Distances:</b>
    <br>
    <br>
       Compute the sum of squares:
    <br><br>
       \[
       d_A^2 + d_B^2 = (4\sqrt{2})^2 + (2\sqrt{5})^2 = 32 + 20 = 52
       \]
    <br>
    <br>
    <br>
    <b>Conclusion:</b>
    <br><br>
    The sum of the squares of the distances from points \( A \) and \( B \) to the origin is \( 52 \).
</div>

<br>

<b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">COMPETITION HOST(S)/CONTRIBUTOR(S)</b>
    <br>

<b><u>XTX Markets</u></b> is a leading algorithmic trading company and has over 200 employees based in London, Paris, New York, Mumbai, Yerevan and Singapore. XTX provides liquidity in the Equity, FX, Fixed Income and Commodity markets and trades over 250bn a day across markets.
<br><br>
XTX Markets' expansive research cluster contains 100,000 cores and 20,000 A/V100 GPUs and is growing. It also has 390 petabytes of usable storage and 7.5 petabytes of RAM. Alongside rich datasets and advanced technological infrastructure we are at the forefront of the crossover of finance and technology.
<br><br>
XTX Markets’ philanthropy focuses on maths and science education and research, alongside other areas such as academic sanctuaries, carbon removal and an employee matching programme. Since 2017, XTX Markets has donated over £100mn to charities and good causes, establishing it as a major donor in the UK and globally.
<br>

<h3 style=""font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.3 <b>DATASET INFORMATION</b></h3>

<hr>

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">HIGH LEVEL DATA SUMMARY</b>

The AI Mathematical Olympiad (AIMO) Prize competition is designed to enhance the mathematical reasoning capabilities of AI by engaging models in a set of 110 mathematics problems similar to those found in high school competitions like the AIME. The competition challenges AI to predict integer solutions to these problems, with solutions constrained to values between 0 and 999. This initiative provides a rigorous platform for assessing AI mathematical reasoning in a controlled environment, devoid of the typical train-test data leakage issues.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">DATA COMPOSITION</b>

The dataset consists of 110 math problems divided across a training set of 10 problems and two test sets, each containing 50 unique problems. These problems span various mathematical subjects including arithmetic, algebra, and geometry, presented in text format with mathematical expressions formatted in LaTeX.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">DATA FILE DESCRIPTIONS</b>

<b><code>train.csv</code>:</b>
* Contains 10 problems used for training models. Each record includes:
    - <b><code>id</code> (string):</b> A unique identifier for each problem.
    - <b><code>problem</code> (string):</b> The text of the problem, including LaTeX for mathematical notation.
    - <b><code>answer</code> (int):</b> The integer answer for the problem, between 0 and 999.

<b><code>test.csv</code>:</b>
* Contains 50 placeholder problems for submission trials; these will be replaced with the actual problems during the scoring phase. Each record contains:
    - <b><code>id</code> (string):</b> A unique identifier corresponding to each problem.
    - <b><code>problem</code> (string):</b> Placeholder text of the problem; not representative of the final test problems.

<b><code>sample_submission.csv</code>:</b>
* Provides a format template for submissions. Each record includes:
    - <b><code>id</code> (string):</b> The problem identifier.
    - <b><code>answer</code> (int):</b> Participants must fill in their predicted integer answer for each problem.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">UNIQUE ASPECTS OF THE DATASET</b>

This dataset is specifically engineered to avoid overlap with publicly available data, thus eliminating the risk of train-test leakage. This clean separation ensures a fair evaluation of a model's capability to solve mathematical problems from scratch. Additionally, all responses must be reported modulo 1000, introducing a unique element of complexity to the answering process.

<br><b style=""text-decoration: underline; font-size: 15px; text-transform: uppercase; letter-spacing: 2px; font-weight: 900;"">DATASET CHALLENGES AND OPPORTUNITIES</b>

The dataset's limited size poses a challenge for model training, requiring efficient generalization from minimal examples. The range of problem complexity, from basic arithmetic to advanced geometric reasoning without visual aids, demands robust textual and numerical interpretation capabilities from participating AI models. These challenges, however, provide valuable opportunities for breakthroughs in AI's mathematical reasoning and its applications in mathematically intensive fields.
<a id=""imports""></a>

<h1 style=""font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""imports"">3&nbsp;&nbsp;IMPORTS&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

<a id=""setup""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""setup"">4&nbsp;&nbsp;SETUP & HELPER FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.0 FUNCTIONS FROM <b>OTHER KAGGLERS</b> 🩵</h3>
<hr><br>

**Give me time to populate this... I am using rewritten variants of quite a few functions and will update with acknowledgement later on... For now I will list a few notebooks to go give upvotes to**
* https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
* https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
* https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
* https://www.kaggle.com/code/bsmit1659/aimo-vllm-accelerated-tot-sc-deepseekmath/notebook

<br>

<b>Thanks to <a href=""https://www.kaggle.com/olyatsimboy"">Olga Tsymboi </a></b> for the information on how to run 2xT4 with vLLM</b>

<br>
<br>

**DETAILS OF `sampling_params`**

```
n: Number of output sequences to return for the given prompt.

best_of: Number of output sequences that are generated from the prompt.
         From these `best_of` sequences, the top `n` sequences are returned.
         `best_of` must be greater than or equal to `n`. This is treated as
         the beam width when `use_beam_search` is True. By default, `best_of`
         is set to `n`.

presence_penalty: Float that penalizes new tokens based on whether they
                  appear in the generated text so far. Values > 0 encourage the model
                  to use new tokens, while values < 0 encourage the model to repeat
                  tokens.

frequency_penalty: Float that penalizes new tokens based on their
                   frequency in the generated text so far. Values > 0 encourage the
                   model to use new tokens, while values < 0 encourage the model to
                   repeat tokens.

repetition_penalty: Float that penalizes new tokens based on whether
                    they appear in the prompt and the generated text so far. Values > 1
                    encourage the model to use new tokens, while values < 1 encourage
                    the model to repeat tokens.

temperature: Float that controls the randomness of the sampling. Lower
             values make the model more deterministic, while higher values make
             the model more random. Zero means greedy sampling.

top_p: Float that controls the cumulative probability of the top tokens
       to consider. Must be in (0, 1]. Set to 1 to consider all tokens.

top_k: Integer that controls the number of top tokens to consider. Set
       to -1 to consider all tokens.

min_p: Float that represents the minimum probability for a token to be
       considered, relative to the probability of the most likely token.
       Must be in [0, 1]. Set to 0 to disable this.

seed: Random seed to use for the generation.

use_beam_search: Whether to use beam search instead of sampling.

length_penalty: Float that penalizes sequences based on their length.
                Used in beam search.

early_stopping: Controls the stopping condition for beam search. It
                accepts the following values: `True`, where the generation stops as
                soon as there are `best_of` complete candidates; `False`, where an
                heuristic is applied and the generation stops when is it very
                unlikely to find better candidates; `""never""`, where the beam search
                procedure only stops when there cannot be better candidates
                (canonical beam search algorithm).

stop: List of strings that stop the generation when they are generated.
      The returned output will not contain the stop strings.

stop_token_ids: List of tokens that stop the generation when they are
                generated. The returned output will contain the stop tokens unless
                the stop tokens are special tokens.

include_stop_str_in_output: Whether to include the stop strings in
                            output text. Defaults to False.

ignore_eos: Whether to ignore the EOS token and continue generating
            tokens after the EOS token is generated.

max_tokens: Maximum number of tokens to generate per output sequence.

min_tokens: Minimum number of tokens to generate per output sequence
            before EOS or stop_token_ids can be generated

logprobs: Number of log probabilities to return per output token.
          Note that the implementation follows the OpenAI API: The return
          result includes the log probabilities on the `logprobs` most likely
          tokens, as well the chosen tokens. The API will always return the
          log probability of the sampled token, so there  may be up to
          `logprobs+1` elements in the response.

prompt_logprobs: Number of log probabilities to return per prompt token.

detokenize: Whether to detokenize the output. Defaults to True.

skip_special_tokens: Whether to skip special tokens in the output.

spaces_between_special_tokens: Whether to add spaces between special
                               tokens in the output.  Defaults to True.

logits_processors: List of functions that modify logits based on
                   previously generated tokens.

truncate_prompt_tokens: If set to an integer k, will use only the last k
                        tokens from the prompt (i.e., left truncation). Defaults to None
                        (i.e., no truncation).
```
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.1 GENERIC HELPER FUNCTIONS</h3>
<hr><br>

These are some functions I carry around with me that I find commonly helpful.

**There are also a few dataset loading functions included here just to ensure they fall before the setup cell**

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.2 <b>LOAD</b> THE DATASET(S)</h3>
<hr><br>

We also define path information and other constants that are helpful in establishing early.

<br>

**SIDE NOTE:** `.asy` or `[asy]` refers to the <b><a href=""https://asymptote.sourceforge.io/"">Asymptote</a></b> vector plotting language. I couldn't figure out a way to plot it inline. We generally want to remove/ignore these questions anyway...
<a id=""eda""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""eda"">5&nbsp;&nbsp;EXPLORATORY DATA ANALYSIS&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.1 <b>EXPLORE</b> THE ART OF PROBLEM SOLVING EXTERNAL DATASET</h3>
<hr><br>

We also define some helpful functions along the way
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.2 <b>EXPLORE</b> THE GSM8K+MATH EXTERNAL DATASET</h3>
<hr><br>

**NOTE: I am loading my version of the external aimo dataset in the cell below... I have left the commented out code showing how I generated it though**
* If you run this code the `extract_and_evaluate_solution` will hang on example `4557`... I have to manually kill and continue after this... I discard it after this.

<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.3 <b>FILTER</b> AND FIX THE EXTERNAL DATASETS</h3>
<hr><br>

We want to remove/improve examples that do not match the requirements as defined in this competition. Specifically:
- Positive integer answer (drop offending rows)
- Remove multiple choice selection (remove text including multiple choice problems - or drop rows for simplicity)
- Remove [asy][/asy] from problems and solutions
- Rewrite #### ANSWER as //boxed{ANSWER}

We are only doing this on the joint dataset as that is what we plan to use.
<a id=""baseline""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""baseline"">6&nbsp;&nbsp;BASELINE SOLUTION AND EVALUATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.1 <b>DEFINE</b> THE REQUIRED FUNCTIONS TO HELP US</h3>
<hr><br>

I will attempt to attribute the base functions in the docstrings in coming versions... but please see my earlier mention of the notebooks that I used for help.
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.2 <b>LOAD</b> THE MODEL, DEFINE CONSTANTS, AND CREATE THE PIPELINE</h3>
<hr>

1. Set the seed for determinism
2. Create a quantization config for double quantized 4 bit quantization with `bitsandbytes`
3. Load the model/tokenizer with the specified quantization config
4. Create a huggingfae pipeline for inferece
5. Prepare the torch backend accordingly

<br>
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.3 <b>DEFINE</b> <s>COMPLEX</s> PROMPT</h3>
<hr><br>

**NOTE: I'm not using this in the vLLM versions of the notebook**

The simple prompt is:

```python
... = problem + ""\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.""
```
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.4 <b>DEMONSTRATE</b> THE INFERENCE FLOW</h3>
<hr><br>

**TO DO**
* Clean this up
<br>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.5 <b>INFER</b> ON THE TEST DATA</h3>
<hr><br>

<b>We instantiate the AIMO SUBMISSION API and update our solution code to accomodate</b><br><br>

---

```python
# Set up the evaluation API
import aimo
aimo_env = aimo.make_env()
AIMO_ITER_TEST = aimo_env.iter_test()
```

<i>Note that this public version of the API does not randomize the order in which problems are served. The API used when your submission is scored will randomize the order.</i>

Example on how to use:

```python
# Iterate through the test set and use the model make predictions
for test_ex_df, submission_ex_df in AIMO_ITER_TEST:
    submission_ex_df['answer'] = model.predict(test_ex_df['problem'])
    env.predict(submission_ex_df)
```

---
<a id=""cv""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""cv"">7&nbsp;&nbsp;CROSS VALIDATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #192a51;"" href=""#toc"">&#10514;</a></h1>

<br>

All of our cross validation will happen within a block that only runs if we are debugging.
","['AI Mathematical Olympiad - Progress Prize 1', 'AIMO External Dataset', 'AMIO parsed ""Art Of Problem Solving"" website', 'antlr4-python3-runtime package 4.11', 'bitsandbytes-0.42.0-py3-none-any.whl', 'deepseek-math', 'External Datasets After Preprocessing for AIMO', 'My CSS Styles', 'open-math-mistral', 'vllm T4 Fix', 'vllm_whl']","['IPython.core.display', 'transformers', 'vllm', 'torch;', 'aimo', 'pandas', 'numpy', 'sympy', 'sympy.parsing.latex', 'sklearn;', 'typing', 'kaggle_datasets', 'dataclasses', 'collections', 'datetime', 'zipfile', 'glob', 'subprocess', 'warnings', 'requests', 'textwrap', 'hashlib', 'imageio', 'IPython', 'urllib', 'pickle', 'random', 'shutil', 'string', 'json', 'copy', 'math', 'time', 'gzip', 'ast', 'sys', 'io', 'gc', 're', 'os', 'matplotlib.pyplot', 'tqdm.notebook', 'plotly.express', 'seaborn', 'PIL', 'matplotlib;', 'plotly']","I'd be happy to summarize the unique aspects of this Machine Learning code written in Python.

**Code Overview**

The code is part of a larger AI-powered system for generating solutions to math problems. It appears to involve a combination of natural language processing (NLP), text generation, and machine learning techniques.

**Unique Aspects**

1. **Inference Handling**: The code defines an `InferenceHandler` class that performs inference on input data using a pre-trained model.
2. **Text Generation**: The code uses various text generation pipelines to generate solutions to math problems.
3. **Cross-Validation**: The code includes a block for cross-validation, which is only executed when the system is in debug mode.
4. **Aggregation of Results**: The code defines an `aggregate_results` function that aggregates the results from multiple runs of the inference handler.
5. **Handling Errors and Exceptions**: The code includes various try-except blocks to handle errors and exceptions during execution.

**Key Functions**

1. `infer`: performs inference on input data using the pre-trained model.
2. `prepare_problem_statement`: prepares a math problem statement for text generation.
3. `run_vllm_pipeline`/`run_pipeline`: runs text generation pipelines using VLLM or a standard pipeline, respectively.
4. `process_output`: processes the output from text generation pipelines.

**Data Structures**

1. `DataFrame`: used to store and manipulate data, including input math problems and their corresponding solutions.
2. Lists: used to store arrays of results and intermediate values.

Please let me know if you'd like me to summarize any specific aspects or sections of this code further!"
AIMO OpenMath-Mistral Baseline,https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline,1.0,,gold,91,3453,447.5s - GPU T4 x2,2 months,"# credits:
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
# OpenMath models

OpenMath models were trained on synthetic dataset created using PoT-like prompting for Mixtral model.

The key feature is that training instructions were designed in a way to reduce parsing difficulties on the post-processing stage, i.e. the final answer will be inside `\boxed{}` block.

For more details please refer to the [paper](https://arxiv.org/pdf/2402.10176.pdf) and [HF training dataset card](https://huggingface.co/datasets/nvidia/OpenMathInstruct-1)

In this baseline we will consider [OpenMath-Mistral-7B-v0.1](https://huggingface.co/nvidia/OpenMath-Mistral-7B-v0.1-hf)
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig, AutoConfig

MODEL_PATH = ""/kaggle/input/open-math-mistral""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map=""auto"",
    torch_dtype=""auto"",
    trust_remote_code=True,
#     quantization_config=quantization_config,
    config=config
)
model.dtype
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
prompt_template = ""System:\n{system}\n\nUser:\n{user}Assistant:\n{generated_solution}""

system = ""You're an expert Python programmer and mathematician. Help the user to solve this problem using code when necessary. Make sure to put the answer (and only answer) inside \\boxed{}.""

user = ""{question}\n\n{context}""

context = """"
generated_solution = """"

print(system)
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return int(''.join(out))
import transformers

pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=""auto"",
)
print(f""Transformers Version: {transformers.__version__}"")
import torch

torch.backends.cuda.enable_mem_efficient_sdp(False)
import re

answers = []

for i in tqdm(range(len(df))):
    try:
        id_ = df['id'].loc[i]
        problem = df['problem'].loc[i]
        
        user_p = user.format(question=problem, context=context)
        query_prompt = prompt_template.format(
            system=system,
            user=user_p,
            generated_solution=generated_solution
        )

        raw_output = pipeline(
            query_prompt, 
            do_sample=False, 
            temperature=0.,
            num_return_sequences=1,
            max_new_tokens=768)
        
        raw_output = raw_output[0]['generated_text']
        
        
        output = re.findall(r'\\boxed\{(.*?)\}', raw_output)[-1]
        
        if not len(output):
            output = naive_parse(raw_output)
        
        output = round(float(output)) % 1000
        
        answers.append(output)
        
        torch.cuda.empty_cache()
        gc.collect()
        
    except Exception as e:
        print(e)
        answers.append(0)
df['answer'] = answers
df
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')

","# credits:
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig, AutoConfig

MODEL_PATH = ""/kaggle/input/open-math-mistral""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map=""auto"",
    torch_dtype=""auto"",
    trust_remote_code=True,
#     quantization_config=quantization_config,
    config=config
)
model.dtype
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
prompt_template = ""System:\n{system}\n\nUser:\n{user}Assistant:\n{generated_solution}""

system = ""You're an expert Python programmer and mathematician. Help the user to solve this problem using code when necessary. Make sure to put the answer (and only answer) inside \\boxed{}.""

user = ""{question}\n\n{context}""

context = """"
generated_solution = """"

print(system)
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return int(''.join(out))
import transformers

pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=""auto"",
)
print(f""Transformers Version: {transformers.__version__}"")
import torch

torch.backends.cuda.enable_mem_efficient_sdp(False)
import re

answers = []

for i in tqdm(range(len(df))):
    try:
        id_ = df['id'].loc[i]
        problem = df['problem'].loc[i]
        
        user_p = user.format(question=problem, context=context)
        query_prompt = prompt_template.format(
            system=system,
            user=user_p,
            generated_solution=generated_solution
        )

        raw_output = pipeline(
            query_prompt, 
            do_sample=False, 
            temperature=0.,
            num_return_sequences=1,
            max_new_tokens=768)
        
        raw_output = raw_output[0]['generated_text']
        
        
        output = re.findall(r'\\boxed\{(.*?)\}', raw_output)[-1]
        
        if not len(output):
            output = naive_parse(raw_output)
        
        output = round(float(output)) % 1000
        
        answers.append(output)
        
        torch.cuda.empty_cache()
        gc.collect()
        
    except Exception as e:
        print(e)
        answers.append(0)
df['answer'] = answers
df
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')

","# OpenMath models

OpenMath models were trained on synthetic dataset created using PoT-like prompting for Mixtral model.

The key feature is that training instructions were designed in a way to reduce parsing difficulties on the post-processing stage, i.e. the final answer will be inside `\boxed{}` block.

For more details please refer to the [paper](https://arxiv.org/pdf/2402.10176.pdf) and [HF training dataset card](https://huggingface.co/datasets/nvidia/OpenMathInstruct-1)

In this baseline we will consider [OpenMath-Mistral-7B-v0.1](https://huggingface.co/nvidia/OpenMath-Mistral-7B-v0.1-hf)
","['AI Mathematical Olympiad - Progress Prize 1', 'bitsandbytes-0.42.0-py3-none-any.whl', 'open-math-mistral']","['torch', 'transformers', 'pandas', 'tqdm', 'gc', 're']","Unique aspects:
1. The use of OpenMath models trained on a synthetic dataset created using PoT-like prompting for Mixtral model.
2. The integration of BitsAndBytesConfig to perform quantization and optimize the model for inference.

Steps taken:
1. Installed necessary packages, including torch and transformers.
2. Loaded pre-trained OpenMath-Mistral-7B-v0.1 model and tokenizer.
3. Set up the pipeline for text generation using the loaded model and tokenizer.
4. Read in test and train datasets from Kaggle input.
5. Formatted prompts for each problem in the dataset using a template.
6. Generated solutions for each problem using the text generation pipeline.
7. Extracted answers from generated solutions using regular expressions.
8. Saved the answers to a submission.csv file.

Summary: This code implements a machine learning model for generating mathematical solutions using Python. The model is trained on a synthetic dataset and uses quantization and optimization techniques to improve its performance. The code reads in datasets, generates prompts and solutions for each problem, and extracts the final answers."
Updated Code Interpretation,https://www.kaggle.com/code/lewtun/updated-code-interpretation,21.0,,gold,83,5928,430.5s - GPU T4 x2,23 days,"## Forked from https://www.kaggle.com/code/abdurrafae/improved-code-interpretation
**Lewis:** the only changes in this notebook are those needed to run the original one with the new Kaggle evaluation API
## Forked From  https://kaggle.com/code/xiaoz259/pure-rng/notebook


# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
import time

NOTEBOOK_START_TIME = time.time()
import aimo

env = aimo.make_env()
iter_test = env.iter_test()
TO-DO

Change temperature as the question goes longer
Change temperature based on question lenght
# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
DEBUG = False

QUANT = False

if QUANT:
    from transformers import BitsAndBytesConfig
    quantization_config = BitsAndBytesConfig(
        load_in_4bit = True,
        bnb_4bit_quant_type=""nf4"",
        bnb_4bit_compute_dtype=torch.bfloat16,
        bnb_4bit_use_double_quant=True,
    )

USE_PAST_KEY = True
%%time
if QUANT:
    !pip install -U /kaggle/input/accelerate-wheelwhl/accelerate-0.29.1-py3-none-any.whl -qq
    !pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq


import torch
import gc
torch.backends.cuda.enable_mem_efficient_sdp(False)

from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    AutoConfig,
    StoppingCriteria,
    set_seed
)

import transformers
print(f""Transformers Version: {transformers.__version__}"")
set_seed(42)
import pandas as pd
from tqdm import tqdm
PRIVATE = True

# df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
# df.head()
# if len(df) < 5:
#     df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
#     PRIVATE = False
# df.head()
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import re
import sys
import subprocess

def return_last_print(output, n):
    lines = output.strip().split('\n')
    if lines:
        return lines[n]
    else:
        return """"

def process_code(code, return_shell_output=False):
    
    def repl(match):
        if ""real"" not in match.group():
            return ""{}{}"".format(match.group()[:-1], ', real=True)')
        else:
            return ""{}{}"".format(match.group()[:-1], ')')
    code = re.sub(r""symbols\([^)]+\)"", repl, code)

    if return_shell_output:
        code = code.replace('\n', '\n    ')
            # Add a try...except block
        code = ""\ntry:\n    from sympy import *\n{}\nexcept Exception as e:\n    print(e)\n    print('FAIL')\n"".format(code)
    
    if not return_shell_output:
        print(code)
    with open('code.py', 'w') as fout:
        fout.write(code)
    
    batcmd = 'timeout 7 ' + sys.executable + ' code.py'
    try:
        shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
        return_value = return_last_print(shell_output, -1)
        print(shell_output)
        if return_shell_output:
            if return_value=='FAIL':
                CODE_STATUS = False
                return_value = return_last_print(shell_output, -2)
                if ""not defined"" in return_value:
                    return_value+='\nTry checking the formatting and imports'
            else:
                CODE_STATUS = True
            return return_value, CODE_STATUS  
        code_output = round(float(eval(return_value))) % 1000
    except Exception as e:
        print(e,'shell_output')
        code_output = -1
    
    if return_shell_output:
        if code_output==-1:
            CODE_STATUS = False
        else:
            CODE_STATUS = True
        return code_output, CODE_STATUS  
    
    
    return code_output


def process_text_output(output):
    result = output    
    try:
        result_output = re.findall(r'\\boxed\{(\d+)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED FINAL', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING TEXT')
        result_output = -1
    
    return result_output

torch.cuda.empty_cache()
gc.collect()
import re
import math
import random

from collections import defaultdict

n_repetitions = 19 if PRIVATE else 4 # Original notebook had 22 but times out :(
TOTAL_TOKENS = 2048 # if PRIVATE else 512

if PRIVATE:
    TIME_LIMIT = 31500
else:
    TIME_LIMIT = 1
if PRIVATE:

    MODEL_PATH = ""/kaggle/input/deepseek-math""#""/kaggle/input/gemma/transformers/7b-it/1""
    DEEP = True

    config = AutoConfig.from_pretrained(MODEL_PATH)
    config.gradient_checkpointing = True

    tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

    device_map = [('model.embed_tokens', 0),
                 ('model.layers.0', 0),
                 ('model.layers.1', 0),
                 ('model.layers.2', 0),
                 ('model.layers.3', 0),
                 ('model.layers.4', 0),
                 ('model.layers.5', 0),
                 ('model.layers.6', 0),
                 ('model.layers.7', 0),
                 ('model.layers.8', 0),
                 ('model.layers.9', 0),
                 ('model.layers.10', 0),
                 ('model.layers.11', 0),
                 ('model.layers.12', 0),
                 ('model.layers.13', 0),
                 ('model.layers.14', 0),
                 ('model.layers.15', 0),
                 ('model.layers.16', 0),
                 ('model.layers.17', 0),
                 ('model.layers.18', 0),
                 ('model.layers.19', 0),
                 ('model.layers.20', 0),
                 ('model.layers.21', 0),
                 ('model.layers.22', 1),
                 ('model.layers.23', 1),
                 ('model.layers.24', 1),
                 ('model.layers.25', 1),
                 ('model.layers.26', 1),
                 ('model.layers.27', 1),
                 ('model.layers.28', 1),
                 ('model.layers.29', 1),
                 ('model.norm', 1),
                 ('lm_head', 1)]

    device_map = {ii:jj for (ii,jj) in device_map}

    if QUANT:
        from transformers import BitsAndBytesConfig
        quantization_config = BitsAndBytesConfig(
            load_in_4bit = True,
            bnb_4bit_quant_type=""nf4"",
            bnb_4bit_compute_dtype=torch.bfloat16,
            bnb_4bit_use_double_quant=True,
        )
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=""sequential"",
            torch_dtype=""auto"",
            trust_remote_code=True, 
            quantization_config=quantization_config,
            config=config
        )
    else:  
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=device_map,
            torch_dtype=""auto"",
            trust_remote_code=True,
            #quantization_config=quantization_config,
            config=config
        )
    
    pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=device_map,
)
    from transformers import StoppingCriteriaList

    class StoppingCriteriaSub(StoppingCriteria):
        def __init__(self, stops = [], encounters=1):
            super().__init__()
            self.stops = [stop.to(""cuda"") for stop in stops]

        def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor):
            for stop in self.stops:
                last_token = input_ids[0][-len(stop):]
                if torch.all(torch.eq(stop,last_token)):
                    return True
            return False


    stop_words = [""```output"", ""```python"", ""```\nOutput"" , "")\n```"" , ""``````output""] #,  
    stop_words_ids = [tokenizer(stop_word, return_tensors='pt', add_special_tokens=False)['input_ids'].squeeze() for stop_word in stop_words]
    stopping_criteria = StoppingCriteriaList([StoppingCriteriaSub(stops=stop_words_ids)])
    
    model.dtype, model.hf_device_map
code = """"""Below is a math problem you are to solve (positive numerical answer):
\""{}\""
To accomplish this, first determine a sympy-based approach for solving the problem by listing each step to take and what functions need to be called in each step. Be clear so even an idiot can follow your instructions, and remember, your final answer should be positive integer, not an algebraic expression!
Write the entire script covering all the steps (use comments and document it well) and print the result. After solving the problem, output the final numerical answer within \\boxed{}.

Approach:""""""


cot = """"""Below is a math problem you are to solve (positive numerical answer!):
\""{}\""
Analyze this problem and think step by step to come to a solution with programs. After solving the problem, output the final numerical answer within \\boxed{}.\n\n""""""

promplt_options = [code,cot]
import re
from collections import defaultdict
from collections import Counter

from numpy.random import choice
import numpy as np

tool_instruction = '\n\nPlease integrate natural language reasoning with programs to solve the above problem, and put your final numerical answer within \\boxed{}.\nNote that the intermediary calculations may be real numbers, but the final numercal answer would always be an integer.'


#tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
#tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'

temperature = 0.9
top_p = 1.0

temperature_coding = 0.9
top_p_coding = 1.0

   
total_results = {}
total_answers = {}
best_stats = {}
total_outputs = {}
question_type_counts = {}
starting_counts = (2,3)
    
# LEWIS: I had to invert the loop order because the new API forbids repeated calls on the same problem
for i, (test, sample_submission) in tqdm(enumerate(iter_test)):
    print(f""Solving problem {i} ..."")
    TIME_SPENT = time.time() - NOTEBOOK_START_TIME

    if TIME_SPENT>TIME_LIMIT:
        break
        
    for jj in tqdm(range(n_repetitions)):   
#     for i, (test, sample_submission) in tqdm(enumerate(iter_test)):
        

#         id_ = df['id'].loc[i]
#         problem = df['problem'].loc[i]
        problem = test['problem'].values[0]
        print(f""\n\n\nQUESTION {i} - {jj} - TIME_SPENT : {TIME_SPENT:.0f} secs"")
        
        best, best_count = best_stats.get(i,(-1,-1))
        if best_count>np.sqrt(jj):
            print(""SKIPPING CAUSE ALREADY FOUND BEST"")
            continue
            
        outputs = total_outputs.get(i,[])
        text_answers, code_answers = question_type_counts.get(i,starting_counts)
        results = total_results.get(i,[])
        answers = total_answers.get(i,[])
        
        for _ in range(5):
            torch.cuda.empty_cache()
            gc.collect()
            time.sleep(0.2)

        try:
            ALREADY_GEN = 0
            code_error = None
            code_error_count = 0
            code_output = -1
            #initail_message = problem  + tool_instruction 
            counts = np.array([text_answers,code_answers])

            draw = choice(promplt_options, 1,
                          p=counts/counts.sum())

            initail_message = draw[0].format(problem,""{}"")            
            prompt = f""User: {initail_message}""

            current_printed = len(prompt)
            print(f""{jj}_{prompt}\n"")

            model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
            input_len = len(model_inputs['input_ids'][0])

            generation_output = model.generate(**model_inputs, 
                                               max_new_tokens=TOTAL_TOKENS-ALREADY_GEN,
                                               return_dict_in_generate=USE_PAST_KEY,
                                               do_sample = True,
                                               temperature = temperature,
                                               top_p = top_p,
                                               num_return_sequences=1, stopping_criteria = stopping_criteria)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]
            decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
            print(f""{decoded_output[current_printed:]}\n"")
            current_printed += len(decoded_output[current_printed:])
            cummulative_code = """"
            
            
            stop_word_cond = False
            for stop_word in stop_words:
                stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)
                
            
            while (stop_word_cond) and (ALREADY_GEN<(TOTAL_TOKENS)):

                if (decoded_output[-len(""```python""):]==""```python""):
                    temperature_inner=temperature_coding
                    top_p_inner = top_p_coding
                    prompt = decoded_output
                else:
                    temperature_inner=temperature
                    top_p_inner = top_p
                    try:
                        if (decoded_output[-len(""``````output""):]==""``````output""):
                            code_text = decoded_output.split('```python')[-1].split(""``````"")[0]
                        else:
                            code_text = decoded_output.split('```python')[-1].split(""```"")[0]
                        

                        cummulative_code+=code_text
                        code_output, CODE_STATUS = process_code(cummulative_code, return_shell_output=True)
                        print('CODE RESULTS', code_output)

                        if code_error==code_output:
                            code_error_count+=1
                        else:
                            code_error=code_output
                            code_error_count = 0

                        if not CODE_STATUS:
                            cummulative_code = cummulative_code[:-len(code_text)]

                            if code_error_count>=1:
                                print(""REPEATED ERRORS"")
                                break

                    except Exception as e:
                        print(e)
                        print('ERROR PARSING CODE')
                        code_output = -1

                    if code_output!=-1:
                        if (decoded_output[-len("")\n```""):]=="")\n```""):
                            prompt = decoded_output+'```output\n'+str(code_output)+'\n```\n'
                        else:
                            prompt = decoded_output+'\n'+str(code_output)+'\n```\n'
                    else:
                        prompt = decoded_output
                        cummulative_code=""""


                model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
                ALREADY_GEN =  len(model_inputs['input_ids'][0])-input_len

                if USE_PAST_KEY:
                    old_values = generation_output.past_key_values
                else:
                    old_values = None

                generation_output = model.generate(**model_inputs, 
                                                   max_new_tokens=TOTAL_TOKENS-ALREADY_GEN, 
                                                   return_dict_in_generate=USE_PAST_KEY,
                                                   past_key_values=old_values,
                                                   do_sample = True,
                                                   temperature = temperature_inner,
                                                   top_p = top_p_inner,
                                                   num_return_sequences=1, stopping_criteria = stopping_criteria)

                if USE_PAST_KEY:
                    output_ids = generation_output.sequences[0]
                else:
                    output_ids = generation_output[0]
                decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
                print(f""\nINTERMEDIATE OUT :\n{decoded_output[current_printed:]}\n"")
                current_printed+=len(decoded_output[current_printed:])
                
                stop_word_cond = False
                for stop_word in stop_words:
                    stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]

            raw_output = tokenizer.decode(output_ids[input_len:], skip_special_tokens=True)
            #print(f""\n\nOutput :\n{raw_output}\n"")                            
            result_output = process_text_output(raw_output)
            
            try:
                code_output = round(float(eval(code_output))) % 1000
            except Exception as e:
                print(e,'final_eval')
                code_output = -1

        except Exception as e:
            print(e,""5"")
            result_output, code_output = -1, -1

        if code_output!=-1:
            outputs.append(code_output)
            code_answers+=1

        if result_output!=-1:
            outputs.append(result_output)
            text_answers+=1

        if len(outputs) > 0:
            occurances = Counter(outputs).most_common()
            print(occurances)
            if occurances[0][1] > best_count:
                print(""GOOD ANSWER UPDATED!"")
                best = occurances[0][0]
                best_count = occurances[0][1]
            if occurances[0][1] > 5:
                print(""ANSWER FOUND!"")
                break

        results.append(result_output)
        answers.append(code_output)
        
        best_stats[i] = (best, best_count) 
        question_type_counts[i] = (text_answers, code_answers)
        total_outputs[i] = outputs
        
        total_results[i] = results
        total_answers[i] = answers

        print(""code_answers"",code_answers-starting_counts[1],""text_answers"",text_answers-starting_counts[0])
        if DEBUG:
            break
            
    print(f""Predicted best answer: {best_stats}"")
    sample_submission['answer'] = best_stats[i][0]
    env.predict(sample_submission)
# import numpy as np
# if PRIVATE:
#     for ii in range(len(df)):
#         a = total_answers[ii]
#         b = total_answers[ii]
#         a = np.array(a)
#         b = np.array(b)
#         print(a,b)
#         a[a < 0] = b[a < 0]

#         pred = Counter(a.tolist()).most_common(2)
#         print(pred)
# if PRIVATE:
#     df['answer'] = [best_stats[ii][0] for ii in range(len(df))]
# else:
#     df['answer'] = 2
# df[['id','answer']].to_csv(""foo.csv"", header=True, index=False)
# if not PRIVATE:
#     df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
#     if PRIVATE:
#         df['model_answer'] = [best_stats[ii][0] for ii in range(len(df))]
#         df['match'] = df.answer == df.model_answer
#         print(f'{df.match.sum()} matches in {len(df)} examples')
with open('code.py', 'w') as fout:
    fout.write(""print('done')"")

batcmd = 'timeout 7 ' + sys.executable + ' code.py'
try:
    shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
    print(shell_output)
except:
    pass

","## Forked From  https://kaggle.com/code/xiaoz259/pure-rng/notebook


# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
import time

NOTEBOOK_START_TIME = time.time()
import aimo

env = aimo.make_env()
iter_test = env.iter_test()
DEBUG = False

QUANT = False

if QUANT:
    from transformers import BitsAndBytesConfig
    quantization_config = BitsAndBytesConfig(
        load_in_4bit = True,
        bnb_4bit_quant_type=""nf4"",
        bnb_4bit_compute_dtype=torch.bfloat16,
        bnb_4bit_use_double_quant=True,
    )

USE_PAST_KEY = True
%%time
if QUANT:
    !pip install -U /kaggle/input/accelerate-wheelwhl/accelerate-0.29.1-py3-none-any.whl -qq
    !pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq


import torch
import gc
torch.backends.cuda.enable_mem_efficient_sdp(False)

from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    AutoConfig,
    StoppingCriteria,
    set_seed
)

import transformers
print(f""Transformers Version: {transformers.__version__}"")
set_seed(42)
import pandas as pd
from tqdm import tqdm
PRIVATE = True

# df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
# df.head()
# if len(df) < 5:
#     df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
#     PRIVATE = False
# df.head()
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import re
import sys
import subprocess

def return_last_print(output, n):
    lines = output.strip().split('\n')
    if lines:
        return lines[n]
    else:
        return """"

def process_code(code, return_shell_output=False):
    
    def repl(match):
        if ""real"" not in match.group():
            return ""{}{}"".format(match.group()[:-1], ', real=True)')
        else:
            return ""{}{}"".format(match.group()[:-1], ')')
    code = re.sub(r""symbols\([^)]+\)"", repl, code)

    if return_shell_output:
        code = code.replace('\n', '\n    ')
            # Add a try...except block
        code = ""\ntry:\n    from sympy import *\n{}\nexcept Exception as e:\n    print(e)\n    print('FAIL')\n"".format(code)
    
    if not return_shell_output:
        print(code)
    with open('code.py', 'w') as fout:
        fout.write(code)
    
    batcmd = 'timeout 7 ' + sys.executable + ' code.py'
    try:
        shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
        return_value = return_last_print(shell_output, -1)
        print(shell_output)
        if return_shell_output:
            if return_value=='FAIL':
                CODE_STATUS = False
                return_value = return_last_print(shell_output, -2)
                if ""not defined"" in return_value:
                    return_value+='\nTry checking the formatting and imports'
            else:
                CODE_STATUS = True
            return return_value, CODE_STATUS  
        code_output = round(float(eval(return_value))) % 1000
    except Exception as e:
        print(e,'shell_output')
        code_output = -1
    
    if return_shell_output:
        if code_output==-1:
            CODE_STATUS = False
        else:
            CODE_STATUS = True
        return code_output, CODE_STATUS  
    
    
    return code_output


def process_text_output(output):
    result = output    
    try:
        result_output = re.findall(r'\\boxed\{(\d+)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED FINAL', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING TEXT')
        result_output = -1
    
    return result_output

torch.cuda.empty_cache()
gc.collect()
import re
import math
import random

from collections import defaultdict

n_repetitions = 19 if PRIVATE else 4 # Original notebook had 22 but times out :(
TOTAL_TOKENS = 2048 # if PRIVATE else 512

if PRIVATE:
    TIME_LIMIT = 31500
else:
    TIME_LIMIT = 1
if PRIVATE:

    MODEL_PATH = ""/kaggle/input/deepseek-math""#""/kaggle/input/gemma/transformers/7b-it/1""
    DEEP = True

    config = AutoConfig.from_pretrained(MODEL_PATH)
    config.gradient_checkpointing = True

    tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

    device_map = [('model.embed_tokens', 0),
                 ('model.layers.0', 0),
                 ('model.layers.1', 0),
                 ('model.layers.2', 0),
                 ('model.layers.3', 0),
                 ('model.layers.4', 0),
                 ('model.layers.5', 0),
                 ('model.layers.6', 0),
                 ('model.layers.7', 0),
                 ('model.layers.8', 0),
                 ('model.layers.9', 0),
                 ('model.layers.10', 0),
                 ('model.layers.11', 0),
                 ('model.layers.12', 0),
                 ('model.layers.13', 0),
                 ('model.layers.14', 0),
                 ('model.layers.15', 0),
                 ('model.layers.16', 0),
                 ('model.layers.17', 0),
                 ('model.layers.18', 0),
                 ('model.layers.19', 0),
                 ('model.layers.20', 0),
                 ('model.layers.21', 0),
                 ('model.layers.22', 1),
                 ('model.layers.23', 1),
                 ('model.layers.24', 1),
                 ('model.layers.25', 1),
                 ('model.layers.26', 1),
                 ('model.layers.27', 1),
                 ('model.layers.28', 1),
                 ('model.layers.29', 1),
                 ('model.norm', 1),
                 ('lm_head', 1)]

    device_map = {ii:jj for (ii,jj) in device_map}

    if QUANT:
        from transformers import BitsAndBytesConfig
        quantization_config = BitsAndBytesConfig(
            load_in_4bit = True,
            bnb_4bit_quant_type=""nf4"",
            bnb_4bit_compute_dtype=torch.bfloat16,
            bnb_4bit_use_double_quant=True,
        )
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=""sequential"",
            torch_dtype=""auto"",
            trust_remote_code=True, 
            quantization_config=quantization_config,
            config=config
        )
    else:  
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_PATH,
            device_map=device_map,
            torch_dtype=""auto"",
            trust_remote_code=True,
            #quantization_config=quantization_config,
            config=config
        )
    
    pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=device_map,
)
    from transformers import StoppingCriteriaList

    class StoppingCriteriaSub(StoppingCriteria):
        def __init__(self, stops = [], encounters=1):
            super().__init__()
            self.stops = [stop.to(""cuda"") for stop in stops]

        def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor):
            for stop in self.stops:
                last_token = input_ids[0][-len(stop):]
                if torch.all(torch.eq(stop,last_token)):
                    return True
            return False


    stop_words = [""```output"", ""```python"", ""```\nOutput"" , "")\n```"" , ""``````output""] #,  
    stop_words_ids = [tokenizer(stop_word, return_tensors='pt', add_special_tokens=False)['input_ids'].squeeze() for stop_word in stop_words]
    stopping_criteria = StoppingCriteriaList([StoppingCriteriaSub(stops=stop_words_ids)])
    
    model.dtype, model.hf_device_map
code = """"""Below is a math problem you are to solve (positive numerical answer):
\""{}\""
To accomplish this, first determine a sympy-based approach for solving the problem by listing each step to take and what functions need to be called in each step. Be clear so even an idiot can follow your instructions, and remember, your final answer should be positive integer, not an algebraic expression!
Write the entire script covering all the steps (use comments and document it well) and print the result. After solving the problem, output the final numerical answer within \\boxed{}.

Approach:""""""


cot = """"""Below is a math problem you are to solve (positive numerical answer!):
\""{}\""
Analyze this problem and think step by step to come to a solution with programs. After solving the problem, output the final numerical answer within \\boxed{}.\n\n""""""

promplt_options = [code,cot]
import re
from collections import defaultdict
from collections import Counter

from numpy.random import choice
import numpy as np

tool_instruction = '\n\nPlease integrate natural language reasoning with programs to solve the above problem, and put your final numerical answer within \\boxed{}.\nNote that the intermediary calculations may be real numbers, but the final numercal answer would always be an integer.'


#tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
#tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'

temperature = 0.9
top_p = 1.0

temperature_coding = 0.9
top_p_coding = 1.0

   
total_results = {}
total_answers = {}
best_stats = {}
total_outputs = {}
question_type_counts = {}
starting_counts = (2,3)
    
# LEWIS: I had to invert the loop order because the new API forbids repeated calls on the same problem
for i, (test, sample_submission) in tqdm(enumerate(iter_test)):
    print(f""Solving problem {i} ..."")
    TIME_SPENT = time.time() - NOTEBOOK_START_TIME

    if TIME_SPENT>TIME_LIMIT:
        break
        
    for jj in tqdm(range(n_repetitions)):   
#     for i, (test, sample_submission) in tqdm(enumerate(iter_test)):
        

#         id_ = df['id'].loc[i]
#         problem = df['problem'].loc[i]
        problem = test['problem'].values[0]
        print(f""\n\n\nQUESTION {i} - {jj} - TIME_SPENT : {TIME_SPENT:.0f} secs"")
        
        best, best_count = best_stats.get(i,(-1,-1))
        if best_count>np.sqrt(jj):
            print(""SKIPPING CAUSE ALREADY FOUND BEST"")
            continue
            
        outputs = total_outputs.get(i,[])
        text_answers, code_answers = question_type_counts.get(i,starting_counts)
        results = total_results.get(i,[])
        answers = total_answers.get(i,[])
        
        for _ in range(5):
            torch.cuda.empty_cache()
            gc.collect()
            time.sleep(0.2)

        try:
            ALREADY_GEN = 0
            code_error = None
            code_error_count = 0
            code_output = -1
            #initail_message = problem  + tool_instruction 
            counts = np.array([text_answers,code_answers])

            draw = choice(promplt_options, 1,
                          p=counts/counts.sum())

            initail_message = draw[0].format(problem,""{}"")            
            prompt = f""User: {initail_message}""

            current_printed = len(prompt)
            print(f""{jj}_{prompt}\n"")

            model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
            input_len = len(model_inputs['input_ids'][0])

            generation_output = model.generate(**model_inputs, 
                                               max_new_tokens=TOTAL_TOKENS-ALREADY_GEN,
                                               return_dict_in_generate=USE_PAST_KEY,
                                               do_sample = True,
                                               temperature = temperature,
                                               top_p = top_p,
                                               num_return_sequences=1, stopping_criteria = stopping_criteria)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]
            decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
            print(f""{decoded_output[current_printed:]}\n"")
            current_printed += len(decoded_output[current_printed:])
            cummulative_code = """"
            
            
            stop_word_cond = False
            for stop_word in stop_words:
                stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)
                
            
            while (stop_word_cond) and (ALREADY_GEN<(TOTAL_TOKENS)):

                if (decoded_output[-len(""```python""):]==""```python""):
                    temperature_inner=temperature_coding
                    top_p_inner = top_p_coding
                    prompt = decoded_output
                else:
                    temperature_inner=temperature
                    top_p_inner = top_p
                    try:
                        if (decoded_output[-len(""``````output""):]==""``````output""):
                            code_text = decoded_output.split('```python')[-1].split(""``````"")[0]
                        else:
                            code_text = decoded_output.split('```python')[-1].split(""```"")[0]
                        

                        cummulative_code+=code_text
                        code_output, CODE_STATUS = process_code(cummulative_code, return_shell_output=True)
                        print('CODE RESULTS', code_output)

                        if code_error==code_output:
                            code_error_count+=1
                        else:
                            code_error=code_output
                            code_error_count = 0

                        if not CODE_STATUS:
                            cummulative_code = cummulative_code[:-len(code_text)]

                            if code_error_count>=1:
                                print(""REPEATED ERRORS"")
                                break

                    except Exception as e:
                        print(e)
                        print('ERROR PARSING CODE')
                        code_output = -1

                    if code_output!=-1:
                        if (decoded_output[-len("")\n```""):]=="")\n```""):
                            prompt = decoded_output+'```output\n'+str(code_output)+'\n```\n'
                        else:
                            prompt = decoded_output+'\n'+str(code_output)+'\n```\n'
                    else:
                        prompt = decoded_output
                        cummulative_code=""""


                model_inputs = tokenizer(prompt, return_tensors='pt').to(model.device)
                ALREADY_GEN =  len(model_inputs['input_ids'][0])-input_len

                if USE_PAST_KEY:
                    old_values = generation_output.past_key_values
                else:
                    old_values = None

                generation_output = model.generate(**model_inputs, 
                                                   max_new_tokens=TOTAL_TOKENS-ALREADY_GEN, 
                                                   return_dict_in_generate=USE_PAST_KEY,
                                                   past_key_values=old_values,
                                                   do_sample = True,
                                                   temperature = temperature_inner,
                                                   top_p = top_p_inner,
                                                   num_return_sequences=1, stopping_criteria = stopping_criteria)

                if USE_PAST_KEY:
                    output_ids = generation_output.sequences[0]
                else:
                    output_ids = generation_output[0]
                decoded_output = tokenizer.decode(output_ids, skip_special_tokens=True)
                print(f""\nINTERMEDIATE OUT :\n{decoded_output[current_printed:]}\n"")
                current_printed+=len(decoded_output[current_printed:])
                
                stop_word_cond = False
                for stop_word in stop_words:
                    stop_word_cond = stop_word_cond or (decoded_output[-len(stop_word):]==stop_word)

            if USE_PAST_KEY:
                output_ids = generation_output.sequences[0]
            else:
                output_ids = generation_output[0]

            raw_output = tokenizer.decode(output_ids[input_len:], skip_special_tokens=True)
            #print(f""\n\nOutput :\n{raw_output}\n"")                            
            result_output = process_text_output(raw_output)
            
            try:
                code_output = round(float(eval(code_output))) % 1000
            except Exception as e:
                print(e,'final_eval')
                code_output = -1

        except Exception as e:
            print(e,""5"")
            result_output, code_output = -1, -1

        if code_output!=-1:
            outputs.append(code_output)
            code_answers+=1

        if result_output!=-1:
            outputs.append(result_output)
            text_answers+=1

        if len(outputs) > 0:
            occurances = Counter(outputs).most_common()
            print(occurances)
            if occurances[0][1] > best_count:
                print(""GOOD ANSWER UPDATED!"")
                best = occurances[0][0]
                best_count = occurances[0][1]
            if occurances[0][1] > 5:
                print(""ANSWER FOUND!"")
                break

        results.append(result_output)
        answers.append(code_output)
        
        best_stats[i] = (best, best_count) 
        question_type_counts[i] = (text_answers, code_answers)
        total_outputs[i] = outputs
        
        total_results[i] = results
        total_answers[i] = answers

        print(""code_answers"",code_answers-starting_counts[1],""text_answers"",text_answers-starting_counts[0])
        if DEBUG:
            break
            
    print(f""Predicted best answer: {best_stats}"")
    sample_submission['answer'] = best_stats[i][0]
    env.predict(sample_submission)
# import numpy as np
# if PRIVATE:
#     for ii in range(len(df)):
#         a = total_answers[ii]
#         b = total_answers[ii]
#         a = np.array(a)
#         b = np.array(b)
#         print(a,b)
#         a[a < 0] = b[a < 0]

#         pred = Counter(a.tolist()).most_common(2)
#         print(pred)
# if PRIVATE:
#     df['answer'] = [best_stats[ii][0] for ii in range(len(df))]
# else:
#     df['answer'] = 2
# df[['id','answer']].to_csv(""foo.csv"", header=True, index=False)
# if not PRIVATE:
#     df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
#     if PRIVATE:
#         df['model_answer'] = [best_stats[ii][0] for ii in range(len(df))]
#         df['match'] = df.answer == df.model_answer
#         print(f'{df.match.sum()} matches in {len(df)} examples')
with open('code.py', 'w') as fout:
    fout.write(""print('done')"")

batcmd = 'timeout 7 ' + sys.executable + ' code.py'
try:
    shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
    print(shell_output)
except:
    pass

","## Forked from https://www.kaggle.com/code/abdurrafae/improved-code-interpretation
**Lewis:** the only changes in this notebook are those needed to run the original one with the new Kaggle evaluation API
TO-DO

Change temperature as the question goes longer
Change temperature based on question lenght
# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
","['AI Mathematical Olympiad - Progress Prize 1', 'accelerate wheel/whl', 'bitsandbytes-0.42.0-py3-none-any.whl', 'deepseek-math', 'open-math-mistral']","['time', 'aimo', 'torch', 'gc', 'transformers', 'pandas', 'tqdm', 're', 'sys', 'subprocess', 'math', 'random', 'collections', 'numpy.random', 'numpy']","Here's a summary of the unique aspects of the Machine Learning code written in Python:

**Code Generation**

The code uses a transformer-based model to generate code snippets. The input prompt is processed using a tokenizer, and the generated output is decoded back into text.

**Prompt Processing**

The code takes a prompt as input, which is then processed by the tokenizer to create an encoding that can be fed into the model. The prompt is used to condition the generated code output.

**Code Evaluation**

The generated code snippets are evaluated using the `eval` function, and the result is rounded to the nearest thousand. This suggests that the goal of the code generation task is to generate code that produces a specific numerical value or range of values.

**Stop Word Detection**

The code includes a stop word detection mechanism, which checks if the generated code output contains any stop words (e.g., ""print"", ""exit"", etc.). If a stop word is detected, the code generation process is terminated.

**Code Output Processing**

The generated code snippets are processed using a custom `process_text_output` function to extract relevant information or perform additional processing on the output.

**Answer Tracking**

The code keeps track of the best answer (i.e., the generated code snippet that produces the most common result) and updates it accordingly. This suggests that the goal is to generate code that produces a specific pattern or distribution of results.

**Private Mode**

The code includes a private mode, which is used to process the output in a special way (e.g., converting code outputs to arrays using NumPy). This suggests that there are additional processing steps required for certain inputs or outputs.

Overall, this code appears to be a complex system for generating and evaluating code snippets based on input prompts."
Deepseek Math,https://www.kaggle.com/code/jazivxt/deepseek-math,11.0,,gold,83,8470,234.6s - GPU P100,1 month,"import numpy as np
import pandas as pd
from collections import Counter
import re, sys, subprocess, gc, random
import torch, transformers
from transformers import AutoModelForCausalLM, AutoTokenizer, AutoConfig, set_seed
from accelerate import infer_auto_device_map as iadm

set_seed(199)
p = ""/kaggle/input/deepseek-math""
config = AutoConfig.from_pretrained(p)
config.gradient_checkpointing = True
tokenizer = AutoTokenizer.from_pretrained(p)
model = AutoModelForCausalLM.from_pretrained(p, device_map=""auto"", torch_dtype=""auto"", trust_remote_code=True, config=config)
#device_map = iadm(model, max_memory={0: ""15GiB"", 1: ""15GiB"", ""cpu"": ""25GiB""})
df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
#df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')

pipeline = transformers.pipeline(""text-generation"", model=model, tokenizer=tokenizer, torch_dtype='auto', device_map=""auto"")
torch.backends.cuda.enable_mem_efficient_sdp(False)
# LaTeX Conversion Options
* https://www.kaggle.com/code/sunnymarkliu/more-text-cleaning-to-increase-word-coverage/notebook
* https://www.kaggle.com/code/sulphatet/data-cleaning-latex-to-text
precode = """"""from scipy import *
import signal, math, scipy
def handler(signum, frame): raise Exception('Timeout Error')
signal.signal(signal.SIGALRM, handler)
signal.alarm(10)\n""""""
def process_output(output):
    global precode
    result = output
    try:
        code = output.split('```')[1][7:]
        with open('code.py', 'w') as fout:
            fout.write(precode)
            fout.write(code)
        batcmd = 'timeout 7 ' + sys.executable + ' code.py'
        try:
            shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
            code_output = round(float(eval(shell_output))) % 1000
        except:
            code_output = -1; pass
    except Exception as e:
        code_output = -1; pass
    return -1, code_output
tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'
n_reps = 2
if len(df)>3: n_reps = 12
total_results, total_answers = [[],[]]
for i in range(len(df)):
    id_ = df['id'].loc[i]
    problem = df['problem'].loc[i] 
    results, answers = [[],[]]
    messages = [{""role"": ""user"", ""content"": problem + tool_instruction }] 
    query_prompt = tokenizer.apply_chat_template(messages, tokenize=False)
    for j in range(n_reps):
        try:
            raw_output = pipeline(query_prompt, max_new_tokens=2048, do_sample=True, temperature=0.9, return_full_text=False)
            raw_output = raw_output[0]['generated_text']
            result_output, code_output = process_output(raw_output)
            torch.cuda.empty_cache()
            gc.collect()
        except Exception as e:
            result_output, code_output = -1, -1
        results.append(result_output)
        answers.append(code_output)
    total_results.append(results)
    total_answers.append(answers)
final_answers = []
random.seed(199)
for a, b in zip(total_answers, total_results):
    a = np.array(a)
    b = np.array(b)
    a[a < 0] = b[a < 0]
    pred = Counter(a.tolist()).most_common(2)
    ans = pred[0][0] if not pred[0][0] < 0 else pred[0][1]
    while ans > 999: ans = ans % 1000
    if ans == -1: ans = random.choice(range(1,1000))
    final_answers.append(ans)
df['answer'] = final_answers
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
# Credits
* https://www.kaggle.com/code/olyatsimboy/aimo-zero-shot-sc-mmos-deepseekmath
*  https://www.kaggle.com/code/quan0095/more-diversity-in-output-improve-score
* https://www.kaggle.com/competitions/ai-mathematical-olympiad-prize/discussion/492578
# Planned Updates
* Include additional datasets for testing
* Add a lightweight LLM (<2.5BP) for classifying math problems
* Based on classification and parsing apply different reasoning/logic approaches for solving
# Ｈ𝐀𝑷𝑷𝓎 🇰𝗮𝘨𝘨🇱𝖎Ｎɢ 💯
","import numpy as np
import pandas as pd
from collections import Counter
import re, sys, subprocess, gc, random
import torch, transformers
from transformers import AutoModelForCausalLM, AutoTokenizer, AutoConfig, set_seed
from accelerate import infer_auto_device_map as iadm

set_seed(199)
p = ""/kaggle/input/deepseek-math""
config = AutoConfig.from_pretrained(p)
config.gradient_checkpointing = True
tokenizer = AutoTokenizer.from_pretrained(p)
model = AutoModelForCausalLM.from_pretrained(p, device_map=""auto"", torch_dtype=""auto"", trust_remote_code=True, config=config)
#device_map = iadm(model, max_memory={0: ""15GiB"", 1: ""15GiB"", ""cpu"": ""25GiB""})
df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
#df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')

pipeline = transformers.pipeline(""text-generation"", model=model, tokenizer=tokenizer, torch_dtype='auto', device_map=""auto"")
torch.backends.cuda.enable_mem_efficient_sdp(False)
precode = """"""from scipy import *
import signal, math, scipy
def handler(signum, frame): raise Exception('Timeout Error')
signal.signal(signal.SIGALRM, handler)
signal.alarm(10)\n""""""
def process_output(output):
    global precode
    result = output
    try:
        code = output.split('```')[1][7:]
        with open('code.py', 'w') as fout:
            fout.write(precode)
            fout.write(code)
        batcmd = 'timeout 7 ' + sys.executable + ' code.py'
        try:
            shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
            code_output = round(float(eval(shell_output))) % 1000
        except:
            code_output = -1; pass
    except Exception as e:
        code_output = -1; pass
    return -1, code_output
tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'
n_reps = 2
if len(df)>3: n_reps = 12
total_results, total_answers = [[],[]]
for i in range(len(df)):
    id_ = df['id'].loc[i]
    problem = df['problem'].loc[i] 
    results, answers = [[],[]]
    messages = [{""role"": ""user"", ""content"": problem + tool_instruction }] 
    query_prompt = tokenizer.apply_chat_template(messages, tokenize=False)
    for j in range(n_reps):
        try:
            raw_output = pipeline(query_prompt, max_new_tokens=2048, do_sample=True, temperature=0.9, return_full_text=False)
            raw_output = raw_output[0]['generated_text']
            result_output, code_output = process_output(raw_output)
            torch.cuda.empty_cache()
            gc.collect()
        except Exception as e:
            result_output, code_output = -1, -1
        results.append(result_output)
        answers.append(code_output)
    total_results.append(results)
    total_answers.append(answers)
final_answers = []
random.seed(199)
for a, b in zip(total_answers, total_results):
    a = np.array(a)
    b = np.array(b)
    a[a < 0] = b[a < 0]
    pred = Counter(a.tolist()).most_common(2)
    ans = pred[0][0] if not pred[0][0] < 0 else pred[0][1]
    while ans > 999: ans = ans % 1000
    if ans == -1: ans = random.choice(range(1,1000))
    final_answers.append(ans)
df['answer'] = final_answers
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
","# LaTeX Conversion Options
* https://www.kaggle.com/code/sunnymarkliu/more-text-cleaning-to-increase-word-coverage/notebook
* https://www.kaggle.com/code/sulphatet/data-cleaning-latex-to-text
# Credits
* https://www.kaggle.com/code/olyatsimboy/aimo-zero-shot-sc-mmos-deepseekmath
*  https://www.kaggle.com/code/quan0095/more-diversity-in-output-improve-score
* https://www.kaggle.com/competitions/ai-mathematical-olympiad-prize/discussion/492578
# Planned Updates
* Include additional datasets for testing
* Add a lightweight LLM (<2.5BP) for classifying math problems
* Based on classification and parsing apply different reasoning/logic approaches for solving
# Ｈ𝐀𝑷𝑷𝓎 🇰𝗮𝘨𝘨🇱𝖎Ｎɢ 💯
","['AI Mathematical Olympiad - Progress Prize 1', 'deepseek-math']","['numpy', 'pandas', 'collections', 're,', 'torch,', 'transformers', 'accelerate', 'signal,']","Unique aspects:
1. The code utilizes MMOS-DeepSeekMath, a zero-shot machine learning model for mathematical reasoning.
2. The integration of self-consistency and generated code reasoning evaluation to improve arithmetic hallucinations.

Steps taken:
1. Import necessary libraries, including PyTorch and transformers.
2. Define the problem-solving function using the MMOS-DeepSeekMath model.
3. Generate prompts for the model using a chat template.
4. Process the output by splitting it into code and result sections.
5. Run the generated code using the `subprocess` module to obtain the final answer.

Note: The code appears to be part of a competition submission for the AI Mathematical Olympiad Prize, which is why there are credits and planned updates listed at the end."
Let's Learn Together - DeepMind's AlphaGeometry,https://www.kaggle.com/code/dschettler8845/let-s-learn-together-deepmind-s-alphageometry,,,gold,76,1610,6.2s,1 month,"# Run this to enable CSS types
from IPython.core.display import HTML
def css_styling():
    styles = open(""/kaggle/input/my-css-styles/kaggle_styles.css"", ""r"").read()
    return HTML(""<style>""+styles+""</style>"")
css_styling()
<br>

<center><img src=""https://lh3.googleusercontent.com/tVTh_ZCW5Qozy4vOCpMH06B7Ac_eF7fmEULMMTwDellOh6hnOMUtf28toD68N527IHQTlBWfBCHcZykYPMdrS48yvuEcJKMJG8rU3YRM3u5Ojn3JXnc=w2144-h1206-n-nu-rw"" width=100% style=""padding: 0 0 !important; margin: 0 0 !important;""></center>

<br style=""margin: 15px;"">

<h2 style=""text-align: center; font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">
    <span style=""text-decoration: underline;"">
        <font color=#799cb7>L</font>ET'S 
        <font color=#799cb7>L</font>EARN 
        <font color=#799cb7>T</font>OGETHER !
    </span><br><br><br style=""margin: 15px;"">
<span style=""font-size: 18px; letter-spacing: 1px;"">
    <font color=#799cb7>U</font>NDERSTANDING    
    <font color=#799cb7>W</font>ITH
    <font color=#799cb7>O</font>UR
    <font color=#799cb7>O</font>WN
    <font color=#799cb7>I</font>MPLEMENTATION (!WIP!)
</span><br style=""margin: 15px;""></h2>

<p style=""text-align: center; font-family: Verdana; font-size: 12px; font-style: normal; font-weight: bold; text-decoration: None; text-transform: none; letter-spacing: 1px; color: black; background-color: #ffffff;"">CREATED BY: DARIEN SCHETTLER</p>

<br>

<center><div class=""alert alert-block alert-danger"" style=""margin: 2em; line-height: 1.7em; font-family: Verdana;"">
    <b style=""font-size: 18px;"">🛑 &nbsp; WARNING:</b><br><br><b>THIS IS A WORK IN PROGRESS</b><br>
</div></center>


<center><div class=""alert alert-block alert-warning"" style=""margin: 2em; line-height: 1.7em; font-family: Verdana;"">
    <b style=""font-size: 18px;"">👏 &nbsp; IF YOU FORK THIS OR FIND THIS HELPFUL &nbsp; 👏</b><br><br><b style=""font-size: 22px; color: darkorange"">PLEASE UPVOTE!</b><br><br>This was a lot of work for me and it makes me feel appreciated when others like my work. 😅
</div></center>



<p id=""toc""></p>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; color: #192a51; background-color: #ffffff;"">
    TABLE OF CONTENTS
</h1>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#introduction"" style=""text-decoration: none; color: #799cb7;"">1&nbsp;&nbsp;&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#background_information"" style=""text-decoration: none; color: #799cb7;"">2&nbsp;&nbsp;&nbsp;&nbsp;BACKGROUND INFORMATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#imports"" style=""text-decoration: none; color: #799cb7;"">3&nbsp;&nbsp;&nbsp;&nbsp;IMPORTS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#geometry"" style=""text-decoration: none; color: #799cb7;"">4&nbsp;&nbsp;&nbsp;&nbsp;GEOMETRY</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#problem"" style=""text-decoration: none; color: #799cb7;"">5&nbsp;&nbsp;&nbsp;&nbsp;PROBLEM</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#ar"" style=""text-decoration: none; color: #799cb7;"">6&nbsp;&nbsp;&nbsp;&nbsp;ALGEBRAIC REASONING</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#ar"" style=""text-decoration: none; color: #799cb7;"">7&nbsp;&nbsp;&nbsp;&nbsp;GRAPH</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#ar"" style=""text-decoration: none; color: #799cb7;"">8&nbsp;&nbsp;&nbsp;&nbsp;DDAR</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#next_steps"" style=""text-decoration: none; color: #799cb7;"">9&nbsp;&nbsp;&nbsp;&nbsp;NEXT STEPS</a></h3>

<hr>

<br>
<br>

<a id=""introduction""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""introduction"">1&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>

<img src=""https://lh3.googleusercontent.com/y7r-p8VmkqSLE0ZcwidAO0osQ1Sz1y4FBhwQNkv7t1M5bajHTvCu1vTYxDmVJZ2WuknpHeQB2E6RkPUEu-fAVoAxgh8thMPR6bcK4NFyGFuQ4mo5=w1232-rw"" width=90%>

<br>

**Evan Chen** (a math coach and former Olympiad gold-medalist):
> ""AlphaGeometry's output is impressive because it's both verifiable and clean. 
>
> Past AI solutions to proof-based competition problems have sometimes been hit-or-miss (outputs are only correct sometimes and need human checks). AlphaGeometry doesn't have this weakness: its solutions have machine-verifiable structure. Yet despite this, its output is still human-readable. 
> 
> One could have imagined a computer program that solved geometry problems by brute-force coordinate systems: think pages and pages of tedious algebra calculation. AlphaGeometry is **not that**. It uses classical geometry rules with angles and similar triangles just as students do""

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.1 <b>WHAT</b> IS THIS?</h3>
<hr>

<ul>
    <li style=""font-family: Verdana;"">This notebook will follow the authors learning path and highlight relevant terms, information, and useful content about the competition.</li>
    <li>This notebook will conduct an <b>E</b>xploratory <b>D</b>ata <b>A</b>nalysis for the competition.</li>
    <li>This notebook will propose an open-source baseline solution.</li>
</ul>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.2 <b>WHY</b> IS THIS?</h3>
<hr>

<ul>
    <li>Writing and sharing my learning path and the resulting exploratory data analysis can help improve my own understanding of the competition and the data.</li>
    <li>Sharing my work may help others who are interested in the competition (or the data). This help may take the form of:
        <ul>
            <li>Better understanding the problem and potential common solutions (incl. my baseline).</li>
            <li>Better understanding of the provided dataset.</li>
            <li>Better understanding of the background information and research.</li>
            <li>Better ability to hypothesize new solutions.</li>
        </ul>
    </li>
    <li>Exploratory data analysis is a critical step in any data science project. Sharing my EDA might help others in the competition.</li>
    <li>Writing and sharing my work is often a fun and rewarding experience! It not only allows me to explore and try different techniques, ideas, and visualizations but also encourages and supports other learners and participants.</li>
</ul>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.3 <b>WHO</b> IS THIS FOR?</h3>
<hr>


<ul>
    <li>The primary purpose of this notebook is to educate <b>MYSELF</b>, however, my review/learning might be beneficial to others:
        <ul>
            <li>Other Kagglers (aka. current and future competition participants).</li>
            <li>Anyone interested in learning more about sign language recognition and its potential applications.</li>
            <li>Educators, students, or researchers who want to gain hands-on experience working with real-world data and building machine learning models and want to follow along with something relatively straightforward.</li>
            <li>Those who want to learn how to use specific tools (competition specific and data science) and libraries such as TensorFlow Lite, MediaPipe, pandas, numpy, etc.</li>
        </ul>
    </li>
</ul>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.4 <b>HOW</b> WILL THIS WORK?</h3>
<hr>


<p>I'm going to assemble some markdown cells (like this one) at the beginning of the notebook to go over some concepts/details/etc.</p>

<p>Following this, I will attempt to walk through the data and understand it better prior to composing a baseline solution.</p>

<br>
<br>

<a id=""background_information""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""background_information"">2&nbsp;&nbsp;BACKGROUND INFORMATION &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.1 <b>UNDERSTANDING</b> DEEPMIND'S <b>ALPHA</b>GEOMETRY</h3>
<hr>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Overview of <span style=""color: #77AAB0 !important;"">Alpha</span><span style=""color: #192a51 !important;"">Geometry</span></b>

**(1) Purpose and Achievement**: 
* AlphaGeometry is an AI system designed to solve complex geometry problems. 
* AlphaGeometry represents a significant advancement in AI's ability to perform mathematical reasoning.
* In tests, it solved 25 out of 30 Olympiad geometry problems within the time limits of the competition, <b><mark>nearly matching the performance of human gold medalists.</mark></b>

**(2) Comparison with Previous Systems**: 
* The previous state-of-the-art system, based on <b><a href=""https://en.wikipedia.org/wiki/Wu%27s_method_of_characteristic_set#:~:text=Wu's%20method%20uses%20polynomial%20division,another%20to%20give%20a%20remainder."">""Wu’s method""</a></b>, solved only 10 out of these 30 problems. 
* This shows a significant leap in capabilities with AlphaGeometry.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">How <span style=""color: #77AAB0 !important;"">Alpha</span><span style=""color: #192a51 !important;"">Geometry</span> Works</b>

**(1) The Neuro-Symbolic System**: 
* <u>Basic Definition</u>
    * It combines a neural language model with a symbolic deduction engine. 
    * The neural model provides quick, intuitive ideas, while the symbolic engine applies formal logic and rules to arrive at conclusions.
* <u>ELI5 - Neuro-Symbolic System</u>
    * Imagine you're trying to solve a complex puzzle, like a treasure hunt. You have two friends helping you: one is an imaginative storyteller (the neural language model), and the other is a meticulous detective (the symbolic deduction engine).
        * <b><span style=""color: #77AAB0 !important;"">Imaginative Storyteller (Neural Language Model)</span></b>:
            * This friend is great at coming up with creative ideas quickly. 
            * They suggest where the treasure might be hidden based on the stories and legends they know. 
            * They don't always stick to strict rules but provide you with lots of possible clues based on patterns they've seen in other treasure hunts.
        * <b><span style=""color: #192a51 !important;"">Meticulous Detective (Symbolic Deduction Engine)</span></b>:
            * Your other friend is very logical and methodical. 
            * They take each of the storyteller's ideas and meticulously analyze them, using a map and a set of rules about how treasure hunts usually work. 
            * They carefully check each idea to see if it follows the rules and makes sense in the context of this specific puzzle.
    * To successfully complete the treasure hunt we need <b>BOTH FRIENDS!</b>: 
        * the storyteller's creative ideas to know where to look 
        * and the detective's logical approach to figure out which of those ideas actually lead to the treasure. 
        * Together, they make a great team for solving complex puzzles.
    * This is similar to how a Neuro-Symbolic System works in AI: 
        * the neural part quickly generates a range of ideas or hypotheses, and the symbolic part rigorously evaluates these ideas to find the correct solution.<br>

**(2) The Problem-Solving Process**: 
* <u>Basic Definition</u>
    * For geometry problems, the system first uses symbolic deduction. 
    * If it gets stuck, the neural model suggests new geometric constructs (like points or lines), which then opens new paths for the symbolic engine to explore.
* <u>ELI5 - Neuro-Symbolic System</u>
    * Let's continue our treasure hunt analogy with our two friends — the <b><span style=""color: #77AAB0 !important;"">Imaginative Storyteller (Neural Language Model)</span></b> and the <b><span style=""color: #192a51 !important;"">Meticulous Detective (Symbolic Deduction Engine)</span></b>.
    * To find the treasure, the Detective (Symbolic Deduction Engine) takes the lead initially.
        * They have a map and a set of rules on how typical treasure hunts work. 
        * So, they start analyzing the clues you already have, following the paths on the map logically and methodically, applying these rules. 
        * They're trying to figure out where to go next based on the information at hand.
    * However, sometimes the detective comes to a dead-end (ohno)...
        * At a certain point, the detective hits a dead end. 
        * They've followed the rules and the map as far as they can, but they can't figure out where the treasure is. 
        * They need a new idea or a new place to look, something that's not already on the map or in the rules.
    * The Storyteller (Neural Language Model) Steps In (and Steps Up!):
        * This is where the storyteller comes in. 
        * By thinking outside the box, using their imagination and pattern recognition skills, they are able to suggest new possibilities: 
            * ""What if there’s a hidden path not marked on the map? What if the treasure is buried under that old tree that looks like the one in the legend?"" 
        * These are analagous to new geometric constructs in the context of the puzzle—ideas that aren't part of the original set of clues or map.
    * Annnd We're Back to the Detective:
        * With these new ideas from the storyteller, the detective now has new avenues to explore. 
        * They start applying their logical, rule-based approach to these fresh suggestions. 
        * For instance, they might start considering how a hidden path could connect known locations on the map or how the tree mentioned in the legend relates to known landmarks.
    * In this analogy, the storyteller's imaginative suggestions are like the neural model proposing new geometric constructs when faced with a challenging geometry problem.
        * These new constructs (like adding a new line or point in a geometric diagram) open up new possibilities that weren't apparent before. 
        * Then, the detective's logical approach is akin to the symbolic deduction engine taking these new constructs and rigorously working through them to find a solution to the problem. 
        * Together, they move past the dead-end and closer to finding the treasure, just as the Neuro-Symbolic System solves complex geometry problems.

**(3) Example(s) of Problem Solving**: 
<img src=""https://lh3.googleusercontent.com/CXoZ8QVYA7wKFPt3RurU7Z0SDyp32YQS9gJaEwE-U1AtjAQ-eXEaGxnOSTUH01oyN7YOxz-BILe390w2wHVEFF7XPmCOzqr0QMBroKc4J5kPFyqYVqU=w1232-rw"">
<br>
<img src=""https://lh3.googleusercontent.com/XEyvy2yOfpwazku1bh2mgN48QquA21bUXscAAYOSp34kN-qb1E6glno62gNSqSth921OVJ5nBBT8GNFiVg1nwv3U2jd3vo6YCFENsn3qBD9yQZsD=w1232-rw"">
<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Synthetic Data Generation</b>


**(1) The Training Data(set)**: 
* AlphaGeometry was trained on a massive dataset of <b><u>synthetic</u></b> geometry problems <b>(100 million unique examples).</b>
* This approach bypasses the limitations of relying on human-generated training data

**(2) Synethetic Data Generation Method**: 
* The system generated <b>a billion(!) random diagrams</b>... using these it 
    * Derived relationships
    * Found proofs
    * And identified which constructs were necessary for the respective proofs. 
* This process allowed the original examples to be distilled down to <b>100 million unique examples.</b>

**(3) Some Examples of the Generated Data**
<img src=""https://lh3.googleusercontent.com/I2xcIu8Js4iZP89NPUe2Cr_43To5aamQNzzXDsDD_PamVRJQFZQ7SUdu6zJVlXAJ2Gq6fnINeHzsQeY5ugdSFzdnAaSrIuYcLsgSfJLDjJalifcD=w1232-rw"">

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Evaluation and Applications</b>

**(1) Verification and Evaluation**: 
* The solutions provided by AlphaGeometry were verified by computer, compared with previous methods and human performance, and evaluated by a math expert(s) for correctness and readability.

**(2) Scope of Use**: 
* Currently, AlphaGeometry is specialized in geometry, <b>capable of solving about <mark>one-third of the problems</mark> in a typical International Mathematical Olympiad.</b>

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Broader Implications and Goals</b>

**(1) Mathematical Reasoning with AI**: 
* This development is part of a larger effort to enhance AI's capacity for mathematical reasoning and problem-solving.

**(2) Long-Term Goals**: 
* The ultimate aim is to create AI systems that can generalize across various mathematical fields and contribute to the advancement of human knowledge.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">My Takeaways</b>

**Technical Innovation**: 
* DeepMind continues to contribute exciting and groundbreaking advancements to the AI space in ways that no one else is doing.
    * By targeting real problems (Fusion, Protein Folding, Drug Discovery, Math/Algorithms, etc.) and creating solutions that objectively advance the respective fields, DeepMind stands alone.
* The combination of neural models for intuition and symbolic engines for rigorous logic has been tapped as a solution before by DeepMind, and it would appear that they have found this to be a solid combo when it comes to solving problems that require a mix of imagination, problem solving, and technical rigour.

**Training Methodology**: 
* I thought the use of synthetic data generation is particularly interesting, as it represents a scalable way to train AI without human intervention.
    * We have all heard about this being possible, or working in niche cases... but to see it leveraged with such success is a huge step forward.

**Real-World Impact**: 
* While currently focused on geometry, the techniques and learnings from AlphaGeometry could influence other AI applications in science, engineering, and beyond.
    * As mentioned previously, this 1-2 combo of neural models (LLMs) and symbolic engines (Solvers) seems to hold a lot of promise for future work.

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.2 <b>KEY</b> TERMS RELATED TO <b>ALPHA</b>GEOMETRY</h3>
<hr>

This is just the start... I will add to this as we go.
**(1) AI (Artificial Intelligence)**
- **Definition**: The simulation of human intelligence in machines that are programmed to think like humans and mimic their actions.
- **ELI5**: Like teaching a robot to think and act like a person.
- **Relevance**: AlphaGeometry is an AI system, meaning it's a computer program designed to solve geometry problems like a human, particularly those found in Olympiads.

**(2) Neuro-Symbolic System**
- **Definition**: An approach in AI that combines neural networks (which excel in learning patterns from data) with symbolic AI (which uses structured logic to reason and solve problems).
- **ELI5**: It's like combining fast, instinctive thinking (neural) with careful, rule-based thinking (symbolic) to solve problems.
- **Relevance**: AlphaGeometry uses this approach to both intuitively guess and logically deduce solutions to geometry problems.

**(3) Neural Language Model**
- **Definition**: A type of AI that processes and understands human language. These models are trained on large datasets of text.
- **ELI5**: Imagine a robot that has read a lot of books and can use that knowledge to understand and generate language.
- **Relevance**: In AlphaGeometry, the neural language model helps by quickly generating ideas or guesses about solving geometry problems.

**(4) Symbolic Deduction Engine**
- **Definition**: A system in AI that uses explicit rules and logic to derive conclusions from given premises or data.
- **ELI5**: It's like a very strict math teacher who follows the rules of math precisely to solve problems.
- **Relevance**: This part of AlphaGeometry methodically works through geometry problems step-by-step, following strict geometrical rules.

**(5) Synthetic Data Generation**
- **Definition**: The creation of artificial data by a computer program, used for training AI models.
- **ELI5**: It's like creating a bunch of practice math problems for a student to learn from, instead of using problems from real textbooks.
- **Relevance**: AlphaGeometry was trained on many made-up geometry problems, helping it learn how to solve a wide variety of real problems.

**(6) Parallelized Computing**
- **Definition**: A type of computing where many calculations or processes are carried out simultaneously.
- **ELI5**: Imagine many people working on different parts of a big puzzle at the same time, instead of one person doing it alone.
- **Relevance**: This was used to quickly generate the huge amount of synthetic data needed to train AlphaGeometry.

**(7) Olympiad Geometry Problems**
- **Definition**: Advanced geometry problems like those found in international mathematics competitions for high school students.
- **ELI5**: These are very tricky puzzle-like math problems that are part of a big, worldwide math competition for students.
- **Relevance**: AlphaGeometry is designed to solve these complex problems, which are a test of its mathematical reasoning abilities.

**(8) International Mathematical Olympiad (IMO)**
- **Definition**: An annual mathematics competition for high school students from around the world, known for its challenging problems.
- **ELI5**: Like the Olympics, but for super hard high school math problems.
- **Relevance**: AlphaGeometry's performance is benchmarked against the level of these Olympiad problems.

**(9) Euclid's Five Postulates**

| **Postulate** | **Original Postulate Text** | **Detailed Explanation** | **ELI5 Explanation** | **Analogy** |
|:-----------:|-------------------------|----------------------|------------------|---------|
| **1** | It is possible to draw a straight line segment joining any two points. | This postulate states that if you have any two distinct points, you can always draw a straight line connecting them. It's a fundamental concept in geometry that establishes the existence of straight lines. | You can always draw a straight line between any two points. | Like connecting dots on paper with a ruler. |
| **2** | It is possible to indefinitely extend any straight line segment continuously in a straight line. | This means that a straight line can be extended infinitely in both directions. It does not have inherent endpoints and can be elongated as much as desired. | A straight line can go on forever in both directions. | Like a road that goes on forever and never curves. |
| **3** | Given any straight line segment, it is possible to draw a circle having the segment as a radius and one endpoint as its center. | This postulate allows for the construction of a circle using any straight line segment as its radius. The endpoint of this segment serves as the center of the circle. | You can draw a circle using any straight line segment, with one end of the line being the center of the circle. | Like using a piece of string with one end fixed, to draw a circle. |
| **4** | All right angles are equal to each other or congruent. | This postulate asserts that all right angles (angles of 90 degrees) are identical in measure. It establishes the consistency of right angles across different geometric contexts. | All right angles are the same, no matter where they are. | All corners of a square or a rectangle are the same angle. |
| **5** | Through a given point not on a given straight line, only one line can be drawn parallel to a given line. | This controversial postulate states that if you have a line and a point not on the line, there is exactly one line through the point that doesn't intersect the original line (i.e., is parallel to it). This postulate is the basis for non-Euclidean geometries when it's altered or omitted. | From a point not on a line, only one straight line can be drawn that will never meet the original line. | Like a walking path made parallel to railroad tracks that never cross each other. |

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.3 <b>SECTION</b>-BY-SECTION <b>ALPHA</b>GEOMETRY <a href=""https://www.nature.com/articles/s41586-023-06747-5"">PAPER</a> REVIEW</h3>
<hr>


<b style=""text-decoration: underline; font-family: Verdana; font-size: 18px; text-transform: uppercase; letter-spacing: 2px;"">Abstract Section</b>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Summary:</b>
* The paper introduces AlphaGeometry, an AI designed to solve complex geometry problems at the Olympiad level, a significant achievement in AI and automated reasoning. 
* Traditional machine learning struggles in mathematical domains due to the difficulty in converting human proofs into a format machines can understand. 
* This issue is particularly pronounced in geometry. 
* AlphaGeometry overcomes these challenges by generating its own database of theorems and proofs, employing a combination of neural networks and symbolic reasoning. 
* It has shown remarkable results, solving 25 out of 30 Olympiad-level problems, nearly matching the average score of top human competitors in these contests.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Important Information:</b>

1. ""Proving mathematical theorems at the olympiad level represents a notable milestone in human-level automated reasoning."" 
    * This highlights the significance of the achievement, as Olympiad-level problems are extremely challenging.
2. ""The problem is even worse for geometry because of its unique translation challenges.""
    * This indicates the specific difficulty in adapting machine learning for geometry.
3. ""AlphaGeometry is a neuro-symbolic system that uses a neural language model...to guide a symbolic deduction engine."" 
    * This shows the innovative approach of AlphaGeometry, combining advanced AI techniques.
4. ""On a test set of 30 latest Olympiad-level problems, AlphaGeometry solves 25."" 
    * This quantifies the system's success and its comparison to human performance.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Explanation Like I'm 5 (ELI5):</b>

* Imagine you have a super smart robot that loves playing with shape puzzles. 
* Most robots find these puzzles really hard, especially the trickiest ones made for the smartest kids. 
* But this robot, AlphaGeometry, is special. 
* It can solve almost all of these tough puzzles quickly and even explain how it did it, just like the smartest kids who win gold medals in shape puzzle contests!

<br>
    
<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Key Terms and Definitions:</b>
    
1. **Theorem Proving**: 
    * Like solving a riddle or puzzle in mathematics. 
    * It's about proving whether certain statements about numbers, shapes, or patterns are true.
2. **Euclidean Plane Geometry**: 
    * This is the study of shapes, sizes, and the properties of space. 
    * If you've ever played with shapes on a flat table, that's like studying plane geometry.
3. **Neuro-Symbolic System**: 
    * A combination of two AI techniques. 
        * **""Neuro""** refers to neural networks, which are like a simplified version of how our brains work
        * **""Symbolic""** involves using clear, defined rules and symbols, like in traditional computer programs.
4. **Neural Language Model**: 
    * This is a part of AI that understands and uses human-like language. 
        * It's trained to read, understand, and sometimes write text like a human.
        * Think LLM (ChatGPT, etc.)
5. **Symbolic Deduction Engine**: 
    * This is a computer program that solves problems using a series of logical steps and rules, a bit like following a recipe to bake a cake, but for solving math problems.
6. **International Mathematical Olympiad (IMO)**: 
    * A world championship mathematics competition for high school students, known for its very challenging problems.
   
<b style=""text-decoration: underline; font-family: Verdana; font-size: 18px; text-transform: uppercase; letter-spacing: 2px;"">Main Section</b>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Summary:</b>

* This section of the AlphaGeometry paper explains the challenges and advancements in AI theorem proving, particularly in geometry. 
* Theorem proving is a complex AI task due to the difficulty in translating human proofs into formats understandable by machines. 
* The paper highlights the scarcity of training data for geometry problems and the limitations of current methods. 
* AlphaGeometry addresses these challenges by generating synthetic data (100 million theorems and proofs), focusing on Euclidean plane geometry. 
* It combines a pretrained language model with specialized symbolic engines for proof search, particularly for auxiliary construction - a key challenge in theorem proving. 
* This approach has led to AlphaGeometry performing close to the level of an IMO gold medalist in solving classical geometry problems.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Important Information:</b>

1. ""Theorem proving is difficult for learning-based methods because training data of human proofs translated into machine-verifiable languages are scarce."" 
    * This emphasizes the challenge of data scarcity in AI theorem proving.
2. ""By using existing symbolic engines on a diverse set of random theorem premises, we extracted 100 million synthetic theorems and their proofs."" 
    * This shows how AlphaGeometry overcomes the data scarcity problem.
3. ""We pretrain a language model... and fine-tune it to focus on auxiliary construction during proof search."" 
    * This explains the technique used for solving complex geometry problems.
4. ""AlphaGeometry... substantially outperforms the previous state-of-the-art geometry-theorem-proving computer program."" 
    * This highlights the significant advancement AlphaGeometry represents in the field.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Explanation Like You're 5 (ELI5)</b>

* Imagine you have a really big book of puzzles that are super hard, and you have a magic pen that can draw new puzzles and find answers to them. 
* This magic pen is like AlphaGeometry. 
* It's smart because it learned from a huge number of puzzles it created by itself. 
* When it sees a new puzzle, it uses its magic to think of new ways to solve it, like drawing new shapes or lines that help find the answer. 
* This magic pen is so good at solving puzzles that it's almost as smart as the cleverest kids who win big puzzle competitions!

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Key Terms and Definitions</b>

1. **Theorem Proving**: 
    * In AI, this refers to the process of finding proofs for mathematical statements using algorithms and computational methods.
2. **Synthetic Data**: 
    * Artificially created data used to train machine learning models, as opposed to real-world data.
3. **Euclidean Plane Geometry**: 
    * The study of geometric shapes and properties in a flat, two-dimensional space, like the geometry of shapes drawn on paper.
4. **Auxiliary Construction**: 
    * In geometry, this involves adding extra lines, points, or shapes to a diagram to help prove a theorem.
5. **Language Model**: 
    * An AI model trained to understand and generate human-like text.
6. **Symbolic Engines**: 
    * Software systems that solve problems using symbols and logic, following a set of predefined rules.
7. **International Mathematical Olympiad (IMO)**: 
    * A prestigious annual competition for high school students, featuring challenging mathematics problems.
8. **Exogenous Term Generation**: 
    * In AI theorem proving, this refers to the creation of new elements or terms during the proof process that were not part of the original problem statement.
<br>

<a id=""imports""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""imports"">3&nbsp;&nbsp;IMPORTS &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
print(""\n... PACKAGE INSTALLS STARTING ...\n"")

# Imports Required for Installs
import os
import sys

# Define directory paths for installs
AG_REPO_DIR = ""/kaggle/input/alphageometry-github-repo/alphageometry""
AG_DATA_DIR=""/kaggle/working/ag_ckpt_vocab""
MELIAD_DIR=""/kaggle/working/meliad_lib/meliad""
sys.path.insert(0, AG_REPO_DIR)

# Define common hyperparameters for usage
DDAR_ARGS={
    ""defs_file"": os.path.join(AG_REPO_DIR, ""defs.txt""),
    ""rules_file"": os.path.join(AG_REPO_DIR, ""rules.txt"")
}
BATCH_SIZE=2
BEAM_SIZE=2
DEPTH=2
SEQ_LENGTH=128

LM_ARGS = {
    ""ckpt_path"": AG_DATA_DIR,
    ""vocab_path"": os.path.join(AG_DATA_DIR, ""geometry.757.model""),
    ""gin_search_paths"": os.path.join(MELIAD_DIR, ""transformer/configs""),
    ""gin_files"": [
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""base_htrans.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""size/medium_150M.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""options/positions_t5.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""options/lr_cosine_decay.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""options/seq_1024_nocache.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""geometry_150M_generate.gin"")
    ],
    ""gin_params"": {
        ""DecoderOnlyLanguageModelGenerate.output_token_losses"": True,
        ""TransformerTaskConfig.batch_size"": BATCH_SIZE,
        ""TransformerTaskConfig.sequence_length"": SEQ_LENGTH,
        ""Trainer.restore_state_variables"": False
    }
}

# Do the installs
!pip install -q -r {os.path.join(AG_REPO_DIR, ""requirements.in"")}
!pip install -q --upgrade gdown==4.7.3

if not os.path.isdir(AG_DATA_DIR):
    !gdown -q --folder https://bit.ly/alphageometry

if not os.path.isdir(MELIAD_DIR):
    os.makedirs(MELIAD_DIR, exist_ok=True)
    !git clone -q https://github.com/google-research/meliad {MELIAD_DIR}
    !export PYTHONPATH=$PYTHONPATH:/kaggle/working/meliad_lib/meliad
print(""\n... PIP INSTALLS COMPLETE ...\n"")

print(""\n... IMPORTS STARTING ...\n"")
print(""\n\tVERSION INFORMATION"")
# Machine Learning and Data Science Imports (basics)
import tensorflow as tf; print(f""\t\t– TENSORFLOW VERSION: {tf.__version__}"");
import pandas as pd; pd.options.mode.chained_assignment = None; pd.set_option('display.max_columns', None);
import numpy as np; print(f""\t\t– NUMPY VERSION: {np.__version__}"");
import sklearn; print(f""\t\t– SKLEARN VERSION: {sklearn.__version__}"");

# Built-In Imports (mostly don't worry about these)
from kaggle_datasets import KaggleDatasets
from collections import Counter
from datetime import datetime
from zipfile import ZipFile
from glob import glob
import Levenshtein
import subprocess
import warnings
import requests
import hashlib
import imageio
import IPython
import sklearn
import urllib
import zipfile
import pickle
import random
import shutil
import string
import json
import math
import time
import gzip
import ast
import sys
import io
import os
import gc
import re

# Visualization Imports (overkill)
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
from matplotlib.patches import Rectangle
import matplotlib.patches as patches
import plotly.graph_objects as go
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm; tqdm.pandas();
import plotly.express as px
import tifffile as tif
import seaborn as sns
from PIL import Image, ImageEnhance; Image.MAX_IMAGE_PIXELS = 5_000_000_000;
import matplotlib; print(f""\t\t– MATPLOTLIB VERSION: {matplotlib.__version__}"");
import plotly
import PIL
import cv2

import plotly.io as pio
print(pio.renderers)

def check_nvidia_gpu():
    try:
        subprocess.check_output('nvidia-smi')
        print('\n... NVIDIA GPU DETECTED ...\n')
        return True
    except Exception: # this command not being found can raise quite a few different errors depending on the configuration
        print('\n... NO NVIDIA GPU DETECTED ...\n')
        return False

def seed_it_all(seed=7):
    """""" Attempt to be Reproducible """"""
    os.environ['PYTHONHASHSEED'] = str(seed)
    random.seed(seed)
    np.random.seed(seed)
    tf.random.set_seed(seed)

seed_it_all()
print(f""ARE WE USING NVIDIA-GPU?\n\t--> {check_nvidia_gpu()}"")
print(""\n\n... IMPORTS COMPLETE ...\n"")
<br>

<a id=""geometry""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""geometry"">4&nbsp;&nbsp;GEOMETRY &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.1 <code><b>GEOMETRY.PY</b></code> FILE - <b>IMPORTS</b></h3>
<hr>

# Copyright 2023 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

""""""Implements geometric objects used in the graph representation.""""""
from __future__ import annotations

from collections import defaultdict  # pylint: disable=g-importing-member
from typing import Any, Type
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.2 <code><b>GEOMETRY.PY</b></code> FILE - THE <b>NODE</b> CLASS</h3>
<hr>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Class Definition</b>

* The Node class is a component in a graph structure, it will be used for proving geometric theorems and/or other similar tasks. 
* The docstring explains that nodes can represent various geometric entities and maintain relationships with other nodes.

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">High Level ELI5 Analogy</b>

* Let's use an analogy of a social network to explain the Node class. 
* As such, we imagine each `**Node**` as a **person** in a social network. 
* This network isn't just about who knows whom, but also includes details about friendships merging, people representing groups, and different types of relationships.

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Constructor and Attributes</b>

* The **`__init__`** method initializes a Node instance. 
* It sets up various attributes as shown in the table below:

| **Attribute**         | **Type**        | **Purpose in Node Class**                                     | **Social Network Analogy**                                                                          |
|-------------------|-------------|-----------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| **`self.name`**       | **`str`**       | Represents the name of the node.                          | Like a person's name in the social network. If they don't have a name, they use a unique ID.     |
| **`self.graph`**      | **`Any`**       | Reference to the graph this node is part of.              | Represents the social network platform or community the person belongs to.                      |
| **`self.edge_graph`** | **`dict`**      | Tracks connections to other nodes.                        | A list of the person's friends and the details about how and why they are friends (shared interests, etc.).  |
| **`self.merge_graph`**| **`dict`**      | Maintains history of merges with other nodes.             | History of when and why two people (one of which is the person) decided to represent themselves as a single entity (like a couple or a team). |
| **`self.rep_by`**     | **`Node`**/**`None`** | Indicates which node this node is represented by.        | If a person is part of a group or team, this shows who is the spokesperson or leader of that group. |
| **`self.members`**    | **`set`**       | Set of nodes in the equivalence class this node belongs to. | Members of a group or community that the person is part of.                                      |
| **`self._val`**       | **`Node`**/**`None`** | Private attribute for value-type relationships.           | Represents a specific quality or characteristic of a/the person, like their role in a project.      |
| **`self._obj`**       | **`Node`**/**`None`** | Private attribute for object-type relationships.          | The actual project or object that is associated with the person's role.                          |
| **`self.deps`**       | **`list`**      | List of dependencies.                                     | Other people or things that this person relies on or is influenced by.                          |
| **`self.num`**        | **`Numeric`**/**`None`** | Numerical representation of the node.                     | A unique number or ID for the person, used for sorting or identification purposes.              |
| **`self.change`**     | **`set`**       | Tracks nodes dependent on this node's numerical representation. | People who are influenced or affected by changes in this person's status or role.               |

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Method Overview</b>

To explain the methods of the **`Node`** class, let's continue using the social network analogy as well as explaining things simply based on the real purpose.


| **Method**                  | **Purpose in Node Class**                                       | **Social Network Analogy**                                                                                   |
|-------------------------|-------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| **`set_rep`**               | Sets another node as the representative of this node.       | Choosing someone to represent you in the social network, like a spokesperson or agent.                  |
| **`rep`**                   | Finds the representative node of this node.                 | Finding out who is currently representing you in the network.                                            |
| **`why_rep`**               | Explains why a node has a certain representative.           | Understanding the reasons or history behind why someone represents you.                                  |
| **`rep_and_why`**           | Gets the representative and the reason for representation.  | Identifying your representative and understanding why they represent you.                                |
| **`neighbors`**             | Finds neighboring nodes of a certain type.                  | Looking for people in your network who have a specific relationship to you (friends, colleagues, etc.). |
| **`merge_edge_graph`**      | Merges the edge graph of another node into this one.        | Combining your friendship network with someone else's.                                                   |
| **`merge`**                 | Merges this node with a list of other nodes.                | Forming a group or a team with a list of people.                                                         |
| **`merge_one`**             | Merges this node with another specific node.                | Forming a partnership or alliance with another person.                                                   |
| **`is_val`**                | Checks if a node has a specific value-type relationship.    | Determining if your relationship with someone has a specific characteristic (like a work relationship). |
| **`set_val`**               | Sets a value-type relationship for the node.                | Defining a specific characteristic of your relationship with someone.                                    |
| **`set_obj`**               | Sets an object-type relationship for the node.              | Associating a specific item or project with your relationship.                                           |
| **`val`** (property)        | Gets the value-type relationship of the node.               | Checking the specific characteristic of your relationship with someone.                                  |
| **`obj`** (property)        | Gets the object-type relationship of the node.              | Looking at the item or project associated with your relationship.                                        |
| **`equivs`**                | Gets all nodes equivalent to this node.                     | Finding all the people who are considered the same as you in the network (like members of a team).      |
| **`connect_to`**            | Connects this node to another node with dependencies.       | Forming a connection or relationship with someone, with specific reasons or conditions.                 |
| **`equivs_upto`**           | Finds equivalent nodes up to a certain level.               | Identifying people who are equivalent to you up to a certain degree or within a certain context.        |
| **`why_equal`**             | Explains why this node is equal to other nodes.             | Understanding why you are considered the same as other people in specific situations.                    |
| **`why_equal_groups`**      | Finds reasons for equality among groups of nodes.           | Finding out why you are considered part of different groups or categories in the network.                |
| **`why_val`**               | Explains why a node has a specific value-type relationship. | Understanding why a specific characteristic defines your relationship with someone.                      |
| **`why_connect`**           | Explains the reason behind a connection to another node.    | Understanding the reasons or history behind your connection with someone else.                           |

Each method in the `Node` class plays a role similar to interactions and relationships in a social network, managing how individuals (nodes) relate to each other, form groups, represent one another, and define their relationships.

---

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Code Walkthrough</b>

I will now go through the actual code itself:
* I will add comments that are overly verbose to help over-explain functionality
* I will add Google style docstrings
* I will rewrite certain parts of the code if necessary to improve my understanding

<br>
class Node:
    """"""
    Represents a node in a proof state graph, which can be a Point, Line, Circle, etc.
    
    This class handles the complexities of graph-based relationships, including merging histories,
    equivalence relationships, and connections to other nodes.

    Attributes:
        name (str): The name of the node. Defaults to the object's string representation if empty.
        graph (Any): A reference to the graph that this node is a part of.
        edge_graph (dict): A dictionary representing connections to other nodes.
        merge_graph (dict): A dictionary maintaining the history of merges with other nodes.
        rep_by (Node or None): The node that this node is currently represented by, if any.
        members (set): A set of nodes that are members of the equivalence class this node belongs to.
        _val (Node or None): A private attribute for value-type relationships.
        _obj (Node or None): A private attribute for object-type relationships.
        deps (list): A list of dependencies.
        num (numeric or None): A numerical representation of the node, used for indexing or sorting.
        change (set): A set of nodes whose numerical representation depends on this node.
    
    Example Usage:
        >>> point = Node(name=""PointA"")
        >>> line = Node(name=""LineB"")
        >>> point.connect_to(line, deps=[""dependency1""])
    """"""

    def __init__(self, name: str = '', graph: Any = None):
        """"""
        Initialize a new Node instance.
        
        Args:
            name (str): The name of the node. If not provided, defaults to the object's string representation.
            graph (Any): The graph to which this node belongs. Can be any type.
        """"""
        self.name = name or str(self)  # Use the provided name or default to the object's string representation.
        self.graph = graph  # The graph this node is part of. Could be any structure or type.

        # Edge graph: Tracks what other nodes this node is connected to.
        # Structure: 
        #      edge_graph = {
        #          other_node1: {
        #              this_node1: deps, 
        #              this_node2: deps
        #          }, 
        #          other_node2: {
        #              this_node2: deps, 
        #              ...
        #          }
        #      }
        self.edge_graph = {}

        # Merge graph: Keeps the history of merges with other nodes.
        # Structure: 
        #    merge_graph = {
        #        this_node1: {
        #            merged_node1: deps1, 
        #            merged_node2: deps2
        #        }, 
        #        ...
        #    }
        self.merge_graph = {}

        self.rep_by = None  # The node that this node is represented by, if any.
        self.members = {self}  # Starts as a set containing only this node, representing its equivalence class.

        self._val = None  # Private attribute for storing a value-type relationship (like length or angle).
        self._obj = None  # Private attribute for storing an object-type relationship.

        self.deps = []  # A list to track dependencies.

        # Numerical representation, possibly for indexing or sorting purposes within the graph.
        self.num = None

        # Set of nodes whose numerical representation ('num') is influenced by this node.
        self.change = set()

    def set_rep(self, node: 'Node') -> None:
        """"""
        Set another node as the representative of this node.

        This method is used when two nodes are determined to be equivalent, and one needs to act as the representative.

        Args:
            node (Node): The node to set as the representative.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.set_rep(node2)  # Node2 now represents Node1

        Raises:
            ValueError: If the provided node is the same as the current node.
        """"""
        if node == self:
            raise ValueError(""A node cannot represent itself."")
        
        # Set the representative node.
        self.rep_by = node

        # Merge the edge graph of the current node with the representative node.
        #   - This means combining their connections.
        node.merge_edge_graph(self.edge_graph)

        # Update the representative's members set to include members of this node.
        #   - This reflects that they are now part of the same equivalence class.
        node.members.update(self.members)

    def rep(self) -> 'Node':
        """"""
        Get the representative node of this node.

        If this node is part of an equivalence class (i.e., it has been merged with other nodes),
        this method will return the node that represents this equivalence class.

        Returns:
            Node: The representative node.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> rep_node = node.rep()  # Get the representative of 'node'

        """"""
        x = self
        # Traverse up the chain of representatives.
        #   - This is akin to finding the ""root"" or the primary representative in the equivalence class.
        while x.rep_by:
            x = x.rep_by
        return x

    def why_rep(self) -> list[Any]:
        """"""
        Explains the reason(s) why this node is represented by its current representative.

        This method utilizes the 'why_equal' method to trace back the series of merges or 
        equivalences that led to the current representation of this node.

        Returns:
            list[Any]: A list of reasons (dependencies) explaining the representative relationship.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.set_rep(node2)
            >>> node1.why_rep()  # Explains why node1 is represented by node2
        """"""
        # The method leverages the 'why_equal' function, passing the current representative node.
        return self.why_equal([self.rep()], None)
    
    def rep_and_why(self) -> tuple[Node, list[Any]]:
        """"""
        Retrieves the representative of this node and the reasons for its representation.

        This method combines the functionality of 'rep' and 'why_rep' to provide both the representative
        node and the reasons behind this representation in a single call.

        Returns:
            tuple[Node, list[Any]]: A tuple containing the representative node and a list of reasons for the representation.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> rep, reasons = node.rep_and_why()  # Get the representative and the reasons
        """"""
        # First, find the representative node of this node.
        rep = self.rep()
        
        # Then, get the reasons why this node is represented by the rep node.
        #   - This is done by tracing back the equivalence or merging history.
        return rep, self.why_equal([rep], None)

    def neighbors(self, oftype: Type[Node], return_set: bool = False, do_rep: bool = True) -> list[Node]:
        """"""
        Retrieves a list of neighboring nodes of a specific type.

        This method can return either direct neighbors or representatives of those neighbors, 
        depending on the 'do_rep' flag.

        Args:
            oftype (Type[Node]): The type of neighboring nodes to retrieve.
            return_set (bool): If True, returns a set instead of a list. Defaults to False.
            do_rep (bool): If True, returns representatives of the neighbors. Defaults to True.

        Returns:
            list[Node]: A list (or set, if return_set is True) of neighboring nodes or their representatives.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> neighbors = node.neighbors(Node, return_set=False, do_rep=True)
        """"""
        
        # Initialize the set of neighboring nodes (or their representatives)
        result = set()
        
        # Determine whether to use the representative of this node or the node itself.
        rep = self.rep() if do_rep else self

        # Iterate through each neighbor in the edge graph of the representative (or this node).
        for n in rep.edge_graph:
            # Check if the neighbor matches the specified type, if type is given.
            if oftype is None or isinstance(n, oftype):
                # Add either the representative of the neighbor or the neighbor itself to the result.
                result.add(n.rep() if do_rep else n)

        # Return the result as a set if specified, otherwise as a list.
        return result if return_set else list(result)

    def merge_edge_graph(self, new_edge_graph: dict[Node, dict[Node, list[Node]]]) -> None:
        """"""
        Merges a new edge graph into this node's existing edge graph.

        This method is essential for combining the connections (edges) of two nodes 
        when they are merged, ensuring that the merged node maintains all existing connections.

        Args:
            new_edge_graph (dict): The edge graph to be merged with this node's edge graph.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.merge_edge_graph(node2.edge_graph)
        """"""
        for x, xdict in new_edge_graph.items():
            # Iterate through each node and its associated dictionary in the new edge graph.
            if x in self.edge_graph:
                # If this node already exists in our edge graph, update its dependencies.
                self.edge_graph[x].update(dict(xdict))
            else:
                # If this node is new to our edge graph, add it along with its dependencies.
                self.edge_graph[x] = dict(xdict)
                
    def merge(self, nodes: list[Node], deps: list[Any]) -> None:
        """"""
        Merges a list of nodes into this node, updating the merge graph.

        Each node in the list will be merged with this node, and the dependencies
        for each merge will be recorded.

        Args:
            nodes (list[Node]): The nodes to merge with this node.
            deps (list[Any]): The dependencies associated with each merge.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node3 = Node(name=""Node3"")
            >>> node1.merge([node2, node3], deps=[""dep1"", ""dep2""])
        """"""
        # Merge each node in the list with this node ... one by one
        for node in nodes:
            self.merge_one(node, deps)

    def merge_one(self, node: Node, deps: list[Any]) -> None:
        """"""
        Merges a single node into this node, updating the merge graph.

        This method is used for merging one node at a time, setting this node as the representative
        for the merged node and recording the dependencies for the merge.

        Args:
            node (Node): The node to be merged with this node.
            deps (list[Any]): The dependencies associated with the merge.
        
        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.merge_one(node2, deps=[""dep1""])
        """"""
        # Update the representative of the node to be this node's representative.
        node_rep = node.rep()
        node_rep.set_rep(self.rep())

        if node in self.merge_graph:
            # If the node is already merged, no further action is required.
            return

        # Update the merge graph for both nodes to reflect the new dependencies.
        #   - The node we are bringing in and the node we represent (self)
        self.merge_graph[node] = deps
        node.merge_graph[self] = deps
        
    def is_val(self, node: Node) -> bool:
        """"""
        Checks if the relationship between this node and another node is of a specific value type.

        This method is used to determine if there's a specific value-type relationship between 
        two nodes. Some examples of this are:
            - a `Line` (self) and a `Direction` (node)
            - a `Segment` (self) and a `Length` (node)
            - an `Angle` (self) and a `Measure` (node)
            - a `Ratio` (self) and a `Value` (node)

        Args:
            node (Node): The other node to check the relationship with.

        Returns:
            bool: True if there is a value-type relationship, False otherwise.

        Example Usage:
            >>> line = Node(name=""Line"")
            >>> direction = Node(name=""Direction"")
            >>> line.is_val(direction)  # Returns True if 'direction' is a value-type for 'line'
        """"""
        # The following checks are specific to the types of nodes and their value relationships.
        #   - This is typically used in geometric or other domain-specific contexts.
        #   - If none of the following relationships are matched than we return False.
        return (
            # Is this node a Line and is the other node a Direction
            (isinstance(self, Line) and isinstance(node, Direction)) or
            
            # Is this node a Segment and the other node is a Length
            (isinstance(self, Segment) and isinstance(node, Length)) or
            
            # Is this node an Angle and the other node is a Measure
            (isinstance(self, Angle) and isinstance(node, Measure)) or
            
            # Is this node a Ratio and the other node is a Value
            (isinstance(self, Ratio) and isinstance(node, Value))
        )

    def set_val(self, node: Node) -> None:
        """"""
        Sets a node as the value-type relationship of this node.

        This method is used when you want to associate a value-type relationship with this node,
        like associating a Length (value not the object) with a Segment.

        Args:
            node (Node): The node to set as the value-type relationship.

        Example Usage:
            >>> segment = Node(name=""Segment"")
            >>> length = Node(name=""Length"")
            >>> segment.set_val(length)  # Sets 'length' as the value for 'segment'
        """"""
        self._val = node  # Set the provided node as the value-type relationship.

    def set_obj(self, node: Node) -> None:
        """"""
        Sets a node as the object-type relationship of this node.

        This method is similar to 'set_val' but is used for setting object-type relationships.
        For example, associating a Segment with a Length.

        Args:
            node (Node): The node to set as the object-type relationship.

        Example Usage:
            >>> length = Node(name=""Length"")
            >>> segment = Node(name=""Segment"")
            >>> length.set_obj(segment)  # Sets 'segment' as the object for 'length'
        """"""
        self._obj = node  # Set the provided node as the object-type relationship.

    # Properties are defined to give easy access to the value and object relationships.
    @property
    def val(self) -> Node:
        """"""
        A property to get the node representing the value-type relationship of this node.

        Returns the representative of the value-type node if it exists, otherwise None.

        Returns:
            Node or None: The representative of the value-type relationship node.

        Example usage:
            >>> segment = Node(name=""Segment"")
            >>> length = Node(name=""Length"")
            >>> segment.set_val(length)
            >>> segment.val  # Returns the representative of 'length'
        """"""
        return self._val.rep() if self._val else None

    @property
    def obj(self) -> Node:
        """"""
        A property to get the node representing the object-type relationship of this node.

        Returns the representative of the object-type node if it exists, otherwise None.

        Returns:
            Node or None: The representative of the object-type relationship node.

        Example Usage:
            >>> length = Node(name=""Length"")
            >>> segment = Node(name=""Segment"")
            >>> length.set_obj(segment)
            >>> length.obj  # Returns the representative of 'segment'
        """"""
        return self._obj.rep() if self._obj else None
    
    def equivs(self) -> set[Node]:
        """"""
        Retrieves all nodes that are equivalent to this node.

        This method returns all the members of the equivalence class that this node belongs to, 
        including itself.

        Returns:
            set[Node]: A set of nodes that are equivalent to this node.

        Example usage:
            >>> node = Node(name=""Node"")
            >>> equivalent_nodes = node.equivs()
        """"""
        # Retrieve the representative of this node and return all its members.
        #   - This will represent the equivalence class of this node.
        return self.rep().members

    def connect_to(self, node: Node, deps: list[Any] = None) -> None:
        """"""
        Connects this node to another node, updating the edge graph.

        This method is used to establish a connection or relationship between this node and another,
        optionally with a list of dependencies that describe the nature of the connection.

        Args:
            node (Node): The node to connect to.
            deps (list[Any], optional): The dependencies associated with the connection.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.connect_to(node2, deps=[""dependency1""])
        """"""
        
        # Get the representative of this node.
        rep = self.rep()  

        if node in rep.edge_graph:
            # If there's already a connection to the node, update the dependencies.
            rep.edge_graph[node].update({self: deps})
        else:
            # If this is a new connection, add it to the edge graph with the dependencies.
            rep.edge_graph[node] = {self: deps}

        if self.is_val(node):
            # If there is a value-type relationship between this node and the other... set it accordingly.
            self.set_val(node)
            node.set_obj(self)

    def equivs_upto(self, level: int) -> dict[Node, Node]:
        """"""
        Retrieves the equivalent nodes up to a certain level of depth in the merge graph.

        This method is useful for understanding the depth of equivalence relationships between nodes. 
            - This mechanism is essential for understanding the node's equivalence relationships up to a certain depth
        
        Details:
            - A breadth-first search (BFS) approach is employed to traverse the merge_graph. 
            - The queue is used to process each node in a level-by-level manner. 
            - For each node, its neighbors (other nodes it's merged with) are examined. 
            - The traversal considers the 'level' of the merge relationship, allowing control over how deep the search goes in the graph. 

        Args:
            level (int): The level up to which equivalent nodes should be retrieved.

        Returns:
            dict[Node, Node]: A dictionary where keys are nodes and values are their parents in the merge graph up to the specified level.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> equivalents_up_to_level = node.equivs_upto(2)
        """"""
        parent = {self: None}  # Start with the current node as its own parent.
        visited = set()  # Keep track of visited nodes.
        queue = [self]  # Queue for BFS traversal.
        i = 0

        while i < len(queue):
            # Get the current node from the queue.
            current = queue[i]
            i += 1  # Increment the index for the next iteration.

            # Mark the current node as visited to avoid reprocessing it.
            visited.add(current)

            # Iterate through each neighbor connected to the current node in the merge graph.
            for neighbor in current.merge_graph:
                # Check if the level of the merge relationship is within the specified limit.
                # If the level is too high (i.e., exceeds the specified 'level'), skip this neighbor.
                if level is not None and current.merge_graph[neighbor].level is not None and current.merge_graph[neighbor].level >= level:
                    continue

                # If this neighbor hasn't been visited yet, add it to the queue for processing.
                if neighbor not in visited:
                    queue.append(neighbor)
                    # Record the parent (current node) of this neighbor. This is useful for backtracking.
                    parent[neighbor] = current

        return parent
    
    def why_equal(self, others: list[Node], level: int) -> list[Any]:
        """"""
        Explains why this node is considered equal to other nodes, up to a certain level.

        This method performs a breadth-first search (BFS) in the merge graph to find 
        the path to the specified nodes, considering the level of merges.

        Args:
            others (list[Node]): The nodes to compare with.
            level (int): The level up to which the search is performed.

        Returns:
            list[Any]: A list of reasons (dependencies) explaining why the nodes are considered equal.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> reasons = node1.why_equal([node2], level=2)
        """"""
        
        # Convert the list of other nodes to a set for efficient look-up.
        others = set(others)
        
        # Initialize the counter for the number of 'other' nodes found.
        found = 0  
        
        # Initialize the dictionary to keep track of each node's parent in the BFS tree.
        parent = {}
        
        # Initialize the BFS queue with the current node.
        queue = [self]  
        
        # Initialize the index for iterating over the queue.
        i = 0  
        
        # Iterate until the queue is exhausted
        while i < len(queue):
            current = queue[i]  # Get the current node from the queue.
            if current in others:
                # If the current node is one of the 'others', increment the found counter.
                found += 1
            if found == len(others):
                # If all 'other' nodes are found, break out of the loop.
                break
            i += 1  # Move to the next node in the queue.

            # Iterate over the neighbors of the current node in the merge graph.
            for neighbor in current.merge_graph:
                # Check if the merge level of the neighbor is within the specified limit.
                if level is not None and current.merge_graph[neighbor].level is not None and current.merge_graph[neighbor].level >= level:
                    continue  # Skip neighbors beyond the specified level.

                if neighbor not in parent:
                    # If the neighbor hasn't been visited yet, add it to the queue and record its parent.
                    queue.append(neighbor)
                    parent[neighbor] = current

        # Perform backtracking from the found nodes to the current node, 
        #   - This uses the parent dictionary to find the path and reasons for equality.
        return bfs_backtrack(self, others, parent)


    def why_equal_groups(self, groups: list[list[Node]], level: int) -> tuple[list[Any], list[Node]]:
        """"""
        Performs a breadth-first search (BFS) to determine why this node is equal to at least one member of each group.

        This method is useful for understanding complex equivalence relationships across multiple groups
        of nodes, particularly in scenarios where a node might be equivalent to different nodes in different contexts.

        Args:
            groups (list[list[Node]]): A list of groups, each containing multiple nodes.
            level (int): The level up to which the search is conducted in the merge graph.

        Returns:
            tuple[list[Any], list[Node]]: A tuple containing a list of reasons for equivalence and a list of equivalent nodes from each group.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> group1 = [Node(name=""Node1""), Node(name=""Node2"")]
            >>> group2 = [Node(name=""Node3""), Node(name=""Node4"")]
            >>> reasons, equivalents = node.why_equal_groups([group1, group2], level=2)
        """"""
        
        # Initialize a list to hold the found equivalent node in each group.
        others = [None for _ in groups]  
        
        # Initialize the counter for the number of groups where an equivalent node is found.
        found = 0  
        
        # Initialize the dictionary to track the parent of each node in the BFS tree.
        parent = {}  
        
        # Initialize the queue for BFS, starting with the current node.
        queue = [self]  
        
        # Initialize the index for iterating over the queue.
        i = 0
        
        # Iterate until the queue is exhausted
        while i < len(queue):
            current = queue[i]
            # Check each group for an equivalent node.
            for j, grp in enumerate(groups):
                if others[j] is None and current in grp:
                    others[j] = current  # Record the equivalent node found in this group.
                    found += 1  # Increment the counter for found groups.

            if found == len(others):  # If equivalents are found in all groups, stop the search.
                break

            i += 1

            # Process the neighbors of the current node in the merge graph.
            for neighbor in current.merge_graph:
                # Only consider neighbors within the specified level.
                if level is not None and current.merge_graph[neighbor].level is not None and current.merge_graph[neighbor].level >= level:
                    continue
                # Only consider neighbors not already contained within the parent
                if neighbor not in parent:
                    queue.append(neighbor)
                    parent[neighbor] = current

        # Backtrack from the found nodes to determine the path and reasons for equivalence.
        return bfs_backtrack(self, others, parent), others

    def why_val(self, level: int) -> list[Any]:
        """"""
        Explains why the value of this node is considered equal to its current value, up to a certain level.

        This method is useful for understanding the reasoning behind the value assignment of this node,
        especially in complex graphs where values are determined through a series of equivalences.

        Args:
            level (int): The level up to which the search for equivalence is performed.

        Returns:
            list[Any]: A list of reasons (dependencies) explaining the value equivalence.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> value_node = Node(name=""ValueNode"")
            >>> node.set_val(value_node)
            >>> reasons = node.why_val(level=2)
        """"""
        
        # If there are no values assigned we exit early and return None.
        if self._val is None:
            return None
        
        # Perform a BFS to find the reason why this node's value is equal to the representative of its value.
        return self._val.why_equal([self.val], level)


    def why_connect(self, node: Node, level: int = None) -> list[Any]:
        """"""
        Explains the reasons behind the connection between this node and another node, up to a certain level.

        This method is particularly useful in scenarios where the graph represents complex interdependencies,
        and understanding these connections is crucial.

        Args:
            node (Node): The node to which the connection is established.
            level (int, optional): The level up to which the search is conducted in the edge graph.

        Returns:
            list[Any]: A list of dependencies explaining the connection to the specified node.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.connect_to(node2, deps=[""dependency1""])
            >>> reasons = node1.why_connect(node2, level=2)
        """"""
        # Get the representative of this node.
        rep = self.rep()  # Get the representative of this node.
        
        # Get the list which contains all the nodes that are connected to the specified node vai the rep's edge_graph
        equivs = list(rep.edge_graph[node].keys())
        
        # Return None if there are no equivalent connections.
        if not equivs:
            return None  
        
        # Consider the first equivalent node for simplicity.
        equiv = equivs[0]  
        
        # Find the reasons/dependencies for the equivalence/connection between this node and the specified node.
        dep = rep.edge_graph[node][equiv]
        return [dep] + self.why_equal(equiv, level)
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.3 <code><b>GEOMETRY.PY</b></code> FILE - THE <b>NODE</b> CLASS</h3>
<hr>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">The Remaining Class Definitions</b>

* Each subclass represents different geometric concepts.
* These classes inherit from Node and have additional methods specific to their geometric nature.
* The actual geometric concepts that are created as subclasses are:
    * **`Point`** / **`Node`**
        * A basic unit in geometry, representing a location in space with no implicit size or dimension.
    * **`Line`**
        * A line is an **infinitely long** (otherwise it would be a **segment**, straight path with no thickness.
        * It's a fundamental concept because it's used to define other geometric figures, and many theorems in Euclidean Geometry are based on the properties of lines.
    * **`Segment`**
        * A segment is a part of a line that is bounded by two distinct end points. 
        * Segments are important because they represent the simplest form of a measurable distance in geometry.
    * **`Circle`**
        * A circle is a set of points in a plane that are all at a given distance (the radius) from a fixed point (the center). 
        * Circles are crucial in geometry due to their symmetry and the way they relate to other geometric figures like lines and angles.
    * **`Angle`**
        * An angle is formed by two rays (or line segments) with a common endpoint. 
        * Angles are a fundamental measure of the rotation between two intersecting lines and are key to understanding geometric properties and relationships.
        * Angles help us define more complication geometric concepts (planes, etc)
    * **`Ratio`**
        * In geometry, ratios are used to compare sizes of similar figures, lengths of sides, and other quantities. 
        * Ratios are fundamental in understanding proportions and scaling in geometry, as well as in trigonometry.
    * **`Direction`**
        * Refers to the course along which something moves or faces. 
        * In geometry, direction can be represented as vectors or through angular relationships.
    * **`Measure`** and **`Length`**
        * Understanding how to quantify or measure geometrical entities. 
        * Length typically refers to the distance between two points/nodes
        * Measure is similar but usually extends to Angle(s), Area(s), etc.
    * **`Angle`**
        * Formed by two rays (or lines) that share a common endpoint. 
        * Understanding how angles are measured and their properties is important.

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Resources for Fundamentals of Euclidean Geometry</b>

* <a href=""https://math.libretexts.org/Courses/Mount_Royal_University/MATH_1150%3A_Mathematical_Reasoning/4%3A_Basic_Concepts_of_Euclidean_Geometry/4.1%3A_Euclidean_geometry""><b>Mathematics LibreTexts</b></a>: 
    * This resource offers detailed explanations of the basic concepts in Euclidean geometry. 
    * It covers the definitions and properties of points, lines, planes, angles, and various geometric figures, which are essential for understanding the structure and relationships in Euclidean space. 
    * It also discusses **Euclid's five postulates** (discussed above), which are the foundational assumptions of this field. 
    * This is a great resource for learning about the core elements of Euclidean Geometry in a structured manne.
* <a href=""https://byjus.com/maths/euclidean-geometry/""><b>BYJU'S Euclidean Geometry</b></a>: 
    * This is an educational resource that provides an overview of Euclidean geometry.
    * It covers the study of geometrical shapes and figures based on different axioms and theorems, primarily focusing on flat or plane surfaces (similar to the topic of AlphaGeometry). 
    * The resource also touches upon the historical context of Euclidean geometry, its development, and its foundational elements like points, lines, and planes. 
    * I found this one useful for understanding the practical applications and historical significance of Euclidean Geometry.
* <a href=""https://www.britannica.com/science/Euclidean-geometry/Solid-geometry""><b>Britannica on Euclidean Geometry</b></a>: 
    * This article provides a summary of Euclidean geometry, emphasizing its role as the study of plane and solid figures based on axioms and theorems used by the Greek mathematician Euclid. 
    * It underlines the importance of fundamental concepts like points, lines, angles, and circles in forming the basis of Euclidean geometry (very similar to what we are doing next). 
    * The resource is valuable for those looking to understand the broader context and impact of Euclidean geometry in the field of mathematics.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Graph Networking Concepts</b>

* **Node (Vertex)** 
    * A fundamental unit in a graph network, representing an entity (e.g., a point, line, circle, etc. ***in geometry***).
* **Edge** 
    * Represents the relationship or connection between two nodes in a graph.
* **Graph Traversal**: 
    * The process of visiting, checking, and/or updating nodes in a graph. 
    * Common methods include (but are not limited to) 
        * <b><a href=""https://www.wikiwand.com/en/Breadth-first_search"">Breadth-First Search (BFS)</a></b>
        * <b><a href=""https://www.wikiwand.com/en/Depth-first_search"">Depth-First Search (DFS)</a></b>
* **Abstraction Levels**
    * In graph networks, different levels of abstraction can be used to simplify or complicate the representation of relationships.
* **Neighbors**
    * In a graph, neighbors of a node are other nodes that are directly connected to it by an edge.
* **Equivalence & Equality in Graphs**
    * Understanding when two nodes are considered equivalent or equal
    * This is not as straightforward as it may appear... it may involve complex logic beyond simple identity or value comparison.
* **Recursion** 
    * Some functions use recursion, which is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem.
    * NOTE: This is not a graph networking concept but is important nonetheless

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Point` Class</b>

| **Method**            | **Purpose in Point Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node without any modification.             | Point is a basic entity in geometry without additional methods beyond those in Node. |

---

<br>

---

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Direction` Class</b>

| **Method**            | **Purpose in Direction Class**                                        | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node and represents a geometric direction. | Direction is used to represent the concept of direction in geometry without additional methods beyond those in Node. |

---

<br>

---

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Measure` Class</b>

| **Method**            | **Purpose in Measure Class**                                          | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node, specializing in geometric measures.  | Measure represents various measurements like angles, lengths, etc., without additional methods beyond those in Node. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Length` Class</b>

| **Method**            | **Purpose in Length Class**                                           | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node, specializing in representing lengths.| Length represents lengths in geometry without additional methods beyond those in Node. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Value` Class</b>

| **Method**            | **Purpose in Value Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node, encapsulating a generic value.       | Value is used in various contexts like ratios without additional methods beyond those in Node. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Line` Class</b>

| **Method**            | **Purpose in Line Class**                                             | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**             | Creates a new Direction node associated with this Line.               | Used to create a directional aspect for a line.      |
| **`why_coll`**            | Explains why given points are collinear with this line.               | Used to determine the collinearity of points with the line. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Segment` Class</b>

| **Method**            | **Purpose in Segment Class**                                          | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**            | Creates a new Length node associated with this Segment.               | Used to associate a length measure with a segment.   |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Circle` Class</b>

| **Method**            | **Purpose in Circle Class**                                           | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`why_cyclic`**          | Explains why given points are cyclic with respect to this circle.     | Determines the cyclic nature of points with respect to the circle. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Angle` Class</b>

| **Method**            | **Purpose in Angle Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**             | Creates a new Measure node associated with this Angle.                | Associates a measurement with an angle.              |
| **`set_directions`**      | Sets two Direction nodes associated with this Angle.                  | Used to define the directional aspects of an angle.  |
| **`directions`** (property)| Gets the Direction nodes associated with this Angle.                  | Retrieves the directional components of an angle.    |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Ratio` Class</b>

| **Method**            | **Purpose in Ratio Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**             | Creates a new Value node associated with this Ratio.                  | Associates a value with a ratio.                     |
| **`set_lengths`**         | Sets two Length nodes associated with this Ratio.                     | Used to define the proportional lengths in a ratio.  |
| **`lengths`** (property)  | Gets the Length nodes associated with this Ratio.                     | Retrieves the lengths involved in the ratio.         |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Other Standalone Functions</b>

| **Function**          | **Purpose**                                                           | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`why_connect`**         | Explains the connection reasons between pairs of nodes.               | Used to understand the dependencies behind node connections. |
| **`is_equiv`**           | Checks if two nodes are equivalent up to a certain level.             | Determines the equivalence of nodes with a depth limit in the graph. |
| **`is_equal`**           | Checks if two nodes are equal based on their values.                  | Evaluates equality based on node values and their relationships. |
| **`why_equal`**          | Explains why two nodes are considered equal.                         | Used to understand the reasons behind node equality. |
| **`get_lines_thru_all`** | Retrieves lines passing through a set of points.                      | Finds all lines intersecting a given set of points.  |
| **`line_of_and_why`**    | Determines the line connecting points and explains why.               | Identifies and rationalizes the line connecting specific points. |
| **`get_circles_thru_all`**| Retrieves circles passing through a set of points.                    | Finds all circles encompassing a given set of points.|
| **`circle_of_and_why`**   | Determines the circle connecting points and explains why.             | Identifies and rationalizes the circle connecting specific points.|
| **`name_map`**          | Maps structures to their names for easier representation.             | Converts complex structures into a readable name format. |
| **`all_angles`**          | Yields all angles formed by a pair of directions.                     | Generates angles based on direction pairs.           |
| **`all_ratios`**          | Yields all ratios formed by a pair of directions.                     | Generates ratios based on direction pairs.           |

---

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Readability Improvements</b>

To improve the readability and organization of the provided code, we can group related functionalities together and ensure a logical flow. This includes grouping the following:
* Class Definitions
    * We will place all class definitions at the beginning. 
    * This makes it easier to understand the available entities before diving into the functions that operate on them.
* Utility Functions
    * We place utility functions like **`why_connect`**, **`is_equal`**, **`why_equal`**, etc., after class definitions. 
    * These functions are general-purpose and can be used across different classes.
* Specific Functions
    * We place specific functions after the utility functions.
    * These functions, like **`get_lines_thru_all`**, **`line_of_and_why`**, **`get_circles_thru_all`**, **`circle_of_and_why`**, etc., offer more specific (sometimes more complicated) functionality.
    * These functions often utilize the utility functions and class methods.
* Global Variables and Constants
    * We place **`RANKING`** (and other globals if they existed... but they don't) at the end. 
    * Globals are often less crucial to the immediate understanding of the code's functionality.

<br>

---

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Code Walkthrough</b>

I will now go through the actual code itself and at a minimum...
* I will add comments that are overly verbose to help over-explain functionality
* I will add Google style docstrings
* I will rewrite certain parts of the code if necessary to improve my understanding

<br>


class Point(Node):
    """""" Inherits all behavior from Node without any modification. """"""
    pass


class Direction(Node):
    """"""Node of type Direction, representing a geometric direction.

    Inherits from Node and represents the concept of direction in geometry.
    """"""
    # No additional attributes or methods beyond those provided by Node.
    pass

class Measure(Node):
    """"""
    Node representing a geometric measure, such as the measure of an angle.

    This class extends the Node class, specializing in representing a geometric measure.
    It could represent various measurements like angles, lengths, etc.

    Example Usage:
        >>> measure1 = Measure()
    """"""
    # Inherits all behavior from Node without any modification.
    pass


class Length(Node):
    """"""
    Node representing a geometric length, such as the length of a segment.

    This class extends the Node class, specializing in representing lengths in geometry.

    Example Usage:
        >>> length1 = Length()
    """"""
    # Inherits all behavior from Node without any modification.
    pass


class Segment(Node):
    """"""Node of type Segment, representing a geometrical segment.

    Inherits from Node and adds specific functionality for segments in geometry.
    A segment is a part of a line that is bounded by two distinct end points.
    """"""

    def new_val(self) -> Length:
        """"""Creates a new Length instance.

        Overrides the `new_val` method in Node for segments, where the value
        associated with a segment is its length.

        Returns:
            Length: A new instance of the Length class.
        """"""
        return Length()

class Line(Node):
    """"""Node of type Line, representing a geometrical line.

    Inherits from Node and adds specific functionality for lines in geometry.
    A line is an infinitely long straight path with no thickness.
    
    NOTE: If it had a finite length it would be a 'Segment'
    """"""

    def new_val(self) -> Direction:
        """"""Creates a new Direction instance.

        This method overrides the `new_val` method in the Node class,
        providing a specific implementation for Line, where the value
        associated with a line is its direction.

        Returns:
            Direction: A new instance of the Direction class.
        """"""
        return Direction()

    def why_coll(self, points: list[Point], level: int = None) -> list[Any]:
        """"""Explains why a set of points are collinear with this line.

        This method is used to determine the reasons behind the collinearity of a set of points with this line.
        It checks at various levels of abstraction as defined by 'level'.

        Args:
            points (list[Point]): A list of Point instances to check for collinearity.
            level (int, optional): The level of abstraction for checking collinearity. Defaults to infinity.

        Returns:
            list[Any] or None: A list of reasons for collinearity, or None if no collinearity is found.
        """"""

        # Default level is infinity if not specified.
        level = level or float('inf')

        # Create a list to hold groups of lines connected to each point.
        groups = []

        for p in points:
            # Extract lines connected to point `p` with dependencies below the specified level.
            group = [l for l, d in self.edge_graph[p].items() if d is None or d.level < level]

            # If no group is formed, return None as collinearity cannot be established.
            if not group:
                return None

            groups.append(group)

        # Initialize a variable to hold the minimum set of dependencies that explain the collinearity.
        min_deps = None

        for line in groups[0]:
            # For each line, find equal groups and their dependencies.
            deps, others = line.why_equal_groups(groups[1:], level)
            if deps is None:
                continue  # Skip if no dependencies are found.

            # Add dependencies to the list for each point-line pair.
            for p, o in zip(points, [line] + others):
                deps.append(self.edge_graph[p][o])

            # Update min_deps if it's None or found dependencies are fewer.
            if min_deps is None or len(deps) < len(min_deps):
                min_deps = deps

        # If no minimal dependencies are found, return None. Otherwise, return the found dependencies.
        if min_deps is None:
            return None

        # Return the subset of deps (paths) that is not None
        return [d for d in min_deps if d is not None]


class Circle(Node):
    """"""Node of type Circle, representing a geometrical circle.

    Inherits from Node and adds specific functionality for circles in geometry.
    A circle is a set of points in a plane that are all at a given distance (the radius) from a fixed point (the center).
    """"""

    def why_cyclic(self, points: list[Point], level: int = None) -> list[Any]:
        """"""Explains why a set of points are cyclic with respect to this circle.

        Determines the reasons behind the cyclic nature (all points lie on the circumference)
        of a set of points with respect to this circle.

        Args:
            points (list[Point]): A list of Point instances to check for cyclic nature.
            level (int, optional): The level of abstraction for checking cyclic nature. Defaults to infinity.

        Returns:
            list[Any] or None: A list of reasons for cyclic nature, or None if it's not cyclic.
        """"""
        # Default level is infinity if not specified.
        level = level or float('inf')

        # Create a list to hold groups of circles connected to each point.
        groups = []

        for p in points:
            # Extract circles connected to point `p` with dependencies below the specified level.
            group = [c for c, d in self.edge_graph[p].items() if d is None or d.level < level]

            # If no group is formed, return None as the cyclic nature cannot be established.
            if not group:
                return None
            groups.append(group)

        # Initialize a variable to hold the minimum set of dependencies that explain the cyclic nature.
        min_deps = None

        for circle in groups[0]:
            # For each circle, find equal groups and their dependencies.
            deps, others = circle.why_equal_groups(groups[1:], level)
            if deps is None:
                continue  # Skip if no dependencies are found.

            # Add dependencies to the list for each point-circle pair.
            for p, o in zip(points, [circle] + others):
                deps.append(self.edge_graph[p][o])

            # Update min_deps if it's None or found dependencies are fewer.
            if min_deps is None or len(deps) < len(min_deps):
                min_deps = deps

        # If no minimal dependencies are found, return None. Otherwise, return the found dependencies.
        if min_deps is None:
            return None

        # Return the subset of deps (paths) that is not None
        return [d for d in min_deps if d is not None]


class Angle(Node):
    """"""Node of type Angle, representing a geometrical angle.

    Inherits from Node and adds specific functionality for angles in geometry.
    """"""

    def new_val(self) -> Measure:
        """"""Creates a new Measure instance.

        Overrides the `new_val` method in Node for angles, where the value
        associated with an angle is its measure.

        Returns:
            Measure: A new instance of the Measure class.
        """"""
        return Measure()

    def set_directions(self, d1: Direction, d2: Direction) -> None:
        """"""Sets the directions forming the angle.

        Args:
            d1 (Direction): The first direction of the angle.
            d2 (Direction): The second direction of the angle.
        """"""
        self._d = d1, d2  # Store the directions as a tuple.

    @property
    def directions(self) -> tuple[Direction, Direction]:
        """"""Gets the directions forming the angle.

        Returns:
            tuple[Direction, Direction]: A tuple containing the two directions of the angle.
        """"""

        # The two directions
        #   - d1 (Direction): The first direction of the angle.
        #   - d2 (Direction): The second direction of the angle.
        d1, d2 = self._d

        # If either direction is None, return them as is.
        #   - Otherwise, get their representative directions.
        return (d1, d2) if d1 is None or d2 is None else (d1.rep(), d2.rep())



class Ratio(Node):
    """"""
    Node of type Ratio, representing a ratio of lengths or other measures.

    Inherits from Node and adds specific functionality for representing ratios in geometry.

    Example Usage:
        >>> ratio = Ratio()
    """"""

    def new_val(self) -> Value:
        """"""
        Creates a new Value instance.

        Overrides the `new_val` method in Node for ratios, where the value associated with a ratio
        is a generic value.

        Returns:
            Value: A new instance of the Value class.
        """"""
        return Value()

    def set_lengths(self, l1: Length, l2: Length) -> None:
        """"""
        Sets the lengths involved in the ratio.

        Args:
            l1 (Length): The first length in the ratio.
            l2 (Length): The second length in the ratio.
        """"""
        self._l = l1, l2  # Store the lengths as a tuple.

    @property
    def lengths(self) -> tuple[Length, Length]:
        """"""
        Gets the lengths involved in the ratio.

        Returns:
            tuple[Length, Length]: A tuple containing the two lengths in the ratio.
        """"""
        # The lengths
        #   - l1 (Length): The first length in the ratio.
        #   - l2 (Length): The second length in the ratio.
        l1, l2 = self._l

        # If either length is None, return them as is.
        #   - Otherwise, get their representative lengths.
        return (l1, l2) if l1 is None or l2 is None else (l1.rep(), l2.rep())


class Value(Node):
    """"""
    Node representing a generic value, used in various contexts like ratios.

    This class extends the Node class, providing a way to encapsulate a generic value.

    Example Usage:
        >>> value = Value()
    """"""
    # Inherits all behavior from Node without any modification.
    pass


def why_connect(*pairs: list[tuple[Node, Node]]) -> list[Any]:
    """"""
    Finds reasons for connection between pairs of nodes.

    This function takes pairs of nodes and for each pair, it determines why they are connected in the graph.
    It leverages the `why_connect` method of the `Node` class.

    Args:
        pairs (list[tuple[Node, Node]]): A list of tuples, each containing two nodes for which the connection
        reason is to be found.

    Returns:
        list[Any]: A list containing the reasons for connection for each pair of nodes.

    Example Usage:
        >>> node1 = Node()
        >>> node2 = Node()
        >>> why_connect((node1, node2))
        [connection_reason]
    """"""
    # Initialize an empty list to store the results.
    result = []

    # Iterate over each pair of nodes provided as input.
    for node1, node2 in pairs:
        # For each pair, call the 'why_connect' method on the first node (node1)
        #   - pass the second node (arg) to find out the connection reason
        #   - Append the result of 'why_connect' to the 'result' list.
        result += node1.why_connect(node2)

    # After processing all pairs, return the list of connection reasons.
    return result


def is_equiv(x: Node, y: Node, level: int = None) -> bool:
    """"""
    Determines if two nodes are equivalent at a certain level of abstraction.

    The function checks if two nodes, x and y, are equivalent. The level of abstraction for checking
    equivalence can be specified. If no level is given, it defaults to infinity, meaning it checks at all levels.

    Args:
        x (Node): The first node.
        y (Node): The second node.
        level (int, optional): The level of abstraction for the equivalence check. Defaults to None.

    Returns:
        bool: True if the nodes are equivalent at the specified level, False otherwise.

    Example Usage:
        >>> point1 = Point()
        >>> point2 = Point()
        >>> is_equiv(point1, point2)
        False
    """"""
    # If the 'level' argument is None, set it to infinity.
    #   - This indicates the check should consider all levels of abstraction.
    level = level or float('inf')

    # Call the 'why_equal' method on node 'x' with node 'y' and 'level'.
    #   - The method returns None if they ARE NOT equivalent
    #   - The method returns a non-None value if they ARE equivalent.
    # We then check this result and convert it into a boolean value
    return x.why_equal([y], level) is not None


def is_equal(x: Node, y: Node, level: int = None) -> bool:
    """"""
    Checks if two nodes are equal based on their values and equivalence.

    This function compares two nodes for equality. It first checks if they are the same instance,
    then verifies if their values (`_val` attributes) are not None and finally checks if their values are equal.
    If the values are equal, it additionally checks for their equivalence using `is_equiv`.

    Args:
        x (Node): The first node.
        y (Node): The second node.
        level (int, optional): The level of abstraction for equivalence check. Defaults to None.

    Returns:
        bool: True if the nodes are equal, False otherwise.

    Example Usage:
        >>> nodeA = Node()
        >>> nodeB = Node()
        >>> is_equal(nodeA, nodeB)
        False
    """"""
    # First, check if the two nodes are exactly the same instance.
    #  - If so they are equivalent (trivial case)
    if x == y:
        return True

    # Check if either of the nodes has a None value for '_val'.
    #   - If so, the nodes cannot be considered equal, so return False.
    if x._val is None or y._val is None:
        return False

    # Compare the '_val' attributes of the nodes.
    #   - If they are different, the nodes are not equal, so return False.
    if x.val != y.val:
        return False

    # If the '_val' attributes are the same...
    # We have to further check if the nodes are equivalent using 'is_equiv'
    #   - This is a deeper check to see if they are considered equal
    #   - It operates at a specific level of abstraction ('level').
    return is_equiv(x._val, y._val, level)


def why_equal(x: Node, y: Node, level: int = None) -> list[Any]:
    """"""
    Determines the reasons for the equality of two nodes at a specified level of abstraction.

    This function is crucial for understanding why two nodes in the graph are considered equal.
    It checks for direct equality, and if not directly equal, it checks the equality of their values.

    Args:
        x (Node): The first node to compare.
        y (Node): The second node to compare.
        level (int, optional): The level of abstraction for checking equality. Defaults to None (all levels).

    Returns:
        list[Any] or None: A list of reasons for equality if they are equal; None otherwise.

    Example Usage:
        >>> node1 = Node()
        >>> node2 = Node()
        >>> why_equal(node1, node2)
        None  # or [reasons] if they are equal
    """"""

    # First, check if the two nodes are exactly the same instance.
    #  - If so they are equivalent (trivial case)
    if x == y:
        return []

    # Check if either node has a Falsey value
    #   - If so, the nodes cannot be considered equal, so return None.
    if not x._val or not y._val:
        return None

    # Check if the values of the nodes are the same
    #  - If so, they are equivalent.
    if x._val == y._val:
        return []

    # If values are not the same, check for equality at a deeper level using 'why_equal'.
    return x._val.why_equal([y._val], level)


def val_type(x: Node) -> Type[Node]:
    """"""
    Determines the type of value associated with a given node.

    This function helps to find out what kind of value a node represents, such as direction, length, etc.

    Args:
        x (Node): The node whose value type is to be determined.

    Returns:
        Type[Node]: The type of value associated with the node.

    Example Usage:
        >>> node = Line()
        >>> val_type(node)
        <class 'Direction'>
    """"""

    # Determine the value type based on the node's class.
    # The function can be extended to include other node types and their associated value types.

    if isinstance(x, Line):
        # If 'x' is an instance of the Line class, return the Direction class.
        # This indicates that for a Line node, the associated value type is Direction.
        return Direction

    if isinstance(x, Segment):
        # If 'x' is an instance of the Segment class, return the Length class.
        # This indicates that for a Segment node, the associated value type is Length.
        return Length

    if isinstance(x, Angle):
        # If 'x' is an instance of the Angle class, return the Measure class.
        # This indicates that for an Angle node, the associated value type is Measure.
        return Measure

    if isinstance(x, Ratio):
        # If 'x' is an instance of the Ratio class, return the Value class.
        # This indicates that for a Ratio node, the associated value type is Value.
        return Value
    
    
def name_map(struct: Any) -> Any:
    """"""
    Recursively maps a data structure of nodes to their names.

    This utility function is useful for converting complex structures containing nodes
    into a more readable format by using the names of the nodes.

    Args:
        struct (Any): A data structure (like list, tuple, set, dict) containing nodes.

    Returns:
        Any: A similar structure where nodes are replaced with their names.

    Example Usage:
        >>> my_structure = [Node(name=""A""), Node(name=""B"")]
        >>> name_map(my_structure)
        [""A"", ""B""]
    """"""

    # Handle different types of data structures recursively.
    if isinstance(struct, list):
        # If 'struct' is a list, apply 'name_map' to each element in the list.
        # This creates a new list
        #   - Each element is the result of applying 'name_map' to the original elements.
        return [name_map(x) for x in struct]

    elif isinstance(struct, tuple):
        # If 'struct' is a tuple, apply 'name_map' to each element in the tuple.
        # This creates a new tuple
        #   - Each element is the result of applying 'name_map' to the original elements.
        return tuple([name_map(x) for x in struct])

    elif isinstance(struct, set):
        # If 'struct' is a set, apply 'name_map' to each element in the set.
        # This creates a new set
        #   - Each element is the result of applying 'name_map' to the original elements.
        return set([name_map(x) for x in struct])

    elif isinstance(struct, dict):
        # If 'struct' is a dictionary, apply 'name_map' to both keys and values.
        # This creates a new dictionary
        #   - Each key-value pair is the result of applying 'name_map' to the original pairs.
        return {name_map(key): name_map(value) for key, value in struct.items()}

    else:
        # If 'struct' is not a list, tuple, set, or dictionary, it's assumed to be a single node.
        #   - We then Use 'getattr' to get the 'name' attribute of the node.
        #     - If the node does not have a 'name', return an empty string.
        #     - Otherwise we return the respective name from the 'name' attribute
        return getattr(struct, 'name', '')


def bfs_backtrack(
        root: Node, leafs: list[Node], parent: dict[Node, Node]
) -> list[Any]:
    """"""
    Backtracks from leaf nodes to the root node in a BFS traversal.

    Given a root node, a list of leaf nodes, and a parent mapping (as typically generated by a BFS traversal),
    this function reconstructs the path from each leaf node back to the root node. It stops backtracking
    when it reaches the root node or any node that has already been backtracked.

    Args:
        root (Node): The root node of the BFS traversal.
        leafs (list[Node]): A list of leaf nodes to backtrack from.
        parent (dict[Node, Node]): A dictionary mapping each node to its parent in the BFS traversal.

    Returns:
        list[Any]: A list containing the paths (in terms of edges) backtracked from the leafs to the root.

    Raises:
        None: This function does not explicitly raise any exceptions, but may implicitly raise if
              there are inconsistencies in the input data.

    Example Usage:
        >>> root_node = Node()
        >>> leaf_nodes = [Node(), Node()]
        >>> parent_map = {leaf_nodes[0]: root_node, leaf_nodes[1]: root_node}
        >>> bfs_backtrack(root_node, leaf_nodes, parent_map)
        [path1, path2]
    """"""
    # Create a set 'backtracked' and add the 'root' node to it.
    #   - This set will keep track of visited nodes during backtracking.
    backtracked = {root}

    # Initialize a list to store the dependencies (paths) found during backtracking.
    deps = []

    # Iterate over each node in the 'leafs' list.
    for node in leafs:
        # If a leaf node is None, this is an invalid case, so return None.
        if node is None:
            return None

        # If the current node is already in the 'backtracked' set, skip to the next node.
        if node in backtracked:
            continue

        # If the current node does not have a parent in the 'parent' dictionary...
        #   - This means there's a missing link in the path, so return None.
        if node not in parent:
            return None

        # Continue backtracking until break condition
        #   - This condition is that a node is already in the 'backtracked' set
        while node not in backtracked:
            # Add the current node to the 'backtracked' set to mark it as visited.
            backtracked.add(node)

            # Append the dependency (edge) between the current node and its parent to the 'deps' list.
            deps.append(node.merge_graph[parent[node]])

            # Move to the parent of the current node for the next iteration.
            node = parent[node]

    # After processing all leaf nodes, return the list of dependencies (paths) found.
    return deps


def get_lines_thru_all(*points: list[Point]) -> list[Line]:
    """"""
    Retrieves all lines that pass through a given set of points.

    This function is used to find all Line nodes in the graph that are connected to all
    the given Point nodes. It's a way to discover common lines shared by multiple points.

    Args:
        points (list[Point]): Variable number of Point instances.

    Returns:
        list[Line]: A list of Line instances that pass through all the given points.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> lines = get_lines_thru_all(point1, point2, point3)
    """"""

    # Default dictionary to count lines through each point.
    #   - A default dict is one that when initialized assumes the value as defined (0 in this case)
    line2count = defaultdict(lambda: 0)

    # Get the set of all unique points
    points = set(points)

    # Iterate over each point (unique) and count the lines connected to each point.
    for p in points:
        for l in p.neighbors(Line):
            line2count[l] += 1

    # Return the lines that are connected to all points.
    return [l for l, count in line2count.items() if count == len(points)]


def line_of_and_why(points: list[Point], level: int = None) -> tuple[Line, list[Any]]:
    """"""
    Determines the line on which given points are collinear and explains why.

    This function tries to find a Line node that all the given Point nodes are collinear with.
    Additionally, it provides the reasons for their collinearity.

    Args:
        points (list[Point]): A list of Point instances.
        level (int, optional): The level of abstraction for checking collinearity. Defaults to None.

    Returns:
        tuple[Line, list[Any]]: A tuple containing the Line instance and a list of reasons for collinearity,
        or (None, None) if no such line exists.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> line, reasons = line_of_and_why([point1, point2, point3])
    """"""
    # Find all lines that pass through all given points.
    for l0 in get_lines_thru_all(*points):

        # Check equivalent lines for collinearity.
        for l in l0.equivs():

            # Confirm all points are in the edge graph of the line.
            if all([p in l.edge_graph for p in points]):

                # Extract end points of the line and combine with the given points.
                x, y = l.points
                colls = list({x, y} | set(points))

                # Determine the reasons for collinearity.
                why = l.why_coll(colls, level)

                # If there is a valid reason then we return the line and the reason
                if why is not None:
                    return l, why

    # Return None if no line and reasons are found.
    return None, None


def get_circles_thru_all(*points: list[Point]) -> list[Circle]:
    """"""
    Retrieves all circles that pass through a given set of points.

    This function finds all Circle nodes in the graph that are connected to all the given Point nodes.
    It's used to identify common circles that encompass multiple points.

    Args:
        points (list[Point]): A variable number of Point instances.

    Returns:
        list[Circle]: A list of Circle instances that pass through all the given points.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> circles = get_circles_thru_all(point1, point2, point3)
    """"""

    # Initialize a dictionary to count the number of circles passing through each point.
    circle2count = defaultdict(lambda: 0)

    # Convert to set to ensure uniqueness of each point
    points = set(points)

    # Iterate through each point.
    for p in points:
        # For each circle connected to the point, increment its count.
        for c in p.neighbors(Circle):
            circle2count[c] += 1

    # Return circles that pass through all points.
    return [c for c, count in circle2count.items() if count == len(points)]


def circle_of_and_why(points: list[Point], level: int = None) -> tuple[Circle, list[Any]]:
    """"""
    Determines the circle on which given points are concyclic and explains why.

    This function finds a Circle node that encompasses all the given Point nodes and provides
    reasons for their concyclicity (all points lying on the circumference of the circle).

    Args:
        points (list[Point]): A list of Point instances.
        level (int, optional): The level of abstraction for checking concyclicity. Defaults to None.

    Returns:
        tuple[Circle, list[Any]]: A tuple containing the Circle instance and a list of reasons for concyclicity,
        or (None, None) if no such circle exists.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> circle, reasons = circle_of_and_why([point1, point2, point3])
    """"""

    # Find all circles that pass through all given points.
    for c0 in get_circles_thru_all(*points):

        # Check equivalent circles for concyclicity.
        for c in c0.equivs():

            # Ensure all points are in the edge graph of the circle.
            if all([p in c.edge_graph for p in points]):

                # Create a list of unique points.
                cycls = list(set(points))

                # Determine the reasons for concyclicity.
                why = c.why_cyclic(cycls, level)

                # If a valid reason is found then we return the circle and reason
                if why is not None:
                    return c, why

    # Return None if no circle and reasons are found.
    return None, None


def all_angles(d1: Direction, d2: Direction, level: int = None) -> tuple[Angle, list[Direction], list[Direction]]:
    """"""
    Generates all angles formed by two directions up to a certain level of abstraction.

    Args:
        d1 (Direction): The first direction.
        d2 (Direction): The second direction.
        level (int, optional): The level of abstraction. Defaults to infinity.

    Yields:
        tuple[Angle, list[Direction], list[Direction]]: A tuple with an Angle instance and lists of equivalent
        directions for d1 and d2.

    Example Usage:
        >>> direction1, direction2 = Direction(), Direction()
        >>> for angle, d1_equivs, d2_equivs in all_angles(direction1, direction2):
        >>>     print(angle, d1_equivs, d2_equivs)
    """"""

    # Default level is infinity if not specified.
    level = level or float('inf')

    # Get all equivalent directions for d1 up to the specified level.
    d1s = d1.equivs_upto(level)

    # Get all equivalent directions for d2 up to the specified level.
    d2s = d2.equivs_upto(level)

    # Iterate over all angles connected to the representative direction of d1.
    for ang in d1.rep().neighbors(Angle):

        # Get the directions forming the angle.
        d1_, d2_ = ang._d

        # Yield the angle and equivalent directions if they match d1 and d2.
        if d1_ in d1s and d2_ in d2s:
            yield ang, d1s, d2s


def all_ratios(d1, d2, level=None) -> tuple[Angle, list[Direction], list[Direction]]:
    """"""
    Generates all ratios formed by two values up to a certain level of abstraction.

    Args:
        d1 (Node): The first value.
        d2 (Node): The second value.
        level (int, optional): The level of abstraction. Defaults to infinity.

    Yields:
        tuple[Angle, list[Direction], list[Direction]]: A tuple with a Ratio instance and lists of equivalent
        values for d1 and d2.

    Example Usage:
        >>> value1, value2 = Value(), Value()
        >>> for ratio, v1_equivs, v2_equivs in all_ratios(value1, value2):
        >>>     print(ratio, v1_equivs, v2_equivs)
    """"""
    level = level or float('inf')  # Default level is infinity if not specified.
    d1s = d1.equivs_upto(level)  # Get all equivalent values for d1 up to the specified level.
    d2s = d2.equivs_upto(level)  # Get all equivalent values for d2 up to the specified level.

    # Iterate over all ratios connected to the representative value of d1.
    for rat in d1.rep().neighbors(Ratio):
        d1_, d2_ = rat._l  # Get the values forming the ratio.

        # Yield the ratio and equivalent values if they match d1 and d2.
        if d1_ in d1s and d2_ in d2s:
            yield rat, d1s, d2s


# This dictionary defines a ranking for different types of nodes.
#   - It's used to prioritize or differentiate between node types
#   - I'm not sure why yet...
RANKING = {
    Point: 0,
    Line: 1,
    Segment: 2,
    Circle: 3,
    Direction: 4,
    Length: 5,
    Angle: 6,
    Ratio: 7,
    Measure: 8,
    Value: 9,
}
<br>

**Let's make a fake Geometry module so we can spoof the import**
import types

# Create the module Geometry as gm
gm = types.ModuleType('gm')

# Add Node class to gm
gm.Node = Node

# Add other classes to gm
gm.Point = Point
gm.Direction = Direction
gm.Measure = Measure
gm.Length = Length
gm.Segment = Segment
gm.Line = Line
gm.Circle = Circle
gm.Angle = Angle
gm.Ratio = Ratio
gm.Value = Value

# Add functions to gm
gm.why_connect = why_connect
gm.is_equiv = is_equiv
gm.is_equal = is_equal
gm.why_equal = why_equal
gm.val_type = val_type
gm.name_map = name_map
gm.bfs_backtrack = bfs_backtrack
gm.get_lines_thru_all = get_lines_thru_all
gm.line_of_and_why = line_of_and_why
gm.get_circles_thru_all = get_circles_thru_all
gm.circle_of_and_why = circle_of_and_why
gm.all_angles = all_angles
gm.all_ratios = all_ratios
<br>

<a id=""problem""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""problem"">5&nbsp;&nbsp;PROBLEM &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.1 <code>PROBLEM.PY</code> FILE <b>IMPORTS</b></h3>
<hr>

We can see by the imports that we are mostly dealing the **`geometry`** submodule, the **`pretty`** submodule and a few additional packages (i.e. <a href=""https://docs.python.org/3/library/fractions.html"">`Fractions`</a>, `NumPy`, `SciPy`, etc.)

We also include the license information here as found within the original file:
* https://github.com/google-deepmind/alphageometry/blob/main/ar.py
* **Apache License, Version 2.0**
# Copyright 2023 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

""""""Implements objects to represent problems, theorems, proofs, traceback.""""""

from __future__ import annotations

from collections import defaultdict  # pylint: disable=g-importing-member
from typing import Any

# import geometry as gm --> defined above
# import pretty as pt --> defined below
# pylint: disable=protected-access
# pylint: disable=unused-variable
# pylint: disable=unused-argument
# pylint: disable=unused-assignment
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.2 <code><b>PRETTY.PY</b></code> FILE - THE <b>PRETTY</b> HELPER FUNCTIONS</h3>
<hr>

Utilities for string manipulation in the DSL.
# This dictionary maps single character symbols to their respective geometric meanings.
#   - Each key is a character that represents a geometric concept (like 'T' for perpendicular)
#   - The corresponding value is a string that describes the concept in a more readable format.
MAP_SYMBOL = {
    'T': 'perp',      # Perpendicular
    'P': 'para',      # Parallel
    'D': 'cong',      # Congruent
    'S': 'simtri',    # Similar Triangles
    'I': 'circle',    # Circle
    'M': 'midp',      # Midpoint
    'O': 'cyclic',    # Concyclic points (lying on the same circle)
    'C': 'coll',      # Collinear
    '^': 'eqangle',   # Equal Angle
    '/': 'eqratio',   # Equal Ratio
    '%': 'eqratio',   # Equal Ratio (alternative symbol)
    '=': 'contri',    # Congruent Triangles
    'X': 'collx',     # Collinear (extended)
    'A': 'acompute',  # Angle computation
    'R': 'rcompute',  # Ratio computation
    'Q': 'fixc',      # Fixed constant
    'E': 'fixl',      # Fixed line
    'V': 'fixb',      # Fixed bisector
    'H': 'fixt',      # Fixed tangent
    'Z': 'fixp',      # Fixed point
    'Y': 'ind',       # Independent variable or parameter
}


def map_symbol(c: str) -> str:
    """"""
    Maps a single character representing a geometric concept to a more readable string format.

    Args:
        c (str): A single character symbol representing a geometric concept.

    Returns:
        str: A more readable string representation of the geometric concept.

    Raises:
        KeyError: If the symbol `c` is not found in the MAP_SYMBOL dictionary.

    Example Usage:
        >>> map_symbol('T')
        'perp'
    """"""
    return MAP_SYMBOL[c]


def map_symbol_inv(c: str) -> str:
    """"""
    Maps a geometric concept in string format back to its corresponding single character symbol.

    Args:
        c (str): A string representing a geometric concept.

    Returns:
        str: The corresponding single character symbol.

    Raises:
        KeyError: If the string `c` does not have a corresponding symbol in the MAP_SYMBOL dictionary.

    Example Usage:
        >>> map_symbol_inv('perp')
        'T'
    """"""
    # This creates a reverse mapping of the MAP_SYMBOL dictionary
    #   - i.e. the Keys become Values and viceaversa.
    return {v: k for k, v in MAP_SYMBOL.items()}[c]


def _gcd(x: int, y: int) -> int:
    """"""
    Computes the greatest common divisor (GCD) of two integers using the Euclidean algorithm.

    Args:
        x (int): The first integer.
        y (int): The second integer.

    Returns:
        int: The greatest common divisor of `x` and `y`.

    Example Usage:
        >>> _gcd(8, 12)
        4
    """"""
    # The Euclidean algorithm iteratively applies the 'modulus' operation until y becomes zero.
    #   - At that point, x holds the greatest common divisor.
    while y:
        x, y = y, x % y
    return x

def simplify(n: int, d: int) -> tuple[int, int]:
    """"""
    Simplifies a fraction by dividing both the numerator and denominator by their GCD.

    Args:
        n (int): The numerator of the fraction.
        d (int): The denominator of the fraction.

    Returns:
        tuple[int, int]: A tuple containing the simplified numerator and denominator.

    Raises:
        ZeroDivisionError: If the denominator `d` is zero.

    Example Usage:
        >>> simplify(8, 12)
        (2, 3)
    """"""

def pretty2r(a: str, b: str, c: str, d: str) -> str:
    """"""
    Formats a set of four points for a RATIO (r) comparison. 
    It ensures that the first point of each pair is not the common point in the RATIO (r) comparison.

    Args:
        a, b, c, d (str): Four points in a geometric context.

    Returns:
        str: A formatted string representing the ratio of segments AB:CD.

    Example Usage:
        >>> pretty2r('A', 'B', 'C', 'B')
        'B A C B'
    """"""
    # Swap a and b if b is the same as c or d. This is done to standardize the format for comparison.
    if b in (c, d):
        a, b = b, a

    # If a and d are the same, swap c and d to maintain the format.
    if a == d:
        c, d = d, c
    
    return f'{a} {b} {c} {d}'


def pretty2a(a: str, b: str, c: str, d: str) -> str:
    """"""
    Formats a set of four points for an ANGLE (a) comparison. 
    It ensures that the first point of each pair is not the common point in the ANGLE (a) comparison.

    Args:
        a, b, c, d (str): Four points in a geometric context.

    Returns:
        str: A formatted string representing the angles ∠AB and ∠CD for comparison.

    Example Usage:
        >>> pretty2a('A', 'B', 'C', 'B')
        'B A C B'
    """"""
    # Swap a and b if b is the same as c or d. This is done to standardize the format for comparison.
    if b in (c, d):
        a, b = b, a
    
    # If a and d are the same, swap c and d to maintain the format.
    if a == d:
        c, d = d, c

    return f'{a} {b} {c} {d}'


def pretty_angle(a: str, b: str, c: str, d: str) -> str:
    """"""
    Formats a representation of an angle.
    Specifically for the case where the points form an angle (like ∠ABC). 
    It uses Unicode characters (\u2220) to represent the angle symbol.

    Args:
        a, b, c, d (str): Four points in a geometric context.

    Returns:
        str: A Unicode string representing the angle. For example, ∠ABC or ∠(AB-CD).

    Example Usage:
        >>> pretty_angle('A', 'B', 'C', 'D')
        '∠(ABC-BCD)'
    """"""
    # Ensure the format aligns with the standard representation of an angle.
    #  - i.e. We swap a and b if b is the same as c or d. 
    #         This is done to standardize the format for comparison.
    if b in (c, d):
        a, b = b, a
    
    # If a and d are the same, swap c and d to maintain the format.
    if a == d:
        c, d = d, c

    # Return the formatted angle, using the Unicode character for angle (∠).
    if a == c:
        # Simple angle like ∠BAD.
        return f'\u2220{b}{a}{d}'  
    
    # More complex angle representation like ∠(AB-CD).
    return f'\u2220({a}{b}-{c}{d})'  


def pretty_nl(name: str, args: list[str]) -> str:
    """"""""
      Formats a geometric predicate into a natural language representation.

      Args:
          name (str): The name of the geometric predicate.
          args (list[str]): A list of arguments associated with the predicate.

      Returns:
          str: A natural language representation of the geometric predicate.

      Example Usage:
          >>> pretty_nl('coll', ['A', 'B', 'C'])
          'A,B,C are collinear'

      Notes:
          - The function handles a variety of geometric predicates, each requiring a different format.
          - This function is central to converting raw geometric data into a form that's easily readable.
      """"""

    # Handle the 'aconst' predicate, which represents a constant angle.
    if name == 'aconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # Format the angle using `pretty_angle`.
        return f'{pretty_angle(a, b, c, d)} = {y}'

    # Handle the 'rconst' predicate, which represents a constant ratio.
    if name == 'rconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # Format the ratio using `pretty2r`.
        return f'{a}{b}:{c}{d} = {y}'

    # Handle the 'acompute' predicate, which represents an angle computation.
    if name == 'acompute':
        # Unpack the arguments.
        a, b, c, d = args
        # Format the angle using `pretty_angle`.
        return f'{pretty_angle(a, b, c, d)}'

    # Handle the 'coll' predicate, which represents a collinear relationship.
    if name in ['coll', 'C']:
        # Format the collinear relationship as a comma-separated list with the words ' are collinear'.
        return '' + ','.join(args) + ' are collinear'

    # Handle the 'collx' predicate, which represents a collinear (extended) relationship.
    if name == 'collx':
        # Format the collinear relationship as a comma-separated list with the words ' are collinear'.
        return '' + ','.join(list(set(args))) + ' are collinear'

    # Handle the 'cyclic' predicate, which represents concyclic points (lying on the same circle)
    if name in ['cyclic', 'O']:
        # Format the cyclic relationship as a comma-separated list with the words ' are concyclic'.
        return '' + ','.join(args) + ' are concyclic'

    # Handle the 'midp' predicate, which represents a midpoint relationship.
    if name in ['midp', 'midpoint', 'M']:
        # Unpack the arguments.
        x, a, b = args
        # Format the midpoint relationship using a string.
        return f'{x} is midpoint of {a}{b}'

    # Handle the 'eqangle' (and 'eqangle6' amd '^' representations) predicate, which represents an equal angle relationship.
    if name in ['eqangle', 'eqangle6', '^']:
        # Unpack the arguments.
        a, b, c, d, e, f, g, h = args
        # Format the equal angle relationship using `pretty_angle`.
        return f'{pretty_angle(a, b, c, d)} = {pretty_angle(e, f, g, h)}'

    # Handle the 'eqratio' (and 'eqratio6' amd '/' representations) predicate, which represents an equal ratio
    # relationship.
    if name in ['eqratio', 'eqratio6', '/']:
        # Format the equal ratio relationship using string formatting
        return '{}{}:{}{} = {}{}:{}{}'.format(*args)

    # Handle the 'eqratio3' predicate, which represents an equal ratio relationship.
    if name == 'eqratio3':
        # Unpack the arguments.
        a, b, c, d, o, o = args  # pylint: disable=redeclared-assigned-name
        # Format the equal ratio relationship as space delimited with prefix symbol 'S'.
        return f'S {o} {a} {b} {o} {c} {d}'

    # Handle the 'cong' (and 'D' representation) predicate, which represents a congruent relationship.
    if name in ['cong', 'D']:
        # Unpack the arguments.
        a, b, c, d = args
        # Return the congruent relationship as a string.
        return f'{a}{b} = {c}{d}'

    # Handle the 'perp' (and 'T' representation) predicate, which represents a perpendicular relationship.
    if name in ['perp', 'T']:
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args
            # Return the perpendicular relationship as a string with the angle symbol.
            return f'{ab} \u27c2 {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the perpendicular relationship as a string with the angle symbol.
        return f'{a}{b} \u27c2 {c}{d}'

    # Handle the 'para' (and 'P' representation) predicate, which represents a parallel relationship.
    if name in ['para', 'P']:
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args
            # Return the parallel relationship as a string with the parallel symbol.
            return f'{ab} \u2225 {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the parallel relationship as a string with the parallel symbol.
        return f'{a}{b} \u2225 {c}{d}'

    # Handle the 'simtri2' (and 'simtri' and 'simtri*' representations) predicate, which represents a similar
    if name in ['simtri2', 'simtri', 'simtri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the similar triangle relationship as a string with the triangle symbol.
        return f'\u0394{a}{b}{c} is similar to \u0394{x}{y}{z}'

    # Handle the 'contri2' (and 'contri' and 'contri*' representations) predicate, which represents a congruent
    if name in ['contri2', 'contri', 'contri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the congruent triangle relationship as a string with the triangle symbol.
        return f'\u0394{a}{b}{c} is congruent to \u0394{x}{y}{z}'

    # Handle the 'circle' (and 'I' representation) predicate, which represents a circle relationship.
    if name in ['circle', 'I']:
        # Unpack the arguments.
        o, a, b, c = args
        # Return the circle relationship as a string with the circle symbol.
        return f'{o} is the circumcenter of \\Delta {a}{b}{c}'

    # Handle the 'foot' predicate, which represents a foot relationship.
    if name == 'foot':
        # Unpack the arguments.
        a, b, c, d = args
        # Return the foot relationship as a string with the foot symbol.
        return f'{a} is the foot of {b} on {c}{d}'


def pretty(txt: str) -> str:
    """"""
    Formats a geometric predicate string into a more readable form, either as a symbol or in natural language.

    Args:
        txt (str): A string representing a geometric predicate and its arguments.

    Returns:
        str: A formatted string either in symbolic or natural language form.

    Example Usage:
        >>> pretty('coll A B C')
        'C A B C are collinear'

    Notes:
        - This function decides whether to use symbolic or natural language format based on the predicate.
        - It's a higher-level formatter that either directly formats the string or delegates to `pretty_nl`.
    """"""

    # Check if the input is a string and split it into words for further processing.
    if isinstance(txt, str):
        txt = txt.split(' ')

    # Extract the predicate name and its arguments.
    name, *args = txt

    # Handle various predicates, each requiring a unique formatting approach.
    if name == 'ind':
        # 'ind' represents an independent variable or parameter.
        return 'Y ' + ' '.join(args)

    # These predicates represent fixed geometric elements like constants, lines, bisectors, etc.
    if name in ['fixc', 'fixl', 'fixb', 'fixt', 'fixp']:
        # The arguments are joined with a space and prefixed with the corresponding symbol.    
        return map_symbol_inv(name) + ' ' + ' '.join(args)

    # 'acompute' represents an angle computation.
    if name == 'acompute':
        
        # The arguments are joined with a space and prefixed with 'A'.
        return 'A ' + ' '.join(args)

    # 'rcompute' represents a ratio computation.
    if name == 'rcompute':
        # The arguments are joined with a space and prefixed with 'R'.
        return 'R ' + ' '.join(args)

    # 'aconst' represents a constant angle.
    if name == 'aconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # It uses `pretty2a` for formatting and is prefixed with '^'.
        return f'^ {pretty2a(a, b, c, d)} {y}'

    # 'rconst' represents a constant ratio.
    if name == 'rconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # It uses `pretty2r` for formatting and is prefixed with '/'.
        return f'/ {pretty2r(a, b, c, d)} {y}'
    
    # 'coll' represents a collinear relationship.
    if name == 'coll':
        # It's prefixed with 'C' and the arguments are joined with a space.
        return 'C ' + ' '.join(args)
    
    # 'collx' represents a collinear (extended) relationship.
    if name == 'collx':
        # It's prefixed with 'X' and the arguments are joined with a space.
        return 'X ' + ' '.join(args)
    
    # 'cyclic' represents a cyclic relationship.
    if name == 'cyclic':
        # It's prefixed with 'O' and the arguments are joined with a space.
        return 'O ' + ' '.join(args)
    
    # 'midp' represents a midpoint relationship.
    if name in ['midp', 'midpoint']:
        # Unpack the arguments.
        x, a, b = args
        # It's prefixed with 'M' and the arguments are joined with a space.
        return f'M {x} {a} {b}'
    
    # 'eqangle' (and 'eqangle6' and '^') represents an equal angle relationship.
    if name == 'eqangle':
        # Unpack the arguments.
        a, b, c, d, e, f, g, h = args
        # It uses `pretty2a` for formatting and is prefixed with '^'.
        return f'^ {pretty2a(a, b, c, d)} {pretty2a(e, f, g, h)}'
    
    # 'eqratio' (and 'eqratio6' and '/') represents an equal ratio relationship.
    if name == 'eqratio':
        # It uses `pretty2r` for formatting and is prefixed with '/'.
        a, b, c, d, e, f, g, h = args
        # Return the equal ratio relationship as a string with the ratio symbol.
        return f'/ {pretty2r(a, b, c, d)} {pretty2r(e, f, g, h)}'
    
    # 'eqratio3' represents an equal ratio relationship.
    if name == 'eqratio3':
        # Unpack the arguments.
        a, b, c, d, o, o = args  # pylint: disable=redeclared-assigned-name
        # Return the equal ratio relationship as a string with the ratio symbol.
        return f'S {o} {a} {b} {o} {c} {d}'
    
    # 'cong' (and 'D') represents a congruent relationship.
    if name == 'cong':
        # Unpack the arguments.
        a, b, c, d = args
        # Return the congruent relationship as a string with the congruent symbol.
        return f'D {a} {b} {c} {d}'
    
    # 'perp' (and 'T') represents a perpendicular relationship.
    if name == 'perp':
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args  
            # Return the perpendicular relationship as a string with the perpendicular symbol.
            return f'T {ab} {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the perpendicular relationship as a string with the perpendicular symbol.
        return f'T {a} {b} {c} {d}'
    
    # 'para' (and 'P') represents a parallel relationship.
    if name == 'para':
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args  
            # Return the parallel relationship as a string with the parallel symbol.
            return f'P {ab} {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the parallel relationship as a string with the parallel symbol.
        return f'P {a} {b} {c} {d}'
    
    # 'simtri2' (and 'simtri' and 'simtri*') represents a similar triangle relationship.
    if name in ['simtri2', 'simtri', 'simtri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the similar triangle relationship as a string with the triangle symbol.
        return f'S {a} {b} {c} {x} {y} {z}'
    
    # 'contri2' (and 'contri' and 'contri*') represents a congruent triangle relationship.
    if name in ['contri2', 'contri', 'contri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the congruent triangle relationship as a string with the triangle symbol.
        return f'= {a} {b} {c} {x} {y} {z}'
    
    # 'circle' (and 'I') represents a circle relationship.
    if name == 'circle':
        # Unpack the arguments.
        o, a, b, c = args
        # Return the circle relationship as a string with the circle symbol.
        return f'I {o} {a} {b} {c}'
    
    # 'foot' represents a foot relationship.
    if name == 'foot':
        # Unpack the arguments.
        a, b, c, d = args
        # Return the foot relationship as a string with the foot symbol.
        return f'F {a} {b} {c} {d}'
    
    # If the predicate is not handled above, we format it as a space-delimited string.
    return ' '.join(txt)
<br>

**Let's make a fake Pretty module (**`pt`**) so we can spoof the import**
import types

# Create a new module object
pt = types.ModuleType('pt') # pretty as pt

# Add functions to pt
pt.map_symbol = map_symbol
pt.map_symbol_inv = map_symbol_inv
pt._gcd = _gcd
pt.simplify = simplify
pt.pretty2r = pretty2r
pt.pretty2a = pretty2a
pt.pretty_angle = pretty_angle
pt.pretty_nl = pretty_nl
pt.pretty = pretty
# Importing necessary functions
from math import gcd

# MAP_SYMBOL dictionary
print(f""\n`MAP_SYMBOL` Dictionary:"")
for k,v in MAP_SYMBOL.items(): print(f""\t{k} --> {v}"")

# map_symbol function
print(f""\n\n`map_symbol` function\n\tmap_symbol('T') returns --> {map_symbol('T')}\n"")

# map_symbol_inv function
print(f""`map_symbol_inv` function\n\tmap_symbol_inv('perp') returns --> {map_symbol_inv('perp')}\n"")

# _gcd function
print(f""`_gcd` function\n\t_gcd(8, 12) returns --> {_gcd(8, 12)}\n"")

# simplify function
print(f""`simplify` function\n\tsimplify(8, 12) returns --> {simplify(8, 12)}\n"")

# pretty2r function
print(f""`pretty2r` function\n\tpretty2r('A', 'B', 'C', 'B') returns --> {pretty2r('A', 'B', 'C', 'B')}\n"")

# pretty2a function
print(f""`pretty2a` function\n\tpretty2a('A', 'B', 'C', 'B') returns --> {pretty2a('A', 'B', 'C', 'B')}\n"")

# pretty_angle function
print(f""`pretty_angle` function\n\tpretty_angle('A', 'B', 'C', 'D') returns --> {pretty_angle('A', 'B', 'C', 'D')}\n"")

# pretty_nl function
print(f""`pretty_nl` function\n\tpretty_nl('coll', ['A', 'B', 'C']) returns --> {pretty_nl('coll', ['A', 'B', 'C'])}\n"")

# pretty function - Example 1
example_1 = ""coll A B C""
print(f""`pretty` function - Example 1\n\tpretty('{example_1}') returns --> {pretty(example_1)}\n"")

# pretty function - Example 2
example_2 = ""perp AB CD""
print(f""`pretty` function - Example 2\n\tpretty('{example_2}') returns --> {pretty(example_2)}\n"")

# pretty function - Example 3
example_3 = ""simtri A B C X Y Z""
print(f""`pretty` function - Example 3\n\tpretty('{example_3}') returns --> {pretty(example_3)}\n"")
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.3 <code><b>PROBLEM.PY</b></code> FILE - BASIC <b>FUNCTIONS</b></h3>
<hr>

reshape, isint, _gcd, simplify, hashed, and hashed_txt

def reshape(l: list[Any], n: int = 1) -> list[list[Any]]:
    """"""
    Reshapes a list into a list of lists with each sublist containing n elements.

    Args:
        l (list[Any]): The original list to be reshaped.
        n (int): The number of elements each sublist should contain.

    Returns:
        list[tuple[Any]]: The reshaped list of tuples.

    Raises:
        AssertionError: If the original list's length is not a multiple of n.

    Example Usage:
        >>> reshape([1, 2, 3, 4, 5, 6], 3)
        [(1, 3, 5), (2, 4, 6)]

    Note:
        The function asserts that the length of the list l must be divisible by n.
        It then distributes the elements of l into n sublists in a round-robin fashion.
    """"""
    # Ensures the list can be evenly divided into n parts.
    assert len(l) % n == 0  
    
    # Initializes n empty sublists.
    columns = [[] for i in range(n)]  
    
    # Distributes elements into the sublists.
    for i, x in enumerate(l):
        columns[i % n].append(x)  
        
    # Zips the sublists to group nth elements together.
    return zip(*columns)


def isint(x: str) -> bool:
    """"""
    Checks if a string can be safely converted to an integer.

    Args:
        x (str): The string to be checked.

    Returns:
        bool: True if x can be converted to an integer, False otherwise.

    Example Usage:
        >>> isint(""123"")
        True
        >>> isint(""abc"")
        False

    Note:
        This function uses a try-except block to attempt conversion and catch any exceptions.
    """"""
    # Attempts to convert x to an integer.
    try:
        int(x)  
        return True
    
    # Catches any exception if conversion fails.
    except:  # pylint: disable=bare-except
        return False
    

def _gcd(x: int, y: int) -> int:
    """"""
    Computes the greatest common divisor (GCD) of two integers using the Euclidean algorithm.

    Args:
        x (int): The first integer.
        y (int): The second integer.

    Returns:
        int: The greatest common divisor of x and y.

    Example Usage:
        >>> _gcd(8, 12)
        4

    Note:
        The function uses the Euclidean algorithm, which involves repeated division.
    """"""
    # Continues finding the remainder until y becomes zero.
    while y:
        x, y = y, x % y  
    
    # The GCD is stored in x when y becomes zero.
    return x  


def simplify(n: int, d: int) -> tuple[int, int]:
    """"""
    Simplifies a fraction by dividing both the numerator and denominator by their GCD.

    Args:
        n (int): The numerator of the fraction.
        d (int): The denominator of the fraction.

    Returns:
        tuple[int, int]: The simplified numerator and denominator.

    Raises:
        ZeroDivisionError: If the denominator is zero.

    Example Usage:
        >>> simplify(8, 12)
        (2, 3)

    Note:
        This function uses the _gcd function to find the greatest common divisor.
    """"""
    g = _gcd(n, d)  # Finds the GCD of the numerator and denominator.
    return (n // g, d // g)  # Divides both by the GCD to simplify the fraction.

    
def parse_rely(s: str) -> dict[str, str]:
    """"""
    Parses a string representing dependencies and returns a dictionary of these mappings.

    Args:
        s (str): A string representing dependencies, formatted as 'a: b, c: d'.

    Returns:
        dict[str, str]: A dictionary where each key-value pair represents a dependency.

    Example Usage:
        >>> parse_rely(""a: b, c: d"")
        {'a': ['b'], 'c': ['d']}

    Note:
        This function splits the string by commas and then by colons to extract dependencies.
    """"""
    
    # Initialize the dependency map
    result = {}
    
    # If the string is empty (or Falsey) we return an empty dictionary
    if not s:
        return result
    
    # Splits the string into individual mappings.
    s = [x.strip() for x in s.split(',')]  
    
    # Iterate over the comma delimited mappings
    for x in s:
        
        # Splits each mapping at the colon.
        a, b = x.split(':')  
        
        # Strips and splits the keys and values.
        a, b = a.strip().split(), b.strip().split()  
        
        # Updates the result dictionary with mappings.
        result.update({m: b for m in a})  
        
    return result


def hashed(name: str, args: list[gm.Point], rename: bool = False) -> tuple[str, ...]:
    """"""
    Generates a hash-like tuple from a geometric predicate name and its arguments.

    Args:
        name (str): The geometric predicate name.
        args (list[gm.Point]): The list of points involved in the predicate.
        rename (bool, optional): If True, uses an alternative name for points.

    Returns:
        tuple[str, ...]: A tuple representing the hashed value of the predicate.

    Example Usage:
        >>> hashed('cong', [Point('A'), Point('B')], rename=False)
        ('cong', 'A', 'B')

    Note:
        This function is used to create a unique representation of geometric predicates.
    """"""
    # Handles special cases like 's_angle' and defaults to using point names for hashing.
    #   - The 'rename' flag allows for alternative point naming, useful in different contexts.
    #   - We also need to hangle the special case of 's_angle'
    if name == 's_angle':
        args = [p.name if not rename else p.new_name for p in args[:-1]] + [str(args[-1])]
    else:
        args = [p.name if not rename else p.new_name for p in args]
    return hashed_txt(name, args)


def hashed_txt(name: str, args: list[str]) -> tuple[str, ...]:
    """"""
    Creates a hash-like tuple from a geometric predicate name and its arguments. 
    This hash is designed to be unique to the predicate and its arguments, accounting for 
    the symmetry and order of the arguments where applicable.

    Args:
        name (str): The name of the geometric predicate (like 'cong' for congruent).
        args (list[str]): The list of arguments associated with the predicate. 
                          These arguments are typically point labels (like 'A', 'B', etc.).

    Returns:
        tuple[str, ...]: A tuple that uniquely represents the predicate and its arguments.

    Example Usage:
        >>> hashed_txt('cong', ['A', 'B', 'C', 'D'])
        ('cong', 'A', 'B', 'C', 'D')

    Raises:
        ValueError: If the predicate name is not recognized.

    Notes:
        - The function handles various geometric predicates and sorts their arguments 
          to ensure consistent and equivariant representation.
        - This is particularly important for predicates where the order of arguments 
          does not change the meaning (e.g., congruence, parallelism).
    """"""
    
    # Handle predicates that involve constants (like angles or ratios).
    #   - These predicates have a special last argument (usually a numeric value) 
    #   - This argument should not be sorted with the other point labels.
    if name in ['const', 'aconst', 'rconst']:
        a, b, c, d, y = args  # Unpacking the arguments
        a, b = sorted([a, b])  # Sorting the first pair of points
        c, d = sorted([c, d])  # Sorting the second pair of points
        return name, a, b, c, d, y  # Returning the formatted tuple
    
    # Handle binary predicates like 'para', 'cong', 'perp', etc.
    #   - These involve two pairs of points and require sorting each pair and then the pairs themselves.
    if name in ['npara', 'nperp', 'para', 'cong', 'perp', 'collx']:
        a, b, c, d = args  # Unpacking the arguments
        
        # Sorting each pair of points and then sorting the pairs
        a, b = sorted([a, b])
        c, d = sorted([c, d])
        (a, b), (c, d) = sorted([(a, b), (c, d)])
        
        return (name, a, b, c, d)  # Returning the formatted tuple

    # Handling predicates involving midpoints.
    #   - Here, only the second and third arguments (representing points) are sorted.
    if name in ['midp', 'midpoint']:
        a, b, c = args  # Unpacking the arguments
        b, c = sorted([b, c])  # Sorting the 2nd and 3rd points
        return (name, a, b, c)  # Returning the formatted tuple

    # Handling predicates that involve collections of points like 'coll', 'cyclic', etc.
    #   - Here, all arguments are point labels that are sorted and deduplicated.
    if name in ['coll', 'cyclic', 'ncoll', 'diff', 'triangle']:
        return (name,) + tuple(sorted(list(set(args)))) # Returning the formatted tuple

    # Handling the 'circle' predicate.
    #   - This involves one central point followed by three points on the circle, sorted.
    if name == 'circle':
        x, a, b, c = args  # Unpacking the arguments
        return (name, x) + tuple(sorted([a, b, c]))  # Returning the formatted tuple

    # Handling predicates like 'eqangle', 'eqratio' which compare two geometrical figures.
    #   - This requires sorting the points in each geometrical figure and then sorting the figures.
    if name in ['eqangle', 'eqratio', 'eqangle6', 'eqratio6']:
        a, b, c, d, e, f, g, h = args  # Unpacking the arguments
        
        # Sorting points within each geometrical figure and then sorting the figures.
        a, b = sorted([a, b])
        c, d = sorted([c, d])
        e, f = sorted([e, f])
        g, h = sorted([g, h])
        
        # Adjusting order to ensure consistent representation
        if tuple(sorted([a, b, e, f])) > tuple(sorted([c, d, g, h])):
            a, b, e, f, c, d, g, h = c, d, g, h, a, b, e, f
        if (a, b, c, d) > (e, f, g, h):
            a, b, c, d, e, f, g, h = e, f, g, h, a, b, c, d
            
        # Normalizing names for '6' variants of the predicates
        if name == 'eqangle6':
            name = 'eqangle'
        if name == 'eqratio6':
            name = 'eqratio'
            
        # Returning the formatted tuple
        return (name,) + (a, b, c, d, e, f, g, h)

    # Handling predicates that involve triangles.
    #   - This includes sorting the points in each triangle and then sorting the triangles.
    if name in ['contri', 'simtri', 'simtri2', 'contri2', 'contri*', 'simtri*']:
        a, b, c, x, y, z = args  # Unpacking the arguments
        
        # Sorting points within each triangle and then sorting the triangles.
        (a, x), (b, y), (c, z) = sorted([(a, x), (b, y), (c, z)], key=sorted)
        (a, b, c), (x, y, z) = sorted([(a, b, c), (x, y, z)], key=sorted)
        
        return (name, a, b, c, x, y, z)  # Returning the formatted tuple

    # Handling 'eqratio3' predicate.
    #   - This involves sorting pairs of points and then sorting the pairs.
    if name in ['eqratio3']:
        # Unpacking the arguments and sorting the pairs of points
        a, b, c, d, o, o = args  # pylint: disable=redeclared-assigned-name
        (a, c), (b, d) = sorted([(a, c), (b, d)], key=sorted)
        (a, b), (c, d) = sorted([(a, b), (c, d)], key=sorted)
        return (name, a, b, c, d, o, o)  # Returning the formatted tuple

    # Handling special predicates like 'sameside' or 's_angle'.
    if name in ['sameside', 's_angle']:
        return (name,) + tuple(args)  # Returning the formatted tuple

    # Raising an error if the predicate name is not recognized.
    raise ValueError(f'Not recognize {name} to hash.')
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.4 <code><b>PROBLEM.PY</b></code> FILE - PREDICATE <b>CLASSES</b></h3>
<hr>

These two classes (**`Construction`** and **`Clause`**) are for handling one or many (respectively) predicates.

class Construction:
    """"""
    Represents a geometric construction (predicate), defined by a name and a list of arguments.

    A construction is a basic building block in geometric problems and proofs,
    representing a geometric concept such as a point, line, angle, etc., along
    with its properties and relations to other geometric entities.

    Attributes:
        name (str): The name of the geometric construction (e.g., 'line', 'angle').
        args (list[str]): The arguments or parameters of the construction, typically
                          representing points or numerical values.

    Methods:
        from_txt(cls, data: str): Class method to create a Construction object from
                                  a string representation.
        translate(self, mapping: dict[str, str]): Translates the construction's arguments
                                                  based on the provided mapping.
        txt(self): Returns a string representation of the construction.
    
    Example Usage:
        >>> construction = Construction('line', ['A', 'B'])
        >>> print(construction.name)
        'line'
        >>> print(construction.args)
        ['A', 'B']
        >>> print(construction.txt())
        'line A B'
    """"""

    @classmethod
    def from_txt(cls, data: str) -> Construction:
        """"""
        Creates a Construction object from a string representation.

        Args:
            data (str): The string representation of the construction, where
                        the first word is the name and the rest are arguments.

        Returns:
            Construction: The constructed object.

        Example Usage:
            >>> Construction.from_txt('line A B')
            <Construction object with name 'line' and args ['A', 'B']>
        """"""
        data = data.split(' ')
        return cls(data[0], data[1:])

    def __init__(self, name: str, args: list[str]):
        """"""
        Initializes the Construction object with a name and a list of arguments.

        Args:
            name (str): The name of the construction.
            args (list[str]): The arguments of the construction.
        """"""
        self.name = name
        self.args = args

    def translate(self, mapping: dict[str, str]) -> Construction:
        """"""
        Translates the construction's arguments based on the provided mapping.

        This is typically used to rename points or parameters according to a new
        naming convention.

        Args:
            mapping (dict[str, str]): A dictionary mapping from old argument names
                                      to new ones.

        Returns:
            Construction: A new Construction object with translated arguments.

        Example Usage:
            >>> construction = Construction('line', ['A', 'B'])
            >>> new_construction = construction.translate({'A': 'X', 'B': 'Y'})
            >>> print(new_construction.txt())
            'line X Y'
        """"""
        args = [a if isint(a) else mapping.get(a, a) for a in self.args]
        return Construction(self.name, args)

    def txt(self) -> str:
        """"""
        Returns a string representation of the construction.

        The string representation consists of the construction's name followed
        by its arguments separated by spaces.

        Returns:
            str: The string representation of the construction.

        Example Usage:
            >>> construction = Construction('line', ['A', 'B'])
            >>> print(construction.txt())
            'line A B'
        """"""
        return ' '.join([self.name] + list(self.args))
    
    
class Clause:
    def __init__(self, points: list[str], constructions: list[Construction]):
        """"""
        Initializes the Clause object with points and constructions.

        Args:
            points (list[str]): The list of points involved in the clause.
            constructions (list[Construction]): The constructions (predicates) in the clause.
        """"""
        self.points = []  # Initialize an empty list for storing processed points.
        self.nums = []    # Initialize an empty list for storing numerical values associated with points, if any.

        # Process each point in the provided points list.
        for p in points:
            num = None  # Default numerical value for a point is set to None.

            # Check if the point is a string and contains '@' symbol, indicating a special format.
            if isinstance(p, str) and '@' in p:
                p, num = p.split('@')  # Split the point at '@' to separate the point label and its numeric value.
                x, y = num.split('_')  # Further split the numeric part at '_' to extract two values.
                num = float(x), float(y)  # Convert these values into floats and store them as a tuple.

            self.points.append(p)  # Append the processed point label to the points list.
            self.nums.append(num)   # Append the corresponding numerical value (or None) to the nums list.

        self.constructions = constructions  # Store the provided constructions.

    def translate(self, mapping: dict[str, str]) -> 'Clause':
        """"""
        Translates the clause's points based on the provided mapping.

        This method is typically used to rename points according to a new naming convention.

        Args:
            mapping (dict[str, str]): A dictionary mapping from old point names to new ones.

        Returns:
            Clause: A new Clause object with translated points and constructions.

        Example Usage:
            >>> clause = Clause(['A', 'B'], [Construction('line', ['A', 'B'])])
            >>> new_clause = clause.translate({'A': 'X', 'B': 'Y'})
            >>> print(new_clause.points)
            ['X', 'Y']
        """"""
        points0 = []  # Initialize an empty list to store the translated points.

        # Iterate over each point in the points list.
        for p in self.points:
            
            # Generate a new name for the point if it exceeds the alphabet limit (i.e., beyond 'z').
            pcount = len(mapping) + 1  # Determine the count for the new point name.
            name = chr(96 + pcount)  # Generate a character based on the count.
            
            # If the generated name exceeds 'z', create a new name using a combination of characters.
            if name > 'z':  
                name = chr(97 + (pcount - 1) % 26) + str((pcount - 1) // 26)

            # Get the new name for the point from the mapping, defaulting to the generated name if not found.
            p0 = mapping.get(p, name)
            
            mapping[p] = p0  # Update the mapping with the new point name.
            points0.append(p0)  # Add the translated point name to the new list.

        # Return a new Clause object with translated points and updated constructions.
        return Clause(points0, [c.translate(mapping) for c in self.constructions])

    def add(self, name: str, args: list[str]) -> None:
        """"""
        Adds a new construction to the clause.

        This method allows adding an additional construction (or predicate) to the clause's list of constructions. 

        Args:
            name (str): The name of the geometric construction to be added (e.g., 'line', 'circle').
            args (list[str]): The list of arguments associated with this construction (typically point labels).

        Example Usage:
            >>> clause = Clause(['A', 'B'], [Construction('line', ['A', 'B'])])
            >>> clause.add('circle', ['C', 'A', 'B'])
            >>> print(clause.txt())
            'A B = line A B, circle C A B'
        """"""
        # Appends a new Construction object to the clause's constructions list.
        #   - The new Construction is created with the provided name and arguments.
        self.constructions.append(Construction(name, args))

    def txt(self) -> str:
        """"""
        Returns a string representation of the clause.

        The string format is: 'point1 point2 ... = construction1, construction2, ...'. 
        It represents the clause with its points and constructions in a readable format.

        Returns:
            str: The string representation of the clause.

        Example Usage:
            >>> clause = Clause(['A', 'B'], [Construction('line', ['A', 'B']), Construction('circle', ['C', 'A', 'B'])])
            >>> print(clause.txt())
            'A B = line A B, circle C A B'
        """"""
        # Joins the points into a single string, separated by spaces.
        points_str = ' '.join(self.points)

        # Generates the string representation for each construction in the clause.
        #   - Each construction is converted to its string format and joined by commas.
        constructions_str = ', '.join(c.txt() for c in self.constructions)

        # Combines the points string and the constructions string into the final format.
        return points_str + ' = ' + constructions_str

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.5 <code><b>PROBLEM.PY</b></code> FILE - THE PROBLEM <b>CLASS</b></h3>
<hr>

class Problem:
    """"""
    Represents a geometric problem, consisting of various clauses and a goal.

    A Problem in this context is structured as a collection of clauses (each being a set of constructions and points) 
    and a goal, which is a single construction that needs to be proved or derived.

    Attributes:
        url (str): An identifier or a reference link for the problem.
        clauses (list[Clause]): A list of clauses that constitute the problem.
        goal (Construction): The goal or objective of the problem.
        mapping (dict): Optional attribute to store a mapping of point names, used in translation.

    Methods:
        from_txt_file: Loads problems from a text file.
        from_txt: Parses a problem from a string representation.
        to_dict: Converts a list of problems into a dictionary indexed by URLs.
        copy: Creates a deep copy of the problem.
        translate: Translates point names of the problem into a standardized format.
        txt: Returns a string representation of the problem.
        setup_str_from_problem: Generates a string representation of the problem suitable for theorem proving.
    """"""
    
    @classmethod
    def from_txt_file(cls, fname: str, to_dict: bool = False, translate: bool = True):
        """"""
        Loads problem(s) from a text file, each problem will be represented as a string.

        Args:
            fname (str): The filename of the text file containing the problems.
            to_dict (bool, optional): If True, returns a dictionary of problems indexed by their URLs.
            translate (bool, optional): If True, translates the problems into a standard format.

        Returns:
            list[Problem] or dict[str, Problem]: A list or dictionary of Problem objects.

        Example Usage:
            >>> problems = Problem.from_txt_file(""problems.txt"", to_dict=True)
            >>> print(problems['http://example.com/problem1'].txt())
        """"""

        # Open the file specified by 'fname' in read mode.
        with open(fname, 'r') as f:
            # Read the entire content of the file and split it into lines.
            lines = f.read().split('\n')

        # Filter out empty lines to avoid processing unnecessary whitespace.
        lines = [l for l in lines if l]

        # The 'reshape' function is used to pair each URL with its corresponding problem.
        # It's assumed that each problem is represented in two lines: one for the URL and one for the problem itself.
        data = [
            cls.from_txt(url + '\n' + problem, translate)  # Combine URL and problem and parse it using 'from_txt'.
            for (url, problem) in reshape(lines, 2)  # Use 'reshape' to create pairs of (URL, problem).
        ]

        # If 'to_dict' is True, convert the list of problems into a dictionary with URLs as keys.
        if to_dict:
            # Convert the list of problems to a dictionary indexed by URLs.
            return cls.to_dict(data)  

        # If 'to_dict' is False, simply return the list of problems.
        return data

    @classmethod
    def from_txt(cls, data: str, translate: bool = True) -> Problem:
        """"""
        Parses a problem from its string representation.

        Args:
            data (str): The string representation of the problem.
            translate (bool): If True, translates the problem into a standard format.

        Returns:
            Problem: The parsed problem object.

        Example Usage:
            >>> problem_str = ""A B C; D E F ? goal""
            >>> problem = Problem.from_txt(problem_str)
            >>> print(problem.txt())
        """"""
        # Initialize the URL as an empty string.
        url = ''

        # If the data contains a newline character, it indicates the presence of a URL.
        if '\n' in data:
            # Split the data into URL and the actual problem data.
            url, data = data.split('\n')

        # Check if the data contains a goal (identified by ' ? ').
        if ' ? ' in data:
            # Split the data into clauses (problem's body) and goal.
            clauses, goal = data.split(' ? ')
            # Convert the goal string into a Construction object.
            goal = Construction.from_txt(goal)
        else:
            # If there is no goal, set clauses to data and goal to None.
            clauses, goal = data, None

        # Split the clauses part into individual clauses based on '; '.
        clauses = clauses.split('; ')
        # Create a Problem object with the parsed URL, clauses, and goal.
        #   - Each clause is converted from string to Clause object using Clause.from_txt.
        problem = Problem(
            url=url, 
            clauses=[Clause.from_txt(c) for c in clauses], 
            goal=goal
        )

        # If translation is requested, translate the problem to a standard format.
        if translate:
            return problem.translate()

        # Return the parsed problem as-is if no translation is needed.
        return problem

    @classmethod
    def to_dict(cls, data: list[Problem]) -> dict[str, Problem]:
        """"""
        Converts a list of Problem objects into a dictionary.

        Args:
            data (list[Problem]): A list of Problem objects.

        Returns:
            dict[str, Problem]: A dictionary mapping each Problem's URL to the Problem object.

        Example Usage:
            >>> problems = [Problem('url1', [], None), Problem('url2', [], None)]
            >>> problems_dict = Problem.to_dict(problems)
            >>> print(problems_dict.keys())
            dict_keys(['url1', 'url2'])
        """"""
        # Creates a dictionary from the list of problems,
        #   - Each problem's URL is the KEY
        #   - Each problem object itself is the VALUE.
        return {p.url: p for p in data}
    
    def __init__(self, url: str, clauses: list[Clause], goal: Construction):
        """"""
        Initializes a Problem object.

        Args:
            url (str): The URL associated with the problem.
            clauses (list[Clause]): A list of Clause objects representing the problem's clauses.
            goal (Construction): The goal construction of the problem.

        Example Usage:
            >>> problem = Problem('example_url', [], None)
            >>> print(problem.url)
            'example_url'
        """"""
        self.url = url            # Storing the URL of the problem.
        self.clauses = clauses    # Storing the list of clauses in the problem.
        self.goal = goal          # Storing the goal of the problem.
        
    def copy(self) -> Problem:
        """"""
        Creates a copy of the current Problem object.

        Returns:
            Problem: A new Problem object that is a copy of the current object.

        Example Usage:
            >>> original_problem = Problem('url', [], None)
            >>> copied_problem = original_problem.copy()
            >>> print(copied_problem.url)
            'url'
        """"""
        # Returns a new Problem object with the same URL, clauses, and goal as the current object.
        #   - Uses list(self.clauses) to create a shallow copy of the clauses list.
        return Problem(self.url, list(self.clauses), self.goal)
    
    def translate(self) -> Problem:
        """"""
        Translates the problem by standardizing the naming of points to single characters.

        Returns:
            Problem: A new Problem object with translated clause and goal names.

        Example Usage:
            >>> problem = Problem('url', [Clause(['A1', 'B1'], [])], None)
            >>> translated_problem = problem.translate()
            >>> print(translated_problem.clauses[0].points)
            ['A', 'B']
        """"""
        mapping = {}     # Initialize an empty dictionary for point name mapping.
        clauses = []     # Initialize an empty list to store translated clauses.

        # Iterate over each clause in the problem.
        for clause in self.clauses:
            # Translate each clause and append it to the translated clauses list.
            clauses.append(clause.translate(mapping))

        # Translate the goal if it exists (otherwise take it as-is)
        if self.goal:
            goal = self.goal.translate(mapping)
        else:
            goal = self.goal

        # Create a new Problem object with the translated clauses and goal.
        p = Problem(self.url, clauses, goal)
        
        # Store the mapping used for translation.
        p.mapping = mapping  

        # Return the translated Problem object.
        return p  
    
    def txt(self) -> str:
        """"""
        Generates a string representation of the problem.

        This representation includes all the clauses and the goal of the problem,
        formatted in a specific way for readability and consistency.

        Returns:
            str: The string representation of the problem.

        Example Usage:
            Suppose a problem has two clauses 'A B C' and 'D E F', and a goal 'G H'.
            >>> problem = Problem('', [Clause(['A', 'B', 'C'], []), Clause(['D', 'E', 'F'], [])], Construction('goal', ['G', 'H']))
            >>> print(problem.txt())
            'A B C ; D E F ? goal G H'
        """"""
        # If there is a goal, it's separated from the clauses by ' ? '.
        #   - If there IS A GOAL:
        #     - We join the string representations of all clauses with '; ' and append the goal representation. (and return)
        #   - If there IS NOT A GOAL:
        #     - An empty string is returned.
        return (
            '; '.join([c.txt() for c in self.clauses]) + ' ? ' + self.goal.txt() 
            if self.goal
            else ''
        )

    def setup_str_from_problem(self, definitions: list[Definition]) -> str:
        """"""
        Constructs a string representing the theorem premises from a Problem object.

        This method processes each construction in the problem's clauses against a set
        of geometric definitions. It then builds a detailed string that outlines the
        dependencies and relationships between various geometric entities.

        Args:
            definitions (list[Definition]): A list of geometric definitions.

        Returns:
            str: A detailed string representation of the theorem premises.

        Raises:
            AssertionError: If the argument length mismatch is detected between a 
                            construction and its definition.

        Example Usage:
            # Assuming 'definitions' is a pre-defined list of geometric definitions
            >>> problem = Problem(...)
            >>> theorem_premises = problem.setup_str_from_problem(definitions)
            >>> print(theorem_premises)

        Note:
            This method is complex and involves nested loops, conditional checks, and
            string manipulation to generate a comprehensive representation.
        """"""

        # Initializing a reference counter for dependencies.
        ref = 0  

        # List to accumulate strings representing each clause.
        string = []

        # Process each clause in the problem.
        for clause in self.clauses:
            group = {}  # Dictionary to group points.
            p2deps = defaultdict(list)  # Default dictionary to store point-to-dependencies mappings.

            # Iterate over each construction in the clause.
            for c in clause.constructions:
                # Retrieve the definition for the current construction.
                cdef = definitions[c.name]

                # Check if the length of the arguments in the construction matches its definition.
                # If not, assert that the total argument length (including points) matches the definition.
                if len(c.args) != len(cdef.construction.args):
                    assert len(c.args) + len(clause.points) == len(cdef.construction.args), \
                        ""Mismatch in argument length between construction and its definition.""
                    c.args = clause.points + c.args  # Combine points with arguments.

                # Create a mapping of construction arguments to actual points/arguments.
                mapping = dict(zip(cdef.construction.args, c.args))

                # Process basic constructions (basics) in the definition.
                for points, bs in cdef.basics:
                    points = tuple([mapping[x] for x in points])  # Map the basic construction points.
                    for p in points:
                        group[p] = points  # Group points together.

                    # Iterate over basic constructions in the definition.
                    for b in bs:
                        args = [mapping[a] for a in b.args]  # Map arguments of basic constructions.
                        name = b.name

                        # Special handling for 's_angle' and 'aconst' construction types.
                        if b.name in ['s_angle', 'aconst']:
                            x, y, z, v = args
                            name = 'aconst'
                            v = int(v)

                            # Adjust the values and points for negative angles.
                            if v < 0:
                                v = -v
                                x, z = z, x

                            # Simplify the angle representation.
                            m, n = simplify(int(v), 180)
                            args = [y, z, y, x, f'{m}pi/{n}']

                        # Append the hashed text representation of the construction.
                        p2deps[points].append(hashed_txt(name, args))

            # Sort the dependencies for each group of points.
            for k, v in p2deps.items():
                p2deps[k] = sort_deps(v)

            # Process each point in the clause.
            points = clause.points
            while points:
                p = points[0]
                gr = group[p]
                points = [x for x in points if x not in gr]  # Filter out processed points.
                
                # List to store dependency strings.
                deps_str = []  

                # Iterate over dependencies for the current group.
                for dep in p2deps[gr]:
                    # Format the reference number.
                    ref_str = '{:02}'.format(ref)
                    dep_str = pt.pretty(dep)  # Get the pretty-printed representation of the dependency.

                    # Special handling for dependencies of type 'aconst'.
                    if dep[0] == 'aconst':
                        m, n = map(int, dep[-1].split('pi/'))  # Extract angle ratio.
                        mn = f'{m}. pi / {n}.'  # Format the angle representation.
                        dep_str = ' '.join(dep_str.split()[:-1] + [mn])  # Update dependency string with formatted angle.

                    # Append the formatted dependency string with its reference.
                    deps_str.append(dep_str + ' ' + ref_str)
                    ref += 1  # Increment the reference counter.

                # Append the formatted string for the current group.
                string.append(' '.join(gr) + ' : ' + ' '.join(deps_str))

        # Combine all clause strings and append the goal (if present).
        string = '{S} ' + ' ; '.join([s.strip() for s in string])
        if self.goal:
            string += ' ? ' + pt.pretty([self.goal.name] + self.goal.args)
        
        return string
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.6 <code><b>PROBLEM.PY</b></code> FILE - THE DEFINITION <b>CLASS</b></h3>
<hr>

class Definition:
    """"""
    Represents the definitions of construction statements in geometry.

    This class encapsulates the definition of a geometric construction, including
    its dependencies, basic constructions, and numeric properties if any. It's essential
    for understanding how different geometric entities are constructed and related.

    Attributes:
        construction (Construction): The main construction this definition describes.
        rely (dict[str, str]): A mapping of dependencies for the construction.
        deps (Clause): The clause representing the dependencies of the construction.
        basics (list[tuple[list[str], list[Construction]]]): A list of basic constructions and points involved.
        numerics (list[Construction]): Numeric properties or constraints related to the construction.
        points (list[str]): Points involved in the construction (extracted from the construction args).
        args (list[str]): Arguments or parameters specific to the construction.

    Methods:
        from_txt_file: Class method to load definitions from a text file.
        from_string: Class method to create definitions from a string.
        to_dict: Class method to convert a list of definitions into a dictionary.
        from_txt: Class method to parse a single definition from a string.
    """"""

    @classmethod
    def from_txt_file(cls, fname: str, to_dict: bool = False) -> Union[List['Definition'], Dict[str, 'Definition']]:
        """"""
        Loads definitions from a text file.

        This method reads a file containing geometric definitions and constructs
        a list (or dictionary) of Definition objects.

        Args:
            fname (str): The filename of the text file containing the definitions.
            to_dict (bool, optional): If True, returns a dictionary of definitions indexed by their construction names.

        Returns:
            Union[List[Definition], Dict[str, Definition]]: Either a list or dictionary of Definition objects.

        Example Usage:
            >>> definitions = Definition.from_txt_file(""definitions.txt"", to_dict=True)
            >>> print(definitions['line'].construction.name)
            'line'
        """"""
        # Open the file and read its content
        with open(fname, 'r') as f:
            lines = f.read()
        
        # Split the content into individual definitions and process each
        return cls.from_string(lines, to_dict)

    @classmethod
    def from_string(cls, string: str, to_dict: bool = False) -> Union[List['Definition'], Dict[str, 'Definition']]:
        """"""
        Creates a list (or dictionary) of Definition objects from a multiline string.

        Each definition in the string should be separated by a specific number of line breaks
        (currently 6 lines per definition including the empty lines).

        Args:
            string (str): Multiline string containing several geometric definitions.
            to_dict (bool, optional): If True, the method returns a dictionary with construction names as keys.

        Returns:
            Union[List[Definition], Dict[str, Definition]]: A list or dictionary of Definition objects.

        Example Usage:
            Suppose 'string' contains two definitions separated by 6 lines.
            >>> definitions = Definition.from_string(string, to_dict=True)
            >>> print(definitions['line'].construction.name)
            'line'

        Note:
            This method assumes a specific format for each definition in the input string.
            An incorrect format might lead to unexpected results or errors.
        """"""
        # Split the entire string into lines
        lines = string.split('\n')

        # Group these lines into chunks, each representing a single definition
        #   - 'reshape' is used to group every 6 lines into one definition
        data = [cls.from_txt('\n'.join(group)) for group in reshape(lines, 6)]

        # Convert the list of Definition objects into a dictionary if required
        if to_dict:
            return cls.to_dict(data)
        
        # Otherwise we return as-is
        return data

    @classmethod
    def to_dict(cls, data: list[Definition]) -> dict[str, Definition]:
        """"""
        Converts a list of Definition objects into a dictionary.

        The dictionary keys are the names of the constructions from each Definition.

        Args:
            data (list[Definition]): The list of Definition objects to be converted.

        Returns:
            dict[str, Definition]: A dictionary mapping construction names to Definition objects.

        Example Usage:
            >>> definitions_list = [Definition(Construction('line', []), {}, Clause([], []), [], [])]
            >>> definitions_dict = Definition.to_dict(definitions_list)
            >>> 'line' in definitions_dict
            True

        Note:
            The method assumes that each construction name in the definitions is unique.
        """"""
        # Create a dictionary with construction names as keys and the Definition objects as values
        return {d.construction.name: d for d in data}

    @classmethod
    def from_txt(cls, data: str) -> Definition:
        """"""
        Parses a single definition from a string representation.

        This method takes a string that encapsulates a geometric construction definition and its various components,
        and parses it to create a `Definition` object. The string should be formatted with each component separated
        by a newline, following a specific sequence: construction, dependencies (rely), basics, and numerics.

        Args:
            data (str): The string representation of a single geometric definition.

        Returns:
            Definition: The Definition object created from the string.

        Example Usage:
            >>> definition_str = ""line AB\nA: B\nAB = \n\n\n""
            >>> definition = Definition.from_txt(definition_str)
            >>> print(definition.construction.name)
            'line'

        Raises:
            ValueError: If the string format is incorrect or missing required information.

        Note:
            The method assumes a strict format for 'data' and splits it into components based on line breaks.
            Each component is then processed to construct the Definition object.
        """"""
        # Split the input string into its components using newline as a delimiter.
        #   - Each part represents a different aspect of the geometric definition.
        construction, rely, deps, basics, numerics, _ = data.split('\n')

        # Process the 'basics' section of the definition.
        #   - The 'basics' are split by semicolons and further processed into tuples of points and basic constructions.
        basics = [] if not basics else [b.strip() for b in basics.split(';')]
        levels = []
        for bs in basics:
            # If a colon is present, split into points and basic constructions.
            if ':' in bs:
                points, bs = bs.split(':')
                points = points.strip().split()  # Extract the points as a list.
            else:
                points = []

            # Process each basic construction after splitting by comma and convert to Construction objects.
            bs = [Construction.from_txt(b.strip()) for b in bs.strip().split(',')] if bs.strip() else []
            levels.append((points, bs))  # Append the tuple of points and basic constructions to the levels list.

        # Process the 'numerics' section, which is expected to be a comma-separated list of numeric constructions.
        numerics = [] if not numerics else numerics.split(', ')

        # Create the Definition object using the parsed components.
        #   - This includes converting the construction, dependencies, and basics into their respective object representations.
        return Definition(
            construction=Construction.from_txt(construction),
            rely=parse_rely(rely),
            deps=Clause.from_txt(deps),
            basics=levels,
            numerics=[Construction.from_txt(c) for c in numerics],
        )


    def __init__(self, construction: Construction, rely: Dict[str, str], deps: Clause, 
                 basics: List[Tuple[List[str], List[Construction]]], numerics: List[Construction]):
        """"""
        Initializes the Definition object.

        Args:
            construction (Construction): The main construction this definition describes.
            rely (dict[str, str]): Dependencies mapping for the construction.
            deps (Clause): Clause representing the dependencies of the construction.
            basics (list[tuple[list[str], list[Construction]]]): Basic constructions and involved points.
            numerics (list[Construction]): Numeric properties or constraints of the construction.

        Example:
            >>> construction = Construction('triangle', ['A', 'B', 'C'])
            >>> definition = Definition(construction, {}, Clause([], []), [], [])
            >>> print(definition.construction.name)
            'triangle'
        """"""
        self.construction = construction  # Main construction
        self.rely = rely                  # Dependencies
        self.deps = deps                  # Clause for dependencies
        self.basics = basics              # Basic constructions
        self.numerics = numerics          # Numeric properties

        # Process and separate points and arguments from the construction's arguments
        args = set()
        
        # Add individual numerics to the 'args'
        for num in numerics:
            args.update(num.args)
            
        # Create attributes for points and args respectively
        self.points, self.args = [], []
        
        for p in self.construction.args:
            # If the arg is present in the construction then add to attribute args
            if p in args:
                self.args.append(p)
            # Otherwise, it is a point and we add it to the respective attribute
            else:
                self.points.append(p)
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.7 <code><b>PROBLEM.PY</b></code> FILE - THE THEOREM <b>CLASS</b></h3>

class Theorem:
    """"""
    Represents a geometric deduction rule or theorem.

    A Theorem in this context is a logical rule. 
    It describes how certain premises can lead to a specific conclusion
        - A premise is a given geometric construction
        - A conclusion is another geometric construction

    Attributes:
        name (str): A unique identifier for the theorem, typically derived from its premises and conclusion.
        premise (list[Construction]): A list of constructions that form the premises of the theorem.
        conclusion (list[Construction]): The conclusion construction of the theorem.
        is_arg_reduce (bool): Indicates whether the theorem reduces the number of arguments in the deduction process.

    Methods:
        from_txt_file: Loads theorems from a text file.
        from_string: Creates theorems from a string.
        from_txt: Parses a single theorem from a string.
        txt: Returns a string representation of the theorem.
        conclusion_name_args: Returns the conclusion's name and its arguments as points.
    """"""

    @classmethod
    def from_txt_file(cls, fname: str, to_dict: bool = False) -> Union[List['Theorem'], Dict[str, 'Theorem']]:
        """"""
        Loads theorems from a text file.

        Each theorem is expected to be on a separate line in the file. Lines starting with '#' are treated as comments
        and ignored. This method reads the file, processes each line to create Theorem objects, and returns them as a list
        or dictionary.

        Args:
            fname (str): The filename of the text file containing the theorems.
            to_dict (bool, optional): If True, returns a dictionary of theorems indexed by their rule names.

        Returns:
            Union[List[Theorem], Dict[str, Theorem]]: A list or dictionary of Theorem objects.

        Example Usage:
            >>> theorems = Theorem.from_txt_file(""theorems.txt"", to_dict=True)
            >>> print(theorems['r01'].txt())
            'line A B, point C => triangle A B C'
        """"""

        # Open the file and read its content
        with open(fname, 'r') as f:
            theorems = f.read()

        # Process the file content to create Theorem objects
        return cls.from_string(theorems, to_dict)

    @classmethod
    def from_string(cls, string: str, to_dict: bool = False) -> Union[List['Theorem'], Dict[str, 'Theorem']]:
        """"""
        Creates a list (or dictionary) of Theorem objects from a multiline string.

        Each line of the string should represent a theorem.
            - Lines starting with '#' are treated as comments and ignored.

        Args:
            string (str): Multiline string containing several theorems.
            to_dict (bool, optional): If True, returns a dictionary with theorems indexed by their rule names.

        Returns:
            Union[List[Theorem], Dict[str, Theorem]]: A list or dictionary of Theorem objects.

        Example Usage:
            Suppose 'string' contains multiple theorems separated by newlines.
            >>> theorems = Theorem.from_string(string, to_dict=True)
            >>> print(theorems['r01'].txt())
            'line A B, point C => triangle A B C'
        """"""

        # Split the string into lines, filtering out empty lines and comments
        theorems = [l for l in string.split('\n') if l and not l.startswith('#')]

        # Process each line to create Theorem objects
        theorems = [cls.from_txt(l) for l in theorems]

        # Assign unique rule names to each theorem
        for i, th in enumerate(theorems):
            th.rule_name = 'r{:02}'.format(i)

        # Convert to dictionary if needed (rule_name mapped to theorem itself)
        if to_dict:
            return {t.rule_name: t for t in theorems}

        return theorems

    @classmethod
    def from_txt(cls, data: str) -> 'Theorem':
        """"""
        Parses a single theorem from its string representation.

        The string format for a theorem is 'premise1, premise2, ... => conclusion'.
        Each premise and the conclusion are represented in the same way as geometric constructions.

        Args:
            data (str): The string representation of the theorem.

        Returns:
            Theorem: The parsed theorem object.

        Example Usage:
            >>> theorem_str = ""line A B, point C => triangle A B C""
            >>> theorem = Theorem.from_txt(theorem_str)
            >>> print(theorem.txt())
            'line A B, point C => triangle A B C'

        Raises:
            ValueError: If the theorem string does not contain exactly one conclusion.
        """"""

        # Split the string into premises and conclusion parts
        premises, conclusion = data.split(' => ')

        # Split the premises part into individual premises
        premises = premises.split(', ')

        # Split the conclusion part (assuming only one conclusion is allowed)
        conclusion = conclusion.split(', ')

        # Create a Theorem object from the parsed premises and conclusion
        return Theorem(
            premise=[Construction.from_txt(p) for p in premises],
            conclusion=[Construction.from_txt(c) for c in conclusion],
        )

    def __init__(self, premise: list[Construction], conclusion: list[Construction]):
        """"""
        Initializes the Theorem object.

        Args:
            premise (list[Construction]): A list of constructions forming the premises of the theorem.
            conclusion (list[Construction]): The conclusion construction of the theorem.

        Raises:
            ValueError: If more than one conclusion is provided.

        Example Usage:
            >>> theorem = Theorem([Construction('line', ['A', 'B'])], [Construction('triangle', ['A', 'B', 'C'])])
            >>> print(theorem.txt())
            'line A B => triangle A B C'
        """"""
        # Validate that there is exactly one conclusion
        if len(conclusion) != 1:
            raise ValueError('Cannot have more than one conclusion')

        # Construct the theorem name from its premises and conclusion
        self.name = '_'.join([p.name for p in premise + conclusion])
        self.premise = premise  # Store the premises
        self.conclusion = conclusion  # Store the conclusion

        # Determine if the theorem reduces argument complexity
        self.is_arg_reduce = False
        
        # Collect arguments from premises
        prem_args = set(sum([p.args for p in self.premise], []))  
        
        # Collect arguments from conclusion
        con_args = set(self.conclusion[0].args)  
        
        # Set to True if the conclusion has fewer or equal arguments compared to premises
        if len(prem_args) <= len(con_args):
            self.is_arg_reduce = True  

    def txt(self) -> str:
        """"""
        Generates a string representation of the theorem.

        This representation includes the premises and the conclusion of the theorem, formatted in a specific way.

        Returns:
            str: The string representation of the theorem.

        Example Usage:
            >>> theorem = Theorem([Construction('line', ['A', 'B'])], [Construction('triangle', ['A', 'B', 'C'])])
            >>> print(theorem.txt())
            'line A B => triangle A B C'
        """"""
        # Format the premises and conclusion into their string representations (comma delimited)
        premise_txt = ', '.join([clause.txt() for clause in self.premise])
        conclusion_txt = ', '.join([clause.txt() for clause in self.conclusion])
        
        # Combine the premise(s) and conclusion clauses into the theorem's format
        return f'{premise_txt} => {conclusion_txt}'  

    def conclusion_name_args(self, mapping: dict[str, gm.Point]) -> tuple[str, list[gm.Point]]:
        """"""
        Returns the conclusion's name and its arguments as points, based on a given mapping.

        This method is useful for translating the conclusion's abstract points to concrete geometric points,
        as per the provided mapping.

        Args:
            mapping (dict[str, gm.Point]): A mapping from point names to geometric point objects.

        Returns:
            tuple[str, list[gm.Point]]: The name of the conclusion and a list of its points.

        Example Usage:
            >>> mapping = {'A': gm.Point(0, 0), 'B': gm.Point(1, 0), 'C': gm.Point(0, 1)}
            >>> theorem = Theorem([Construction('line', ['A', 'B'])], [Construction('triangle', ['A', 'B', 'C'])])
            >>> name, args = theorem.conclusion_name_args(mapping)
            >>> print(name)
            'triangle'
            >>> for arg in args: print(arg)
            Point(0, 0)
            Point(1, 0)
            Point(0, 1)
        """"""
        # Create a new mapping with only the string keys (ignoring non-string keys)
        mapping = {arg: p for arg, p in mapping.items() if isinstance(arg, str)}

        # Retrieve the conclusion construction
        c = self.conclusion[0]

        # Map the conclusion's arguments to geometric points
        args = [mapping[a] for a in c.args]

        # Return the conclusion's name and the list of points
        return c.name, args
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.8 <code><b>PROBLEM.PY</b></code> FILE - THE DEPENDENCY AND EMPTYDEPENDENCY <b>CLASS</b></h3>

**`Dependency`** extends **`Construction`** and represents a geometrical predicate that depends on other predicates. 

class Dependency(Construction):
    """"""
    Represents a dependency in geometric constructions. 

    This class is a specialized form of a Construction that includes additional attributes 
    and methods to handle dependencies in geometric reasoning. It is used to describe how 
    one geometric fact (like a line being parallel to another) can depend on or lead to other facts.

    Attributes:
        rule_name (str): Identifier for the rule associated with this dependency.
        level (int): The level of derivation or complexity of the dependency.
        why (list[Dependency]): A list of other Dependency objects that this one depends on.
        _stat: Internal status (private attribute), used for internal processing.
        trace: Trace information for debugging or detailed analysis.
    
    Inherited from Construction:
        name (str): The name of the geometric construction (e.g., 'line', 'circle').
        args (list[gm.Point]): The arguments of the construction, usually points or coordinates.
        
    Methods:
        _find: Internal method to find a specific dependency.
        remove_loop: Removes circular references in dependencies.
        copy: Creates a deep copy of the dependency.
        why_me_or_cache: Determines dependencies, utilizing caching for efficiency.
        populate: Fills the dependency with additional details.
        why_me: Main logic to determine why a particular dependency holds.
        hashed: Creates a hash-like representation for the dependency.
    """"""
    
    def __init__(self, name: str, args: list[gm.Point], rule_name: str, level: int):
        """"""
        Initializes a Dependency object.

        Args:
            name (str): The name of the dependency construction.
            args (list[gm.Point]): The points or elements involved in the dependency.
            rule_name (str): The name of the rule associated with this dependency.
            level (int): The complexity level of the dependency.

        The `super().__init__` call initializes the base Construction attributes.
        """"""
        super().__init__(name, args)  # Initialize base Construction class
        self.rule_name = rule_name or ''  # Set the rule name, defaulting to an empty string if not provided
        self.level = level  # Set the complexity level
        self.why = []  # Initialize the list of dependencies

        # Private attributes for internal use
        self._stat = None  # Status attribute, used internally
        self.trace = None  # Trace information, useful for debugging

    def _find(self, dep_hashed: tuple[str, ...]) -> Optional[Dependency]:
        """"""
        Searches recursively for a specific dependency within the current dependency's 'why' list.

        Args:
            dep_hashed (tuple[str, ...]): The hashed representation of the dependency to be found.

        Returns:
            Optional[Dependency]: The found Dependency object, or None if not found.

        Example Usage:
            >>> dep = Dependency('para', [Point('A'), Point('B'), Point('C'), Point('D')], 'rule1', 1)
            >>> dep._find(('para', 'A', 'B', 'C', 'D'))
            # Returns the Dependency object if found, else None
        """"""
        # Iterate through each 'why' dependency.
        for w in self.why:  
            
            # Recursively search in the current 'why' dependency.
            f = w._find(dep_hashed)  
            
            # If found, return the dependency.
            if f:
                return f  
            
            # If the current dependency matches, return it.
            if w.hashed() == dep_hashed:
                return w  


    def remove_loop(self) -> Dependency:
        """"""
        Removes circular references within the dependency graph to prevent infinite loops.

        Returns:
            Dependency: The current Dependency object, potentially with circular references removed.

        Example Usage:
            >>> dep = Dependency(...)
            >>> dep.remove_loop()
            # Returns Dependency object with removed circular references if any existed.
        """"""
        # Utilize _find to check for self-reference (i.e. self.hashed()).
        f = self._find(self.hashed())  
        
        # If a circular reference is found, return the found (circular) dependency.
        if f:
            return f 
        
        # Otherwise, return the current dependency (non-circular).
        return self  

    def copy(self) -> Dependency:
        """"""
        Creates a deep copy of the current Dependency object.

        Returns:
            Dependency: A new Dependency object that is a copy of the current one.

        Example Usage:
            >>> original_dep = Dependency(...)
            >>> copied_dep = original_dep.copy()
            # 'copied_dep' is a separate instance with the same data as 'original_dep'
        """"""
        # Create a new Dependency object.
        dep = Dependency(self.name, self.args, self.rule_name, self.level)  
        
        # Copy the trace attribute.
        dep.trace = self.trace  
        
        # Deep copy of the 'why' list.
        dep.why = list(self.why)
        
        # Return the deep copy of the current dependency object
        return dep

    def why_me_or_cache(self, g: Any, level: int) -> Dependency:
        """"""
        Determines the dependencies of the current object, using caching for improved efficiency.

        Args:
            g (Any): The geometry object or context in which this dependency exists.
            level (int): The level of detail or depth at which dependency resolution is performed.

        Returns:
            Dependency: The current Dependency object, potentially with updated dependencies.

        Example Usage:
            >>> geometry_context = ...
            >>> dep = Dependency(...)
            >>> dep.why_me_or_cache(geometry_context, 2)
            # This method updates 'dep' with its dependencies, using cached values if available.
        """"""
        # Check if the current dependency is in the cache and if so return the cached dep
        if self.hashed() in g.cache:  
            return g.cache[self.hashed()]
        
        # Determine dependencies and update internal state ('why')
        self.why_me(g, level)  
        
        # Return the current dependency with updated 'why'
        return self

    def populate(self, name: str, args: list[gm.Point]) -> Dependency:
        """"""
        Fills the current Dependency object with additional details.

        Args:
            name (str): The name of the dependency to be populated with.
            args (list[gm.Point]): The arguments or points associated with the dependency.

        Returns:
            Dependency: A new Dependency object populated with the given details.
        
        Raises:
            AssertionError: If the rule name does not match the expected rule
        
        Example:
            >>> dep = EmptyDependency(...)
            >>> populated_dep = dep.populate('line', [Point('A'), Point('B')])
            # 'populated_dep' is now a Dependency object with the name 'line' and points 'A', 'B'.
        """"""
        # Ensure the rule name matches the expected rule.
        assert self.rule_name == CONSTRUCTION_RULE, self.rule_name  
        
        # Create a new Dependency object with:
        #   - the basics from the current Dependency
        #   - the arguments/points associated with this dep
        dep = Dependency(self.name, self.args, self.rule_name, self.level)  
        
        # Update the created Dependency with a deepcopy of the 'why'
        dep.why = list(self.why)  # Copy the 'why' list.
        return dep

    def why_me(self, g: Any, level: int) -> None:
        """"""
        Determines the reasons (dependencies) for the current geometric fact (predicates of self).

        This method is a key part of the geometric reasoning process, where it figures out
        why a certain geometric statement (represented by this Dependency object) is true based
        on other known facts and rules.
        
        The method updates the 'why' attribute with a list of other Dependency objects
        that this one logically depends on. It uses different geometric rules and facts
        available in the context 'g' to deduce these dependencies.

        Args:
            g (Any): The geometric context or environment in which this dependency is being evaluated.
            level (int): The level of complexity or depth of reasoning being used.
        
        Raises:
            ValueError: Raises an error if the dependency name is not recognized.
        
        Note:
            This method can get quite complex, as it involves a lot of geometric reasoning
            and different cases based on the type of geometric construction. I do my
            best to explain things in as much detail as possible... but it's overwhelming... obviously.
        """"""
        name, args = self.name, self.args

        # Check if the current dependency is already cached to avoid recomputation.
        hashed_me = hashed(self.name, self.args)
        if hashed_me in g.cache:
            dep = g.cache[hashed_me]
            self.why = dep.why  # Use the cached reasons for this dependency.
            self.rule_name = dep.rule_name  # Use the cached rule name.
            return

        # Handle the 'parallel' case.
        if self.name == 'para':
            
            # Extract point arguments.
            a, b, c, d = self.args

            # If the points are identical, the dependency is trivially satisfied.
            if {a, b} == {c, d}:
                self.why = []  # No dependencies needed.
                return

            # Retrieve the lines formed by these points.
            ab = g._get_line(a, b)
            cd = g._get_line(c, d)

            # If lines are identical, handle collinearity.
            if ab == cd:
                if {a, b} == {c, d}:
                    self.why = []  # No dependencies needed if lines are same with same points.
                    self.rule_name = ''
                    return

                # If lines are same but points are different, collinearity is involved.
                dep = Dependency('coll', list({a, b, c, d}), 't??', None)
                self.why = [dep.why_me_or_cache(g, level)]
                return

            # Check for indirect dependencies through other points on the lines.
            for (x, y), xy in zip([(a, b), (c, d)], [ab, cd]):
                x_, y_ = xy.points
                if {x, y} == {x_, y_}:
                    continue
                    
                # If an indirect dependency exists, we capture it and add it to the 'why'
                d = Dependency('collx', [x, y, x_, y_], None, level)
                self.why += [d.why_me_or_cache(g, level)]

            # Find reasons why lines are parallel.
            whypara = g.why_equal(ab, cd, None)
            self.why += whypara

        # Handles the midpoint case.
        elif self.name == 'midp':
            
            # Extracts the points involved in the midpoint relationship.
            m, a, b = self.args
            
            # Retrieves segments ma and mb.
            ma = g._get_segment(m, a)
            mb = g._get_segment(m, b)
            
            # Checks if m, a, b are collinear as a part of the midpoint verification.
            dep = Dependency('coll', [m, a, b], None, None).why_me_or_cache(g, None)
            
            # The reason why m is the midpoint involves both the collinearity and the equality of segments ma and mb.
            self.why = [dep] + g.why_equal(ma, mb, level)

       # Handles the perpendicularity case.
        elif self.name == 'perp':
            
            # Extracts the points defining the perpendicular lines.
            a, b, c, d = self.args
            
            # Retrieves lines ab and cd.
            ab = g._get_line(a, b)
            cd = g._get_line(c, d)
            
            # For each pair of points, checks if they form a line segment that needs to be considered.
            for (x, y), xy in zip([(a, b), (c, d)], [ab, cd]):
                x_, y_ = xy.points
                if {x, y} != {x_, y_}:
                    d = Dependency('collx', [x, y, x_, y_], None, level)
                    self.why += [d.why_me_or_cache(g, level)]
            
            # Determines if the angles formed by these lines are equal to confirm perpendicularity.
            _, why = why_eqangle(ab._val, cd._val, cd._val, ab._val, level)
            a, b = ab.points
            c, d = cd.points

            # Checks if a renaming of points is required and updates the dependency accordingly.
            if hashed(self.name, [a, b, c, d]) != self.hashed():
                d = Dependency(self.name, [a, b, c, d], None, level)
                d.why = why
                why = [d]

            # Adds the determined reasons to the 'why' attribute.
            self.why += why

        # Handles the congruence case.
        elif self.name == 'cong':
            
            # Extracts the points defining the segments for congruence check.
            a, b, c, d = self.args
            
            # Retrieves segments ab and cd.
            ab = g._get_segment(a, b)
            cd = g._get_segment(c, d)
            
            # The reason for congruence is derived from the equality of these segments.
            self.why = g.why_equal(ab, cd, level)

        # Handles collinearity case.
        elif self.name == 'coll':
            # This method derives the reason for the collinearity of a set of points.
            _, why = gm.line_of_and_why(self.args, level)
            self.why = why

        # Handles the extended collinearity ('collx') case.
        elif self.name == 'collx':
            # Check if the points are collinear.
            if g.check_coll(self.args):
                args = list(set(self.args))
                hashed_me = hashed('coll', args)
                # Utilizes caching to avoid redundant computations.
                if hashed_me in g.cache:
                    dep = g.cache[hashed_me]
                    self.why = [dep]
                    self.rule_name = ''
                    return
                # Determines the reason for collinearity.
                _, self.why = gm.line_of_and_why(args, level)
            else:
                # If not collinear, consider the possibility of them being parallel.
                self.name = 'para'
                self.why_me(g, level)

        # Handles the cyclic case.
        elif self.name == 'cyclic':
            # This method checks if a set of points lie on a common circle.
            _, why = gm.circle_of_and_why(self.args, level)
            self.why = why

        # Handles the case for points on a circle.
        elif self.name == 'circle':
            
            # Extracts the points defining the circle and its radius.
            o, a, b, c = self.args
            
            # Retrieves segments oa, ob, and oc.
            oa = g._get_segment(o, a)
            ob = g._get_segment(o, b)
            oc = g._get_segment(o, c)
            
            # Checks for equality of these segments to confirm the circle property.
            self.why = g.why_equal(oa, ob, level) + g.why_equal(oa, oc, level)
        
        # Handles the case for equal angles
        elif self.name in ['eqangle', 'eqangle6']:
            
            # Extracts the points defining the angles (four lines, two angles)
            a, b, c, d, m, n, p, q = self.args

            # Retrieves the lines and reasons why these lines are formed through each pair of points.
            ab, why1 = g.get_line_thru_pair_why(a, b)
            cd, why2 = g.get_line_thru_pair_why(c, d)
            mn, why3 = g.get_line_thru_pair_why(m, n)
            pq, why4 = g.get_line_thru_pair_why(p, q)
            
            # Check if any of the segments (lines) are undefined, which might occur in special cases.
            #   - i.e. When the points coincide or are not properly defined.
            if ab is None or cd is None or mn is None or pq is None:
                # Check various conditions to handle the undefined segments.

                # If points a, b are the same as points m, n, then lines cd and pq are considered parallel.
                if {a, b} == {m, n}:
                    d = Dependency('para', [c, d, p, q], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # If points a, b are the same as points c, d, then lines pq and mn are considered parallel.
                if {a, b} == {c, d}:
                    d = Dependency('para', [p, q, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # If points c, d are the same as points p, q, then lines ab and mn are considered parallel.
                if {c, d} == {p, q}:
                    d = Dependency('para', [a, b, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # If points p, q are the same as points m, n, then lines ab and cd are considered parallel.
                if {p, q} == {m, n}:
                    d = Dependency('para', [a, b, c, d], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # Return early from the function as the dependencies have been resolved.
                return

            # If the segments are defined, iterate over each pair of points and the corresponding lines.
            for (x, y), xy, whyxy in zip(
                    [(a, b), (c, d), (m, n), (p, q)],
                    [ab, cd, mn, pq],
                    [why1, why2, why3, why4],
            ):
                x_, y_ = xy.points  # Extract the actual points that define the line xy.

                # If the given pair of points (x, y) doesn't match the points (x_, y_) defining the line.
                #   - This indicates an indirect or extended collinearity ('collx').
                if {x, y} != {x_, y_}:
                    # Create a Dependency object for this collinearity case.
                    d = Dependency('collx', [x, y, x_, y_], None, level)
                    d.why = whyxy  # Assign the reasons for this dependency.
                    self.why += [d]  # Add this dependency to the 'why' list.

            # After handling all pairs, extract the actual points for each line.
            a, b = ab.points
            c, d = cd.points
            m, n = mn.points
            p, q = pq.points

            # Check if the hashed representation of the current dependency differs from the hashed representation of the points. 
            #   - This check is necessary to ensure consistency in the representation and naming of points.
            diff = hashed(self.name, [a, b, c, d, m, n, p, q]) != self.hashed()

            # Initialize variable to hold reasons for equal angles.
            whyeqangle = None

            # Check if all the line segments have valid values.
            if ab._val and cd._val and mn._val and pq._val:
                # If so, determine the reasons for equal angles between these segments.
                whyeqangle = why_eqangle(ab._val, cd._val, mn._val, pq._val, level)

            # If reasons for equal angles exist:
            if whyeqangle:
                # Unpack the reasons and the dependencies they are associated with.
                (dab, dcd, dmn, dpq), whyeqangle = whyeqangle

                # Check if there's a discrepancy in the hashed representation.
                if diff:
                    # If so, create a new dependency that accurately reflects the current points.
                    d = Dependency('eqangle', [a, b, c, d, m, n, p, q], None, level)
                    d.why = whyeqangle  # Assign the reasons to this new dependency.
                    whyeqangle = [d]    # Update the list of reasons to include this new dependency.

                # Add the reasons for equal angles to the 'why' list.
                self.why += whyeqangle

            # If there are no reasons for equal angles:
            else:
                # Check if any two pairs of lines are identical.
                if (ab == cd and mn == pq) or (ab == mn and cd == pq):
                    # If so, no additional reasons are needed.
                    self.why += []

                # Check various combinations of lines to determine potential reasons for equal angles.
                elif ab == mn:
                    # If lines ab and mn are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        a, b, c, d, m, n, p, q, ab, mn, g, level
                    )
                elif cd == pq:
                    # If lines cd and pq are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        c, d, a, b, p, q, m, n, cd, pq, g, level
                    )
                elif ab == cd:
                    # If lines ab and cd are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        a, b, m, n, c, d, p, q, ab, cd, g, level
                    )
                elif mn == pq:
                    # If lines mn and pq are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        m, n, a, b, p, q, c, d, mn, pq, g, level
                    )

                # Check if the lines (ab w/ mn and cd w/ pq) are parallel based on equal angle conditions.
                elif g.is_equal(ab, mn) or g.is_equal(cd, pq):
                    # Create a new Dependency object for parallelism between lines ab and mn.
                    dep1 = Dependency('para', [a, b, m, n], None, level)
                    # Determine the reasons why lines ab and mn are parallel.
                    dep1.why_me(g, level)
                    # Create another Dependency object for parallelism between lines cd and pq.
                    dep2 = Dependency('para', [c, d, p, q], None, level)
                    # Determine the reasons why lines cd and pq are parallel.
                    dep2.why_me(g, level)
                    # Add these dependencies to the 'why' list of the current dependency.
                    self.why += [dep1, dep2]

                # Similar check for parallelism between ab & cd and mn & pq.
                elif g.is_equal(ab, cd) or g.is_equal(mn, pq):
                    # Create a new Dependency object for parallelism between lines ab and cd.
                    dep1 = Dependency('para', [a, b, c, d], None, level)
                    # Determine the reasons why lines ab and cd are parallel.
                    dep1.why_me(g, level)
                    # Create another Dependency object for parallelism between lines mn and pq.
                    dep2 = Dependency('para', [m, n, p, q], None, level)
                    # Determine the reasons why lines mn and pq are parallel.
                    dep2.why_me(g, level)
                    # Add these dependencies to the 'why' list of the current dependency.
                    self.why += [dep1, dep2]

                # If all line segments have valid values
                elif ab._val and cd._val and mn._val and pq._val:
                    # Check for reasons of equal angles.
                    self.why = why_eqangle(ab._val, cd._val, mn._val, pq._val, level)
        
        # We now handle cases where the geometric construction involves checking equality of ratios (eqratio or eqratio6). 
        #   - This is a part of geometric reasoning that looks into the relationships between different segments.
        elif self.name in ['eqratio', 'eqratio6']:
            # Extracting the points that define the segments for ratio comparison.
            a, b, c, d, m, n, p, q = self.args

            # Getting the segments ab, cd, mn, pq from the geometry context 'g'.
            ab = g._get_segment(a, b)
            cd = g._get_segment(c, d)
            mn = g._get_segment(m, n)
            pq = g._get_segment(p, q)

            # Check if any of these segments are undefined, possibly due to overlapping points.
            if ab is None or cd is None or mn is None or pq is None:
                # If any pair of points defining a segment are the same, then we are looking at congruence, not ratio.
                if {a, b} == {m, n}:
                    # Create a congruence dependency and find its reasoning.
                    d = Dependency('cong', [c, d, p, q], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                # Similar checks for other combinations of points.
                if {a, b} == {c, d}:
                    d = Dependency('cong', [p, q, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                if {c, d} == {p, q}:
                    d = Dependency('cong', [a, b, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                if {p, q} == {m, n}:
                    d = Dependency('cong', [a, b, c, d], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                return  # Exit if any segments are undefined.

            # If all segments are well-defined, check if their ratios are equal.
            if ab._val and cd._val and mn._val and pq._val:
                self.why = why_eqratio(ab._val, cd._val, mn._val, pq._val, level)

            # If no specific reason for equal ratios is found, explore other possibilities.
            if self.why is None:
                self.why = []  # Initialize an empty list for reasons.

                # Check for direct equality of segments which would imply equal ratios.
                if (ab == cd and mn == pq) or (ab == mn and cd == pq):
                    self.why += []  # No additional dependencies are needed in this case.
                elif ab == mn:
                    # If segments ab and mn are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(a, b, c, d, m, n, p, q, ab, mn, g, level)
                elif cd == pq:
                    # If segments cd and pq are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(c, d, a, b, p, q, m, n, cd, pq, g, level)
                elif ab == cd:
                    # If segments ab and cd are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(a, b, m, n, c, d, p, q, ab, cd, g, level)
                elif mn == pq:
                    # If segments mn and pq are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(m, n, a, b, p, q, c, d, mn, pq, g, level)

                # Check if segments are parallel as a possible reason for equal ratios.
                if g.is_equal(ab, mn) or g.is_equal(cd, pq):
                    # Create and resolve dependencies for parallel lines (ab//mn or cd//pq).
                    dep1 = Dependency('para', [a, b, m, n], None, level)
                    dep1.why_me(g, level)
                    dep2 = Dependency('para', [c, d, p, q], None, level)
                    dep2.why_me(g, level)
                    self.why += [dep1, dep2]
                if g.is_equal(ab, cd) or g.is_equal(mn, pq):
                    # Create and resolve dependencies for parallel lines (ab//cd or mn//pq).
                    dep1 = Dependency('para', [a, b, c, d], None, level)
                    dep1.why_me(g, level)
                    dep2 = Dependency('para', [m, n, p, q], None, level)
                    dep2.why_me(g, level)
                    self.why += [dep1, dep2]

                # Finally, if all else fails, re-check for equal angles as a last resort.
                if ab._val and cd._val and mn._val and pq._val:
                    self.why = why_eqangle(ab._val, cd._val, mn._val, pq._val, level)

        # These are different types of geometric dependencies.
        elif self.name in ['diff', 'npara', 'nperp', 'ncoll', 'sameside']:
            # For these types, currently, no additional dependencies are determined.
            #   - This might represent cases where the dependency is either direct or not yet implemented.
            self.why = []

        # Handling the case of similar triangles.
        elif self.name == 'simtri':
            # Extracts the points defining the two triangles.
            a, b, c, x, y, z = self.args

            # Creates a dependency for equal angles between the two triangles.
            #   - i.e. angle at 'a' in the first triangle should be equal to the angle at 'x' in the second triangle.
            dep1 = Dependency('eqangle', [a, b, a, c, x, y, x, z], '', level)
            dep1.why_me(g, level)  # Determines why these angles are equal.

            # Similarly, this checks for equality of another pair of angles.
            dep2 = Dependency('eqangle', [b, a, b, c, y, x, y, z], '', level)
            dep2.why_me(g, level)

            # Assigns a rule name for this type of dependency.
            self.rule_name = 'r34'

            # Records these dependencies.
            self.why = [dep1, dep2]

        # Handling the case of congruent triangles.
        elif self.name == 'contri':
            # Extracts the points defining the two triangles.
            a, b, c, x, y, z = self.args

            # Checks for congruence (equality of length) between corresponding sides (ab w/ xy) of the triangles.
            dep1 = Dependency('cong', [a, b, x, y], '', level)
            # Determines why these segments (ab w/ xy) are congruent.
            dep1.why_me(g, level)  
            
            # Checks for congruence (equality of length) between corresponding sides (bc w/ yz) of the triangles.
            dep2 = Dependency('cong', [b, c, y, z], '', level)
            # Determines why these segments (bc w/ yz) are congruent.
            dep2.why_me(g, level)
            
            # Checks for congruence (equality of length) between corresponding sides (ca w/ zx) of the triangles.
            dep3 = Dependency('cong', [c, a, z, x], '', level)
            # Determines why these segments (ca w/ zx) are congruent.
            dep3.why_me(g, level)

            # Assigns a rule name for this type of dependency.
            self.rule_name = 'r32'

            # Records these dependencies.
            self.why = [dep1, dep2, dep3]

        # This case represents 'independence'. 
        #   - This appears to be a placeholder for dependencies that don't need further explanation or are considered axiomatic.
        elif self.name == 'ind':
            # No action is taken for 'independent' dependencies.
            pass  

        # Handling the case for a constant angle.
        elif self.name == 'aconst':
            # Extracts points and the angle of interest.
            a, b, c, d, ang0 = self.args

            # Gets the value of the angle.
            measure = ang0._val

            # Iterates over angles neighboring the given angle in the geometric context.
            for ang in measure.neighbors(gm.Angle):
                
                # Skips this angle if it's the same angle as the original.
                if ang == ang0:
                    continue  

                # Extracts line objects from the neighboring angle.
                d1, d2 = ang._d
                l1, l2 = d1._obj, d2._obj
                (a1, b1), (c1, d1) = l1.points, l2.points

                # Checks if lines are parallel or collinear.
                #   - If not than we skip this angle
                if not g.check_para_or_coll([a, b, a1, b1]) or not g.check_para_or_coll([c, d, c1, d1]):
                    continue

                # Clears previous reasons, preparing to record new ones.
                self.why = []

                # For each set of arguments, checks if they are collinear.
                for args in [(a, b, a1, b1), (c, d, c1, d1)]:
                    if g.check_coll(args):
                        # If they are collinear and involve more than two unique points
                        if len(set(args)) > 2:
                            dep = Dependency('coll', args, None, None)
                            # A collinearity dependency is added.
                            self.why.append(dep.why_me_or_cache(g, level))
                    else:
                        # If they are not collinear
                        dep = Dependency('para', args, None, None)
                        # a parallel dependency is added.
                        self.why.append(dep.why_me_or_cache(g, level))

                # Adds reasons explaining the equality of the given angle with its neighboring angles.
                self.why += gm.why_equal(ang, ang0)
                
                # Exits after processing the first relevant angle.
                break  

        # Handling the case for a constant ratio.
        elif self.name == 'rconst':
            # Extracts points and the ratio of interest.
            a, b, c, d, rat0 = self.args

            # Gets the value of the ratio.
            val = rat0._val

            # Iterates over ratios neighboring the given ratio in the geometric context.
            for rat in val.neighbors(gm.Ratio):
                
                # If this ratio is the same ratio as the original we skip it
                if rat == rat0:
                    continue  

                # Extracts line objects from the neighboring ratio.
                l1, l2 = rat._l
                s1, s2 = l1._obj, l2._obj
                (a1, b1), (c1, d1) = list(s1.points), list(s2.points)

                # Checks if corresponding segments are congruent
                #   - If not, then we skip this ratio
                if not g.check_cong([a, b, a1, b1]) or not g.check_cong([c, d, c1, d1]):
                    continue  

                # Clears previous reasons, preparing to record new ones.
                self.why = []

                # For each set of arguments
                for args in [(a, b, a1, b1), (c, d, c1, d1)]:
                    if len(set(args)) > 2:
                        dep = Dependency('cong', args, None, None)
                        # Add a congruency dependency
                        self.why.append(dep.why_me_or_cache(g, level))

                # Adds reasons explaining the equality of the given ratio with its neighboring ratios.
                self.why += gm.why_equal(rat, rat0)
                
                # Exits after processing the first relevant ratio.
                break  

        # This case handles unrecognized dependency names.
        else:
            # Raises an error if the dependency name is not recognized.
            raise ValueError('Not recognized', self.name)


    def hashed(self, rename: bool = False) -> tuple[str, ...]:
        """"""
        Creates a hash-like tuple representation for the Dependency object.

        Args:
            rename (bool, optional): If True, use alternative names for the points.

        Returns:
            tuple[str, ...]: A tuple representing the hashed value of the dependency.

        Example Usage:
            >>> dep = Dependency('line', [Point('A'), Point('B')], 'rule1', 1)
            >>> dep.hashed()
            ('line', 'A', 'B')

        Note:
            This method is used for caching and identifying unique dependencies.
        """"""
        
        # Utilize the hashed function to create the tuple.
        return hashed(self.name, self.args, rename=rename)  
    

class EmptyDependency:
    """"""
    Represents an initially empty geometric dependency that can be filled and extended.

    This class is used as a starting point for constructing more complex dependencies in geometric reasoning.
    It allows for incremental building up of a dependency from simpler components.

    Attributes:
        level (int): The level of complexity or derivation for the dependency.
        rule_name (str): Name of the rule associated with the dependency, if any.
        empty (bool): A flag indicating whether the dependency is empty.
        why (list[Dependency]): A list of Dependency objects that this one depends on.
        trace (Any): Optional attribute for debugging or tracing the dependency.

    Methods:
        populate: Fills the empty dependency with details.
        copy: Creates a deep copy of the empty dependency.
        extend: Adds a new dependency to the list.
        extend_many: Adds multiple new dependencies to the list.
    """"""

    def __init__(self, level: int, rule_name: str):
        """"""
        Initializes an EmptyDependency object.

        Args:
            level (int): The complexity level for the dependency.
            rule_name (str): The rule name associated with this dependency, if applicable.

        The object starts with no dependencies (empty list) and is marked as empty.
        """"""
        # Complexity level of the dependency.
        self.level = level  
        
        # Rule name, defaulting to an empty string if not provided.
        self.rule_name = rule_name or ''  
        
        # Initially marked as empty.
        self.empty = True  
        
        # Initializes with no dependencies.
        self.why = []  
        
        # Optional tracing information, initially None.
        self.trace = None  

    def populate(self, name: str, args: list[gm.Point]) -> Dependency:
        """"""
        Populates the current empty dependency with a specific dependency.

        Args:
            name (str): The name of the dependency to be populated with.
            args (list[gm.Point]): The points or elements involved in the dependency.

        Returns:
            Dependency: A Dependency object populated with the given details.

        Example Usage:
            >>> empty_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> populated_dep = empty_dep.populate('line', [Point('A'), Point('B')])
            # populated_dep is now a Dependency object representing a line with points 'A', 'B'.
        """"""
        
        # Create the dependency from the provided information
        dep = Dependency(name, args, self.rule_name, self.level)
        
        # Inherit trace information from the empty dependency.
        dep.trace2 = self.trace  
        
        # Copies the 'why' list to the new dependency.
        dep.why = list(self.why)  
    
        return dep

    def copy(self) -> EmptyDependency:
        """"""
        Creates a deep copy of the current EmptyDependency object.

        Returns:
            EmptyDependency: A new EmptyDependency object that is a copy of the current one.

        Example Usage:
            >>> original_empty_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> copied_empty_dep = original_empty_dep.copy()
            # copied_empty_dep is a separate instance with the same data as original_empty_dep.
        """"""
        
        # Initialize a new EmptyDependency
        other = EmptyDependency(self.level, self.rule_name)
        
        # Maps the 'why' over to the new EmptyDependency
        other.why = list(self.why)  
        
        return other

    def extend(
            self,
            g: Any,
            name0: str,
            args0: list[gm.Point],
            name: str,
            args: list[gm.Point],
    ) -> EmptyDependency:
        """"""
        Extends the current dependency with a new one.

        This method adds a new dependency to the existing list of dependencies.

        Args:
            g (Any): The geometric context or environment.
            name0 (str): The name of the initial dependency.
            args0 (list[gm.Point]): The points involved in the initial dependency.
            name (str): The name of the new dependency to be added.
            args (list[gm.Point]): The points involved in the new dependency.

        Returns:
            EmptyDependency: An updated EmptyDependency object with the new dependency added.

        Example Usage:
            >>> current_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> extended_dep = current_dep.extend(geometry_context, 'line', [Point('A'), Point('B')], 'para', [Point('C'), Point('D')])
            # extended_dep now includes dependencies for a line (AB) and parallelism (CD).
        """"""
        # Populates the current dependency with the initial dependency details.
        dep0 = self.populate(name0, args0)
        
        # Creates a new EmptyDependency object.
        deps = EmptyDependency(level=self.level, rule_name=None)
        
        # Adds the new dependency to the list.
        dep = Dependency(name, args, None, deps.level)
        deps.why = [dep0, dep.why_me_or_cache(g, None)]
        
        return deps

    def extend_many(
            self,
            g: Any,
            name0: str,
            args0: list[gm.Point],
            name_args: list[tuple[str, list[gm.Point]]],
    ) -> EmptyDependency:
        """"""
        Extends the current dependency with multiple new dependencies.

        This method allows adding several new dependencies at once.

        Args:
            g (Any): The geometric context or environment.
            name0 (str): The name of the initial dependency.
            args0 (list[gm.Point]): The points involved in the initial dependency.
            name_args (list[tuple[str, list[gm.Point]]]): A list of tuples, each containing a dependency name and its associated points.

        Returns:
            EmptyDependency: An updated EmptyDependency object with the new dependencies added.

        Example Usage:
            >>> current_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> name_args = [('para', [Point('C'), Point('D')]), ('coll', [Point('E'), Point('F')])]
            >>> extended_dep = current_dep.extend_many(geometry_context, 'line', [Point('A'), Point('B')], name_args)
            # extended_dep now includes dependencies for a line (AB), parallelism (CD), and collinearity (EF).
        """"""
        # Return the current dependency if no new dependencies are provided.
        if not name_args:
            return self

        # Populates the current dependency with the initial dependency details.
        dep0 = self.populate(name0, args0)
        
        # Creates a new EmptyDependency object.
        deps = EmptyDependency(level=self.level, rule_name=None)
        
        # Adds the initial dependency to the list.
        deps.why = [dep0]

        # Iterates over each new dependency and adds them to the list along with the 'why'
        for name, args in name_args:
            dep = Dependency(name, args, None, deps.level)
            deps.why += [dep.why_me_or_cache(g, None)]
        
        return deps
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.9 <code><b>PROBLEM.PY</b></code> FILE - THE SPECIFIC/COMPLEX <b>FUNCTIONS</b></h3>

def why_eqratio(
        d1: gm.Direction,
        d2: gm.Direction,
        d3: gm.Direction,
        d4: gm.Direction,
        level: int,
) -> list[Dependency]:
    """"""Determines the reasons for equality of two geometric ratios.

    This function is used in the context of geometric reasoning to explain why two ratios, 
    formed by pairs of directions, are equal. It explores all combinations of equivalent ratios 
    and finds the minimal explanation for their equality.

    Args:
        d1 (gm.Direction): The first direction in the first ratio.
        d2 (gm.Direction): The second direction in the first ratio.
        d3 (gm.Direction): The first direction in the second ratio.
        d4 (gm.Direction): The second direction in the second ratio.
        level (int): The level of abstraction for the reasoning.

    Returns:
        list[Dependency]: A list of Dependency objects representing the reasons for the equality of the two ratios.

    Example Usage:
        # Assuming d1, d2, d3, d4 are gm.Direction instances and 'level' is set.
        >>> reasons = why_eqratio(d1, d2, d3, d4, level)
    """"""
    
    # Generate all possible equivalent ratios for the first and second pairs of directions.
    all12 = list(gm.all_ratios(d1, d2, level))
    all34 = list(gm.all_ratios(d3, d4, level))

    # Initialize a variable to keep track of the minimal explanation for ratio equality.
    min_why = None

    # Iterate through each combination of equivalent ratios from the first and second pairs.
    for ang12, d1s, d2s in all12:
        for ang34, d3s, d4s in all34:
            
            # Check if these two ratios are equal and if so why
            why0 = gm.why_equal(ang12, ang34, level)
            
            # Skip to the next combination if these two are not equal.
            if why0 is None:
                continue
            
            # Get the directions involved in the ratios
            d1_, d2_ = ang12._l
            d3_, d4_ = ang34._l
            
            # Backtrack to find the path of dependencies for each direction involved in the ratios.
            why1 = gm.bfs_backtrack(d1, [d1_], d1s)
            why2 = gm.bfs_backtrack(d2, [d2_], d2s)
            why3 = gm.bfs_backtrack(d3, [d3_], d3s)
            why4 = gm.bfs_backtrack(d4, [d4_], d4s)

            # Compile all reasons (dependencies) for the equality of these ratios.
            why = why0 + why1 + why2 + why3 + why4

            # Update the minimal explanation if the current explanation is more concise.
            if min_why is None or len(why) < len(min_why[0]):
                min_why = why, ang12, ang34, why0, why1, why2, why3, why4

    # If no explanation is found, return None.
    if min_why is None:
        return None

    # Extract from the minimal explanation the involved dependancies (whys), angles and directions.
    _, ang12, ang34, why0, why1, why2, why3, why4 = min_why

    # If the original and compared directions are the same, return the reasons for their equality.
    d1_, d2_ = ang12._l
    d3_, d4_ = ang34._l
    if d1 == d1_ and d2 == d2_ and d3 == d3_ and d4 == d4_:
        return why0

    # Extract the points for each direction to create dependencies.
    (a_, b_), (c_, d_) = d1_._obj.points, d2_._obj.points
    (e_, f_), (g_, h_) = d3_._obj.points, d4_._obj.points
    
    # Initialize the list of dependencies
    deps = []

    # If reasons for equality exist, create and append a Dependency object.
    if why0:
        dep = Dependency('eqratio', [a_, b_, c_, d_, e_, f_, g_, h_], '', level)
        dep.why = why0
        deps.append(dep)

    # Iterate through each set of points and append necessary dependencies (congruent).
    (a, b), (c, d) = d1._obj.points, d2._obj.points
    (e, f), (g, h) = d3._obj.points, d4._obj.points
    for why, (x, y), (x_, y_) in zip(
            [why1, why2, why3, why4],                 # reason (or None)
            [(a, b), (c, d), (e, f), (g, h)],         # pair of points (1)
            [(a_, b_), (c_, d_), (e_, f_), (g_, h_)], # pair of points (2)
    ):
        if why:
            dep = Dependency('cong', [x, y, x_, y_], '', level)
            dep.why = why
            deps.append(dep)

    # Return the list of dependencies explaining the equality of the ratios.
    return deps


def why_eqangle(
        d1: gm.Direction,
        d2: gm.Direction,
        d3: gm.Direction,
        d4: gm.Direction,
        level: int,
        verbose: bool = False,
) -> list[Dependency]:
    """"""Determines the reasons for equality of two geometric angles.

    This function explains why two angles, formed by pairs of directions, are equal.
    It compares all combinations of equivalent angles and determines the minimal
    explanation for their equality.

    Args:
        d1, d2 (gm.Direction): Directions forming the first angle.
        d3, d4 (gm.Direction): Directions forming the second angle.
        level (int): The level of abstraction for the reasoning.
        verbose (bool, optional): If true, provides more detailed explanation. Defaults to False.

    Returns:
        list[Dependency]: A list of Dependency objects representing the reasons for the equality of the two angles.

    Example Usage:
        # Assuming d1, d2, d3, d4 are gm.Direction instances and 'level' is set.
        >>> reasons = why_eqangle(d1, d2, d3, d4, level)
    """"""
    # Generate all possible equivalent angles for the first and second pairs of directions.
    all12 = list(gm.all_angles(d1, d2, level))
    all34 = list(gm.all_angles(d3, d4, level))

    # Initialize a variable to keep track of the minimal explanation for angle equality.
    min_why = None

    # Iterate through each combination of equivalent angles from the first and second pairs.
    for ang12, d1s, d2s in all12:
        for ang34, d3s, d4s in all34:
            # Check if these two angles are equal.
            why0 = gm.why_equal(ang12, ang34, level)
            # Skip to the next combination if these two are not equal.
            if why0 is None:
                continue

            # Backtrack to find the path of dependencies for each direction involved in the angles.
            d1_, d2_ = ang12._d
            d3_, d4_ = ang34._d
            why1 = gm.bfs_backtrack(d1, [d1_], d1s)
            why2 = gm.bfs_backtrack(d2, [d2_], d2s)
            why3 = gm.bfs_backtrack(d3, [d3_], d3s)
            why4 = gm.bfs_backtrack(d4, [d4_], d4s)

            # Compile all reasons (dependencies) for the equality of these angles.
            why = why0 + why1 + why2 + why3 + why4

            # Update the minimal explanation if the current explanation is more concise.
            if min_why is None or len(why) < len(min_why[0]):
                min_why = why, ang12, ang34, why0, why1, why2, why3, why4

    # If no explanation is found, return None.
    if min_why is None:
        return None

    # Extract from the minimal explanation the involved dependancies (whys), angles and directions.
    _, ang12, ang34, why0, why1, why2, why3, why4 = min_why
    why0 = gm.why_equal(ang12, ang34, level)
    d1_, d2_ = ang12._d
    d3_, d4_ = ang34._d

    # If the original and compared directions are the same, return the reasons for their equality.
    if d1 == d1_ and d2 == d2_ and d3 == d3_ and d4 == d4_:
        return (d1_, d2_, d3_, d4_), why0

    # Extract the points for each direction to create dependencies.
    (a_, b_), (c_, d_) = d1_._obj.points, d2_._obj.points
    (e_, f_), (g_, h_) = d3_._obj.points, d4_._obj.points
    deps = []

    # If reasons for equality exist, create and append a Dependency object.
    if why0:
        dep = Dependency('eqangle', [a_, b_, c_, d_, e_, f_, g_, h_], '', None)
        dep.why = why0
        deps.append(dep)

    # Iterate through each set of points and append necessary dependencies.
    # We are iterating over a combined sequence of various elements:
    #   1. 'why1' to 'why4' are the reasons for the equality of the directions.
    #   2. 'd1' to 'd4' are the original direction objects.
    #   3. '(a, b)' to '(g, h)' are point pairs defining the original directions.
    #   4. 'd1_' to 'd4_' are the resultant direction objects after backtracking.
    #   5. '(a_, b_)' to '(g_, h_)' are point pairs defining the resultant directions.

    (a, b), (c, d) = d1._obj.points, d2._obj.points
    (e, f), (g, h) = d3._obj.points, d4._obj.points
    for why, d_xy, (x, y), d_xy_, (x_, y_) in zip(
            [why1, why2, why3, why4],
            [d1, d2, d3, d4],
            [(a, b), (c, d), (e, f), (g, h)],
            [d1_, d2_, d3_, d4_],
            [(a_, b_), (c_, d_), (e_, f_), (g_, h_)],
    ):
        # Extract the actual line (or segment) objects associated with the directions.
        xy, xy_ = d_xy._obj, d_xy_._obj

        # Check if there are valid reasons ('why') for the equality of directions.
        if why:
            # Determine the type of geometric relationship:
            #   - If the original and resultant lines (segments) are the same, we use 'collx'.
            #     - 'collx' implies an extended collinearity
            #   - Otherwise, we infer that they are parallel, using 'para'.
            #     - 'para' implies parallelism.
            if xy == xy_:
                name = 'collx'
            else:
                name = 'para'

            # Create a Dependency object to encapsulate this geometric relationship.
            #   - The Dependency object takes:
            #     - the name ('collx' or 'para')
            #     - the points involved,
            #     - an empty string for the rule name
            #     - and the level of abstraction.
            dep = Dependency(name, [x_, y_, x, y], '', None)

            # Assign the reasons ('why') to this Dependency object.
            dep.why = why

            # Append the Dependency object to the list of dependencies ('deps').
            deps.append(dep)

    # Return the list of dependencies explaining the equality of the angles.
    return (d1_, d2_, d3_, d4_), deps

# This constant represents a default rule name used in the context of geometric dependencies. 
#   - It's a placeholder/identifier for a basic rule in the geometric reasoning system.
CONSTRUCTION_RULE = 'c0'


def maybe_make_equal_pairs(
        a: gm.Point,
        b: gm.Point,
        c: gm.Point,
        d: gm.Point,
        m: gm.Point,
        n: gm.Point,
        p: gm.Point,
        q: gm.Point,
        ab: gm.Line,
        mn: gm.Line,
        g: Any,
        level: int,
) -> list[Dependency]:
    """"""Generates dependencies if certain line pairs are equal.

    This function creates dependencies based on the equality of geometric lines.
    It's used in geometric reasoning to infer dependencies from equal line segments or directions.

    Args:
        a, b, c, d, m, n, p, q (gm.Point): Points involved in the line segments.
        ab, mn (gm.Line): Line segments or directions to compare for equality.
        g (Any): Geometric context or environment.
        level (int): The level of abstraction for reasoning.

    Returns:
        list[Dependency]: A list of dependencies if the line pairs are equal, otherwise an empty list.

    Example Usage:
        # Assuming the points and lines are defined and 'level' is set.
        >>> dependencies = maybe_make_equal_pairs(a, b, c, d, m, n, p, q, ab, mn, g, level)
        
    Notes:
        Make a-b:c-d==m-n:p-q in case a-b==m-n or c-d==p-q.
    """"""
    if ab != mn:
        return
    why = []
    eqname = 'para' if isinstance(ab, gm.Line) else 'cong'
    colls = [a, b, m, n]
    if len(set(colls)) > 2 and eqname == 'para':
        dep = Dependency('collx', colls, None, level)
        dep.why_me(g, level)
        why += [dep]

    dep = Dependency(eqname, [c, d, p, q], None, level)
    dep.why_me(g, level)
    why += [dep]
    return why

def compare_fn(dep: Dependency) -> tuple[Dependency, str]:
    """"""A helper function for sorting dependencies.

    This function is used as a key function in sorting dependencies. It creates a tuple
    from a dependency and its string representation, used for comparison.

    Args:
        dep (Dependency): A dependency object.

    Returns:
        tuple[Dependency, str]: A tuple with the dependency and its string representation.

    Example Usage:
        # Assuming 'deps' is a list of Dependency objects.
        >>> sorted_deps = sorted(deps, key=compare_fn)
    """"""
    return (dep, pt.pretty(dep))


def sort_deps(deps: list[Dependency]) -> list[Dependency]:
    """"""Sorts a list of Dependency objects.

    This function sorts dependencies based on a custom sorting function, `compare_fn`.
    It's useful for organizing or prioritizing dependencies in geometric reasoning.

    Args:
        deps (list[Dependency]): A list of Dependency objects.

    Returns:
        list[Dependency]: A sorted list of Dependency objects.

    Example Usage:
        # Assuming 'deps' is a list of Dependency objects.
        >>> sorted_deps = sort_deps(deps)
    """"""
    return sorted(deps, key=compare_fn)
<br>

<a id=""ar""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""numericals"">6&nbsp;&nbsp;NUMERICALS &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.1 <code><b>NUMERICALS.PY</b></code> FILE <b>IMPORTS</b></h3>
<hr>

We can see by the imports that we are mostly dealing the **`geometry`** submodule and a few additional packages (i.e. <a href=""https://docs.python.org/3/library/fractions.html"">`Fractions`</a>, `NumPy`, `SciPy`, etc.)

We also include the license information here as found within the original file:
* https://github.com/google-deepmind/alphageometry/blob/main/ar.py
* **Apache License, Version 2.0**
# Copyright 2023 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

""""""Numerical representation of geometry.""""""
from __future__ import annotations

import math
from typing import Any, Optional, Union

import matplotlib
import matplotlib.colors as mcolors
import numpy as np
from matplotlib import pyplot as plt
from numpy.random import uniform as unif  # pylint: disable=g-importing-member

# import geometry as gm

# WE USE Agg instead of TkAgg due to Kaggle limitations
matplotlib.use('Agg')

HCOLORS = None
THEME = 'dark'
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.2 <code><b>NUMERICALS.PY</b></code> FILE - THE GEOMETRIC <b>CLASSES</b></h3>


| **Function Name**                | **Description**                                                                         | **Parameters**                                                                                                                                                                                                  | **Returns**                                                                                | **Notes**                                                               |
|:----------------------------------:|-----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|-------------------------------------------------------------------------|
| **`_perpendicular_bisector`**    | Constructs a line that is the perpendicular bisector of the segment between two points. | **`p1`**, **`p2`**: Points defining the segment.                                                                                                                                                                | **`Line`**: The perpendicular bisector.                                                    | -                                                                       |
| **`same_sign`**                  | Checks if two sets of points have the same rotational direction.                        | **`a`**, **`b`**, **`c`**, **`d`**, **`e`**, **`f`**: Points to check.                                                                                                                                          | **`bool`**: True if same rotational direction, otherwise False.                            | Uses cross product.                                                     |
| **`solve_quad`**                 | Solves a quadratic equation of the form ax^2 + bx + c = 0.                              | **`a`**, **`b`**, **`c`**: Coefficients of the equation.                                                                                                                                                        | **`tuple[float, float]`**: Solutions of the equation.                                      | Returns **`None`** if no real solutions.                                |
| **`circle_circle_intersection`** | Finds intersection points of two circles.                                               | **`c1`**, **`c2`**: The two circles to intersect.                                                                                                                                                               | **`tuple[Point, Point]`**: Intersection points.                                            | Raises **`InvalidQuadSolveError`** for certain conditions.              |
| **`line_circle_intersection`**   | Calculates intersection points of a line and a circle.                                  | **`line`**: The line, **`circle`**: The circle.                                                                                                                                                                 | **`tuple[Point, Point]`**: Intersection points.                                            | Handles vertical and horizontal lines specially.                        |
| **`_check_between`**             | Checks if a point is between two other points.                                          | **`a`**, **`b`**, **`c`**: The points to check.                                                                                                                                                                 | **`bool`**: True if **`a`** is between **`b`** and **`c`**.                                | Uses dot product for the check.                                         |
| **`circle_segment_intersect`**   | Finds intersection points between a circle and a line segment.                          | **`circle`**: The circle, **`p1`**, **`p2`**: Endpoints of the segment.                                                                                                                                         | **`list[Point]`**: Intersection points.                                                    | Filters out points not on the segment.                                  |
| **`line_segment_intersection`**  | Calculates the intersection point of a line and a line segment.                         | **`l`**: The line, **`A`**, **`B`**: Endpoints of the segment.                                                                                                                                                  | **`Point`**: Intersection point.                                                           | -                                                                       |
| **`line_line_intersection`**     | Finds the intersection point of two lines.                                              | **`l1`**, **`l2`**: The lines to intersect.                                                                                                                                                                     | **`Point`**: Intersection point.                                                           | Raises **`InvalidLineIntersectError`** if lines are parallel.           |
| **`check_too_close`**            | Checks if any new point is too close to existing points.                                | **`newpoints`**: List of new points, **`points`**: List of existing points, **`tol`**: Tolerance factor.                                                                                                        | **`bool`**: True if any new point is too close to existing points.                         | Compares distances based on a minimum distance threshold.               |
| **`check_too_far`**              | Checks if any new point is too far from existing points.                                | **`newpoints`**: List of new points, **`points`**: List of existing points, **`tol`**: Tolerance factor.                                                                                                        | **`bool`**: True if any new point is too far from existing points.                         | Compares distances based on a maximum distance threshold.               |
| **`check_aconst`**               | Checks if an angle between points matches a given constant ratio.                       | **`args`**: List containing points **`a`**, **`b`**, **`c`**, **`d`** and angle ratio **`num`**, **`den`**.                                                                                                     | **`bool`**: True if angle matches the constant.                                            | Uses **`ang_between`** for angle calculation.                           |
| **`check`**                      | Performs various geometric checks based on the provided name.                           | **`name`**: Name of the check, **`args`**: List of points or geometric objects.                                                                                                                                 | **`bool`**: Result of the check.                                                           | Delegates to specific **`check_`** functions.                           |
| **`check_circle`**               | Checks if points form a circle.                                                         | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points form a circle.                                                  | Ensures equal distances from a common point.                            |
| **`check_coll`**                 | Checks if points are collinear.                                                         | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points are collinear.                                                  | Uses line equation for the check.                                       |
| **`check_ncoll`**                | Checks if points are not collinear.                                                     | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points are not collinear.                                              | Negation of **`check_coll`**.                                           |
| **`check_sameside`**             | Checks if two sets of points are on the same side of a line.                            | **`points`**: List of six points.                                                                                                                                                                               | **`bool`**: True if on the same side.                                                      | Uses dot product for the check.                                         |
| **`check_para_or_coll`**         | Checks if points form parallel lines or are collinear.                                  | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if parallel or collinear.                                                 | Combines **`check_para`** and **`check_coll`**.                         |
| **`check_para`**                 | Checks if points form parallel lines.                                                   | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if lines are parallel.                                                    | Uses line properties for the check.                                     |
| **`check_perp`**                 | Checks if points form perpendicular lines.                                              | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if lines are perpendicular.                                               | Uses line properties for the check.                                     |
| **`check_cyclic`**               | Checks if points lie on a common circle.                                                | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points are cyclic.                                                     | Uses circle properties for the check.                                   |
| **`bring_together`**             | Brings points together based on line intersections.                                     | **`a`**, **`b`**, **`c`**, **`d`**: Points to be processed.                                                                                                                                                     | **`tuple[Point, Point, Point, Point]`**: New points after processing.                      | Uses line intersections to generate new points.                         |
| **`same_clock`**                 | Checks if two sets of points have the same clockwise order.                             | **`a`**, **`b`**, **`c`**, **`d`**, **`e`**, **`f`**: Points to check.                                                                                                                                          | **`bool`**: True if both sets have the same clockwise order.                               | Uses cross product to determine order.                                  |
| **`check_const_angle`**          | Checks if an angle between points is a constant.                                        | **`points`**: List containing points and constants.                                                                                                                                                             | **`bool`**: True if angle is constant.                                                     | Uses angle calculation and comparison.                                  |
| **`check_eqangle`**              | Checks if two sets of points form equal angles.                                         | **`points`**: List of eight points.                                                                                                                                                                             | **`bool`**: True if angles are equal.                                                      | Compares angles formed by line intersections.                           |
| **`check_eqratio`**              | Checks if ratios of distances between points are equal.                                 | **`points`**: List of eight points.                                                                                                                                                                             | **`bool`**: True if ratios are equal.                                                      | Compares ratios of distances.                                           |
| **`check_cong`**                 | Checks if distances between pairs of points are congruent.                              | **`points`**: List of four points.                                                                                                                                                                              | **`bool`**: True if distances are congruent.                                               | Compares distances directly.                                            |
| **`check_midp`**                 | Checks if a point is the midpoint between two other points.                             | **`points`**: List of three points.                                                                                                                                                                             | **`bool`**: True if one point is the midpoint.                                             | Ensures the distances to the midpoint are equal.                        |
| **`check_simtri`**               | Checks if two sets of points form similar triangles.                                    | **`points`**: List of six points.                                                                                                                                                                               | **`bool`**: True if triangles are similar.                                                 | Compares ratios of sides' lengths.                                      |
| **`check_contri`**               | Checks if two sets of points form congruent triangles.                                  | **`points`**: List of six points.                                                                                                                                                                               | **`bool`**: True if triangles are congruent.                                               | Compares lengths of corresponding sides.                                |
| **`check_ratio`**                | Checks if ratio of distances between pairs of points matches a given ratio.             | **`points`**: List containing points and the ratio.                                                                                                                                                             | **`bool`**: True if ratio matches.                                                         | Compares product of distances with the given ratio.                     |
| **`draw_angle`**                 | Draws an angle on a matplotlib axis.                                                    | **`ax`**: Matplotlib axis, **`head`**: Vertex of the angle, **`p1`**, **`p2`**: Points defining the angle, **`color`**, **`alpha`**, **`frac`**: Styling options.                                               | None                                                                                       | Uses arctan2 for angle calculation.                                     |
| **`naming_position`**            | Determines a good position for naming a point in a drawing.                             | **`ax`**: Matplotlib axis, **`p`**: Point to be named, **`lines`** and **`circles`**: Existing geometric objects.                                                                                               | **`tuple[float, float]`**: Position for the name.                                          | Avoids overlap with other objects.                                      |
| **`draw_point`**                 | Draws a point on a matplotlib axis.                                                     | **`ax`**: Matplotlib axis, **`p`**: Point to draw, **`name`**: Name of the point, **`lines`**, **`circles`**: Existing geometric objects, **`color`**, **`size`**: Styling options.                             | None                                                                                       | -                                                                       |
| **`_draw_line`**                 | Helper function to draw a line in matplotlib.                                           | **`ax`**: Matplotlib axis, **`p1`**, **`p2`**: Points defining the line, **`color`**, **`lw`**, **`alpha`**: Styling options.                                                                                   | None                                                                                       | -                                                                       |
| **`draw_line`**                  | Draws a line on a matplotlib axis.                                                      | **`ax`**: Matplotlib axis, **`line`**: Line to draw, **`color`**: Styling option.                                                                                                                               | **`tuple[Point, Point]`**: Points defining the line.                                       | Extends line to fit the drawing area.                                   |
| **`_draw_circle`**               | Helper function to draw a circle in matplotlib.                                         | **`ax`**: Matplotlib axis, **`c`**: Circle to draw, **`color`**, **`lw`**: Styling options.                                                                                                                     | None                                                                                       | -                                                                       |
| **`draw_circle`**                | Draws a circle on a matplotlib axis.                                                    | **`ax`**: Matplotlib axis, **`circle`**: Circle to draw, **`color`**: Styling option.                                                                                                                           | **`Circle`**: The drawn circle.                                                            | -                                                                       |
| **`mark_segment`**               | Marks a segment on a matplotlib axis.                                                   | **`ax`**: Matplotlib axis, **`p1`**, **`p2`**: Endpoints of the segment, **`color`**, **`alpha`**: Styling options.                                                                                             | None                                                                                       | Places a marker at the midpoint of the segment.                         |
| **`highlight_angle`**            | Highlights an angle in a matplotlib drawing.                                            | **`ax`**: Matplotlib axis, **`a`**, **`b`**, **`c`**, **`d`**: Points defining the angle, **`color`**, **`alpha`**: Styling options.                                                                            | None                                                                                       | Uses **`draw_angle`** for highlighting.                                 |
| **`highlight`**                  | Draws various highlights based on the provided name.                                    | **`ax`**: Matplotlib axis, **`name`**: Type of highlight, **`args`**: Points or objects for the highlight, **`lcolor`**, **`color1`**, **`color2`**: Styling options.                                           | None                                                                                       | Delegates to specific drawing functions based on **`name`**.            |
| **`_draw`**                      | Draws all elements on a matplotlib axis.                                                | **`ax`**: Matplotlib axis, **`points`**, **`lines`**, **`circles`**: Geometric objects to draw, **`goal`**, **`equals`**, **`highlights`**: Additional drawing parameters.                                      | None                                                                                       | Main function to handle drawing of all elements.                        |
| **`set_theme`**                  | Sets the theme for the drawing.                                                         | **`theme`**: The theme to set.                                                                                                                                                                                  | None                                                                                       | Global variable **`THEME`** is used.                                    |
| **`get_theme`**                  | Gets the current drawing theme.                                                         | None                                                                                                                                                                                                            | **`str`**: Current theme.                                                                  | -                                                                       |
| **`draw`**                       | Main function to draw everything on a single canvas.                                    | **`points`**, **`lines`**, **`circles`**, **`segments`**: Geometric objects, **`goal`**, **`highlights`**, **`equals`**: Additional parameters, **`block`**, **`save_to`**, **`theme`**: Configuration options. | None                                                                                       | Initializes and configures the matplotlib drawing.                      |
| **`close_enough`**               | Checks if two float values are close enough based on a tolerance.                       | **`a`**, **`b`**: Float values, **`tol`**: Tolerance.                                                                                                                                                           | **`bool`**: True if values are close enough.                                               | -                                                                       |
| **`assert_close_enough`**        | Asserts that two float values are close enough.                                         | **`a`**, **`b`**: Float values, **`tol`**: Tolerance.                                                                                                                                                           | None                                                                                       | Throws an assertion error if not                                        |
| **`ang_of`**                     | Calculates the angle of a line segment defined by two points.                           | **`tail`**, **`head`**: The points defining the line segment.                                                                                                                                                   | **`float`**: The angle in radians.                                                         | Uses **`np.arctan2`** for angle calculation.                            |
| **`ang_between`**                | Calculates the angle between two line segments sharing a common tail point.             | **`tail`**, **`head1`**, **`head2`**: The points defining the line segments.                                                                                                                                    | **`float`**: The angle in radians.                                                         | Adjusts angle to be within the range \[-π, π\].                         |
| **`head_from`**                  | Calculates the head point of a line segment given its tail, length, and angle.          | **`tail`**: Starting point, **`ang`**: Angle in radians, **`length`**: Length of the segment.                                                                                                                   | **`Point`**: The head point of the segment.                                                | -                                                                       |
| **`random_points`**              | Generates a list of random points.                                                      | **`n`**: Number of points to generate.                                                                                                                                                                          | **`list[Point]`**: List of randomly generated points.                                      | Points are within the range \[-1, 1\] for both x and y.                 |
| **`random_rfss`**                | Applies random rotation, flip, scale, and shift to a list of points.                    | **`points`**: List of points to transform.                                                                                                                                                                      | **`list[Point]`**: Transformed list of points.                                             | Used for creating variations in geometric configurations.               |
| **`reduce`**                     | Reduces intersecting geometric objects to points of intersection.                       | **`objs`**: List of geometric objects, **`existing_points`**: List of existing points for reference.                                                                                                            | **`list[Point]`**: Points of intersection.                                                 | Handles different types of intersections.                               |
| **`sketch`**                     | General function to sketch various geometric objects based on a name.                   | **`name`**: Name of the sketch function, **`args`**: Arguments for the sketch function.                                                                                                                         | **`list[Union[Point, Line, Circle, HalfLine, HoleCircle]]`**: Resulting geometric objects. | Delegates to specific **`sketch_`** functions.                          |
| **`sketch_on_opline`**           | Sketches a half-line opposite to a given line segment.                                  | **`args`**: Points defining the line segment.                                                                                                                                                                   | **`HalfLine`**: The opposite half-line.                                                    | -                                                                       |
| **`sketch_on_hline`**            | Sketches a half-line.                                                                   | **`args`**: Points defining the half-line.                                                                                                                                                                      | **`HalfLine`**: The sketched half-line.                                                    | -                                                                       |
| **`sketch_ieq_triangle`**        | Sketches an isosceles right-angled triangle.                                            | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: The triangle's vertices.                                          | -                                                                       |
| **`sketch_incenter2`**           | Sketches the incenter of a triangle and feet of angle bisectors.                        | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Incenter and feet of angle bisectors.                             | Uses angle bisectors to find the incenter.                              |
| **`sketch_excenter2`**           | Sketches an excenter of a triangle and feet of external angle bisectors.                | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Excenter and feet of external angle bisectors.                    | Uses external angle bisectors to find the excenter.                     |
| **`sketch_centroid`**            | Sketches the centroid of a triangle and midpoints of its sides.                         | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Centroid and midpoints of sides.                                  | Uses midpoints and line intersections to find the centroid.             |
| **`sketch_ninepoints`**          | Sketches the nine-point circle center of a triangle and midpoints of its sides.         | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Nine-point circle center and midpoints of sides.                  | Uses midpoints to find the nine-point circle center.                    |
| **`sketch_2l1c`**                | Sketches a circle touching two lines and another circle.                                | **`args`**: Points defining the lines and the circle.                                                                                                                                                           | **`tuple[Point, ...]`**: Points related to the construction.                               | Complex geometric construction involving lines and a circle.            |
| **`sketch_3peq`**                | Sketches points for creating a figure with three equal segments.                        | **`args`**: Points defining the base figure.                                                                                                                                                                    | **`tuple[Point, ...]`**: Points defining the equal segments.                               | -                                                                       |
| **`try_to_sketch_intersect`**    | Tries to find an intersection point between two sketched objects.                       | **`name1`**, **`args1`**: First object, **`name2`**, **`args2`**: Second object, **`existing_points`**: Reference points.                                                                                       | **`Optional[Point]`**: Intersection point if found.                                        | Handles different types of intersections.                               |
| **`sketch_acircle`**             | Sketches a circle based on specific geometric constraints.                              | **`args`**: Points defining the constraints.                                                                                                                                                                    | **`Circle`**: The resulting circle.                                                        | Uses line intersections to define the circle.                           |
| **`sketch_aline`**               | Sketches a construction line based on specific angles and points.                       | **`args`**: Points defining the angles and line.                                                                                                                                                                | **`HalfLine`**: The resulting construction line.                                           | Complex geometric construction involving angles.                        |
| **`sketch_amirror`**             | Sketches an angle mirror line.                                                          | **`args`**: Points defining the angle to mirror.                                                                                                                                                                | **`HalfLine`**: The angle mirror line.                                                     | -                                                                       |
| **`sketch_bisect`**              | Sketches a line that bisects the angle between two line segments.                       | **`args`**: Points defining the angle.                                                                                                                                                                          | **`Line`**: The angle bisector.                                                            | -                                                                       |
| **`sketch_exbisect`**            | Sketches a line that bisects the external angle between two line segments.              | **`args`**: Points defining the angle.                                                                                                                                                                          | **`Line`**: The external angle bisector.                                                   | -                                                                       |
| **`sketch_bline`**               | Sketches the perpendicular bisector of a line segment.                                  | **`args`**: Points defining the line segment.                                                                                                                                                                   | **`Line`**: The perpendicular bisector.                                                    | -                                                                       |
| **`sketch_dia`**                 | Sketches a circle with a given diameter.                                                | **`args`**: Points defining the diameter.                                                                                                                                                                       | **`Circle`**: The circle with the specified diameter.                                      | -                                                                       |
| **`sketch_tangent`**             | Sketches tangent points from a point to a circle.                                       | **`args`**: Points defining the circle and external point.                                                                                                                                                      | **`tuple[Point, Point]`**: Tangent points.                                                 | Uses circle properties to find tangent points.                          |
| **`sketch_circle`**              | Sketches a circle based on a center and a point on the circumference.                   | **`args`**: Points defining the circle.                                                                                                                                                                         | **`Circle`**: The sketched circle.                                                         | -                                                                       |
| **`sketch_cc_tangent`**          | Sketches tangents to two circles.                                                       | **`args`**: Points defining the circles.                                                                                                                                                                        | **`tuple[Point, ...]`**: Points of tangency.                                               | Complex geometric construction involving two circles.                   |
| **`sketch_hcircle`**             | Sketches a hole circle (circle with a known point inside).                              | **`args`**: Points defining the circle and the hole.                                                                                                                                                            | **`HoleCircle`**: The hole circle.                                                         | -                                                                       |
| **`sketch_e5128`**               | Sketches points for a specific geometric problem (E5128).                               | **`args`**: Points defining the problem.                                                                                                                                                                        | **`tuple[Point, Point]`**: Points related to the problem.                                  | -                                                                       |
| **`sketch_eq_quadrangle`**       | Sketches a quadrangle with two equal opposite sides.                                    | **`args`**: Points defining the base quadrangle.                                                                                                                                                                | **`tuple[Point, ...]`**: Points of the quadrangle.                                         | Randomized construction within constraints.                             |
| **`sketch_eq_trapezoid`**        | Sketches an isosceles trapezoid.                                                        | **`args`**: Points defining the base trapezoid.                                                                                                                                                                 | **`tuple[Point, ...]`**: Points of the trapezoid.                                          | Randomized construction within constraints.                             |
| **`sketch_eqangle2`**            | Sketches a point based on equal angles constraint.                                      | **`args`**: Points defining the angles.                                                                                                                                                                         | **`Point`**: The resulting point.                                                          | Complex geometric construction involving equal angles.                  |
| **`sketch_eqangle3`**            | Sketches a circle based on equal angle constraints.                                     | **`args`**: Points defining the angles and circle.                                                                                                                                                              | **`Circle`**: The resulting circle.                                                        | Complex geometric construction involving angles and a circle.           |
| **`sketch_eqdia_quadrangle`**    | Sketches a quadrangle with two equal diagonals.                                         | **`args`**: Points defining the base quadrangle.                                                                                                                                                                | **`tuple[Point, ...]`**: Points of the quadrangle.                                         | Randomized construction within constraints.                             |
| **`sketch_free`**                | Sketches a random free point.                                                           | **`args`**: Not used.                                                                                                                                                                                           | **`Point`**: A random point.                                                               | Generates a completely random point.                                    |
| **`sketch_isos`**                | Sketches an isosceles triangle.                                                         | **`args`**: Points defining the base triangle.                                                                                                                                                                  | **`tuple[Point, ...]`**: Points of the triangle.                                           | Randomized construction within constraints.                             |
| **`sketch_line`**                | Sketches a line based on two points.                                                    | **`args`**: Points defining the line.                                                                                                                                                                           | **`Line`**: The sketched line.                                                             | -                                                                       |
| **`sketch_cyclic`**              | Sketches a circle passing through three points.                                         | **`args`**: Points defining the circle.                                                                                                                                                                         | **`Circle`**: The cyclic circle.                                                           | -                                                                       |
| **`sketch_hline`**               | Sketches a half-line.                                                                   | **`args`**: Points defining the half-line.                                                                                                                                                                      | **`HalfLine`**: The sketched half-line.                                                    | -                                                                       |
| **`sketch_midp`**                | Sketches the midpoint between two points.                                               | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: The midpoint.                                                                 | -                                                                       |
| **`sketch_pentagon`**            | Sketches a pentagon.                                                                    | **`args`**: Points defining the pentagon's vertices.                                                                                                                                                            | **`tuple[Point, ...]`**: Points of the pentagon.                                           | Constructs a pentagon with random orientation and size.                 |
| **`sketch_pline`**               | Sketches a line parallel to a given line through a point.                               | **`args`**: Point **`a`** and line through points **`b`** and **`c`**.                                                                                                                                          | **`Line`**: The parallel line.                                                             | -                                                                       |
| **`sketch_pmirror`**             | Sketches the reflection of a point across another point.                                | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: Reflected point.                                                              | Reflects **`a`** across **`b`**.                                        |
| **`sketch_quadrangle`**          | Sketches a random quadrangle.                                                           | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the quadrangle.                                         | Creates a quadrangle with random orientation and size.                  |
| **`sketch_r_trapezoid`**         | Sketches a right-angled trapezoid.                                                      | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the trapezoid.                                          | Constructs a right-angled trapezoid with random orientation and size.   |
| **`sketch_r_triangle`**          | Sketches a right-angled triangle.                                                       | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Creates a right-angled triangle with random orientation and size.       |
| **`sketch_rectangle`**           | Sketches a rectangle.                                                                   | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the rectangle.                                          | Constructs a rectangle with random orientation and size.                |
| **`sketch_reflect`**             | Sketches the reflection of a point across a line.                                       | **`args`**: Point **`a`** and line through points **`b`** and **`c`**.                                                                                                                                          | **`Point`**: Reflected point.                                                              | Reflects **`a`** across the line through **`b`** and **`c`**.           |
| **`sketch_risos`**               | Sketches a right isosceles triangle.                                                    | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Constructs a right isosceles triangle with random orientation and size. |
| **`sketch_rotaten90`**           | Rotates a point 90 degrees counterclockwise around another point.                       | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: The rotated point.                                                            | Rotation is performed counterclockwise.                                 |
| **`sketch_rotatep90`**           | Rotates a point 90 degrees clockwise around another point.                              | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: The rotated point.                                                            | Rotation is performed clockwise.                                        |
| **`sketch_s_angle`**             | Sketches a line segment with a specified slope angle.                                   | **`args`**: Points **`a`**, **`b`**, and angle **`y`**.                                                                                                                                                         | **`HalfLine`**: The line segment.                                                          | **`y`** is the angle in degrees from **`a`** to **`b`**.                |
| **`sketch_segment`**             | Sketches a line segment between two random points.                                      | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, Point]`**: Endpoints of the segment.                                       | Generates a random line segment.                                        |
| **`sketch_shift`**               | Shifts a point by the vector defined by two other points.                               | **`args`**: Points **`a`**, **`b`**, and **`c`**.                                                                                                                                                               | **`Point`**: The shifted point.                                                            | Shifts **`c`** by the vector from **`a`** to **`b`**.                   |
| **`sketch_square`**              | Sketches a square.                                                                      | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`tuple[Point, Point]`**: Two opposite vertices of the square.                            | Constructs a square with one side defined by **`a`** and **`b`**.       |
| **`sketch_isquare`**             | Sketches an isosceles square.                                                           | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the square.                                             | Constructs an isosceles square with random orientation and size.        |
| **`sketch_tline`**               | Sketches a line perpendicular to a given line through a point.                          | **`args`**: Point **`a`** and line through points **`b`** and **`c`**.                                                                                                                                          | **`Line`**: The perpendicular line.                                                        | -                                                                       |
| **`sketch_trapezoid`**           | Sketches a trapezoid.                                                                   | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the trapezoid.                                          | Constructs a trapezoid with random orientation and size.                |
| **`sketch_triangle`**            | Sketches a triangle.                                                                    | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Creates a triangle with random orientation and size.                    |
| **`sketch_triangle12`**          | Sketches a triangle with side lengths in a 1:2 ratio.                                   | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Constructs a triangle with sides in a 1:2 ratio.                        |
| **`sketch_trisect`**             | Sketches two trisectors of an angle.                                                    | **`args`**: Points **`a`**, **`b`**, and **`c`**.                                                                                                                                                               | **`tuple[Point, Point]`**: Points defining the trisectors.                                 | Divides the angle at **`b`** into three equal parts.                    |
| **`sketch_trisegment`**          | Sketches two points dividing a segment into three equal parts.                          | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`tuple[Point, Point]`**: The two division points.                                        | Divides the segment into three equal parts.                             |
class InvalidLineIntersectError(Exception):
    """"""Exception raised for errors in the intersection of lines.""""""
    pass


class InvalidQuadSolveError(Exception):
    """"""Exception raised for errors in solving quadratic equations.""""""
    pass

ATOM = 1e-12
class Point:
    """"""
    Represents a point in 2D space with x and y coordinates.
    
    Methods are defined to allow for common geometric operations such as addition,
    subtraction, and comparison of points, as well as calculating distance, midpoint, etc.
    
    Attributes:
        x (float): The x-coordinate of the point.
        y (float): The y-coordinate of the point.

    Methods:
        __lt__: Check if this point is 'less than' another point based on their coordinates.
        __gt__: Check if this point is 'greater than' another point based on their coordinates.
        __add__: Add two points by adding their respective coordinates.
        __sub__: Subtract the coordinates of another point from this point.
        __mul__: Multiply the coordinates of this point by a scalar.
        __rmul__: Right multiplication of the point by a scalar. Enables scalar-point multiplication.
        __truediv__: Divide the coordinates of this point by a scalar.
        __floordiv__: Floor division of the point's coordinates by a scalar.
        __str__: String representation of the point in the format ""P(x,y)"".
        close: Check if this point is close to another point within a specified tolerance.
        distance: Calculate the distance from this point to another point, line, or circle.
        midpoint: Calculate the midpoint between this point and another point.
        distance2: Calculate the squared Euclidean distance from this point to another point.
        rotatea: Rotate this point around the origin by a given angle.
        rotate: Rotate this point around the origin using precomputed sine and cosine values.
        flip: Flip the point across the y-axis (mirror in the x-direction).
        perpendicular_line: Create a line perpendicular to a given line that passes through this point.
        foot: Find the foot of the perpendicular from this point to a line or circle.
        parallel_line: Create a line parallel to a given line that passes through this point.
        norm: Calculate the Euclidean norm (magnitude) of the point.
        cos: Calculate the cosine of the angle between this point and another point when both are treated as vectors from the origin.
        dot: Calculate the dot product of this point with another point.
        sign: Determine the sign of this point relative to a line.
        is_same: Check if this point is the same as another point, within a small tolerance.
    """"""

    def __init__(self, x, y):
        """"""
        Initialize a point with x and y coordinates.

        Args:
            x (float): The x-coordinate of the point.
            y (float): The y-coordinate of the point.
        """"""
        self.x = x
        self.y = y
    
    def __lt__(self, other: 'Point') -> bool:
        """"""
        Check if this point is 'less than' another point. 
        
        Comparison is first done on the x-coordinate
        Only if the x-coords are the same will the comparison continue to the y-coord

        Args:
            other (Point): The point to compare against.

        Returns:
            bool: True if this point is less than the other point, False otherwise.

        Example:
            >>> Point(1, 2) < Point(2, 1)
            True
        """"""
        return (self.x, self.y) < (other.x, other.y)
    
    
    def __gt__(self, other: 'Point') -> bool:
        """"""
        Check if this point is 'greater than' another point. 
        
        Comparison is first done on the x-coordinate, then the y-coordinate.
        Only if the x-coords are the same will the comparison continue to the y-coord

        Args:
            other (Point): The point to compare against.

        Returns:
            bool: True if this point is greater than the other point, False otherwise.

        Example:
            >>> Point(3, 4) > Point(2, 5)
            True
        """"""
        return (self.x, self.y) > (other.x, other.y)

    def __add__(self, p: Point) -> Point:
        """"""
        Add two points by adding their respective coordinates.

        Args:
            p (Point): Another point to add.

        Returns:
            Point: A new point resulting from the coordinate-wise addition.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(3, 4)
            >>> print(p1 + p2)
            P(4,6)
        """"""
        return Point(self.x + p.x, self.y + p.y)
    
    def __sub__(self, p: 'Point') -> 'Point':
        """"""
        Subtract the coordinates of another point from this point.

        Args:
            p (Point): The point to subtract.

        Returns:
            Point: A new point resulting from the coordinate-wise subtraction.

        Example:
            >>> p1 = Point(5, 4)
            >>> p2 = Point(2, 2)
            >>> print(p1 - p2)
            P(3,2)
        """"""
        return Point(self.x - p.x, self.y - p.y)
    
    def __mul__(self, f: float) -> 'Point':
        """"""
        Multiply the coordinates of this point by a scalar.

        Args:
            f (float): The scalar to multiply by.

        Returns:
            Point: A new point with coordinates scaled by the scalar.

        Example:
            >>> p = Point(1, 2)
            >>> print(p * 3)
            P(3,6)
        """"""
        return Point(self.x * f, self.y * f)
    
    def __rmul__(self, f: float) -> 'Point':
        """"""
        Right multiplication of the point by a scalar. Enables scalar-point multiplication.

        Args:
            f (float): The scalar to multiply by.

        Returns:
            Point: A new point with coordinates scaled by the scalar.

        Example:
            >>> p = Point(1, 2)
            >>> print(3 * p)
            P(3,6)
        """"""
        return self * f

    def __truediv__(self, f: float) -> 'Point':
        """"""
        Divide the coordinates of this point by a scalar.

        Args:
            f (float): The scalar to divide by.

        Returns:
            Point: A new point with coordinates divided by the scalar.

        Example:
            >>> p = Point(10, 20)
            >>> print(p / 2)
            P(5.0,10.0)
        """"""
        return Point(self.x / f, self.y / f)
    
    def __floordiv__(self, f: float) -> 'Point':
        """"""
        Floor division of the point's coordinates by a scalar.

        Args:
            f (float): The scalar to divide by.

        Returns:
            Point: A new point with coordinates floor-divided by the scalar.

        Example:
            >>> p = Point(10, 20)
            >>> print(p // 3)
            P(3,6)
        """"""
        div = self / f  # true division
        return Point(int(div.x), int(div.y))
    
    def __str__(self) -> str:
        """"""
        String representation of the point in the format ""P(x,y)"".

        Returns:
            str: The string representation.

        Example:
            >>> p = Point(1, 2)
            >>> str(p)
            'P(1,2)'
        """"""
        return 'P({},{})'.format(self.x, self.y)

    def close(self, point: 'Point', tol: float = ATOM) -> bool:
        """"""
        Check if this point is close to another point within a specified tolerance.

        Args:
            point (Point): The point to compare with.
            tol (float): The tolerance for comparison.

        Returns:
            bool: True if the points are within the specified tolerance, False otherwise.

        Example:
            >>> p1 = Point(1.0000001, 2.0000001)
            >>> p2 = Point(1, 2)
            >>> p1.close(p2)
            True
        """"""
        return abs(self.x - point.x) < tol and abs(self.y - point.y) < tol
    
    def midpoint(self, p: 'Point') -> 'Point':
        """"""
        Calculate the midpoint between this point and another point.

        Args:
            p (Point): The other point.

        Returns:
            Point: The midpoint between the two points.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(3, 4)
            >>> print(p1.midpoint(p2))
            P(2.0,3.0)
        """"""
        return Point(0.5 * (self.x + p.x), 0.5 * (self.y + p.y))
    
    def distance(self, p: Union[Point, Line, Circle]) -> float:
        """"""
        Calculate the Euclidean distance from this point to another geometric object
        (Point, Line, or Circle).

        The method dynamically adjusts its calculation based on the type of the argument:
        - If the argument is a Point, it calculates the direct Euclidean distance.
        - If the argument is a Line, it delegates to the Line's distance method to get
          the shortest distance from the point to the line.
        - If the argument is a Circle, it calculates the distance from the point to the
          Circle's center and adjusts it by the Circle's radius to give the shortest
          distance to the Circle.

        Args:
            p (Union[Point, Line, Circle]): The geometric object to measure distance to.

        Returns:
            float: The Euclidean distance to the object.

        Raises:
            TypeError: If 'p' is not a Point, Line, or Circle.

        Example:
            >>> point = Point(1, 1)
            >>> other_point = Point(4, 5)
            >>> line = Line(Point(0, 0), Point(1, 1))
            >>> circle = Circle(Point(5, 5), 2)
            >>> point.distance(other_point)  # Distance to another point
            5.0
            >>> point.distance(line)  # Perpendicular distance to a line
            0.0
            >>> point.distance(circle)  # Distance to a circle's boundary
            2.8284271247461903
        """"""
        if isinstance(p, Line):
            # Delegates the distance calculation to the Line's method.
            return p.distance(self)
        elif isinstance(p, Circle):
            # Computes the distance to the circle's center and adjusts by the radius.
            return abs(p.radius - self.distance(p.center))
        elif isinstance(p, Point):
            # Standard Euclidean distance formula.
            dx = self.x - p.x
            dy = self.y - p.y
            return np.sqrt(dx * dx + dy * dy)
        else:
            # Raises an error if 'p' is not a recognized geometric object.
            raise TypeError(f""Cannot compute distance to object of type {type(p)}"")

    def distance2(self, p: 'Point') -> float:
        """"""
        Calculate the squared Euclidean distance from this point to another point.
        This is more efficient than `distance` for comparison purposes as it avoids a square root calculation.

        Args:
            p (Point): The other point to measure distance to.

        Returns:
            float: The squared Euclidean distance to the other point.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(4, 6)
            >>> p1.distance2(p2)
            25.0
        """"""
        dx = self.x - p.x
        dy = self.y - p.y
        return dx * dx + dy * dy

    def rotatea(self, ang: float) -> 'Point':
        """"""
        Rotate this point around the origin (0, 0) by a given angle.

        Args:
            ang (float): The angle in radians to rotate.

        Returns:
            Point: A new point rotated around the origin.

        Example:
            >>> p = Point(1, 0)
            >>> print(p.rotatea(np.pi / 2))
            P(0.0,1.0)
        """"""
        sinb, cosb = np.sin(ang), np.cos(ang)
        return self.rotate(sinb, cosb)

    def rotate(self, sinb: float, cosb: float) -> 'Point':
        """"""
        Rotate this point around the origin using precomputed sine and cosine values.

        Args:
            sinb (float): The sine of the angle.
            cosb (float): The cosine of the angle.

        Returns:
            Point: A new point rotated around the origin.

        Example:
            >>> p = Point(1, 0)
            >>> sinb, cosb = np.sin(np.pi / 2), np.cos(np.pi / 2)
            >>> print(p.rotate(sinb, cosb))
            P(0.0,1.0)
        """"""
        x, y = self.x, self.y
        return Point(x * cosb - y * sinb, x * sinb + y * cosb)

    def flip(self) -> 'Point':
        """"""
        Flip the point across the y-axis (mirror in the x-direction).

        Returns:
            Point: A new point mirrored across the y-axis.

        Example:
            >>> p = Point(1, 2)
            >>> print(p.flip())
            P(-1,2)
        """"""
        return Point(-self.x, self.y)

    def perpendicular_line(self, line: 'Line') -> 'Line':
        """"""
        Create a line perpendicular to a given line that passes through this point.

        Args:
            line (Line): The line to which the new line will be perpendicular.

        Returns:
            Line: A new line perpendicular to the given line.

        Note:
            This relies on the `perpendicular_line` method of the `Line` class.
        """"""
        return line.perpendicular_line(self)

    def foot(self, line: Union['Line', 'Circle']) -> 'Point':
        """"""
        Find the foot of the perpendicular from this point to a line or circle.

        Args:
            line (Union[Line, Circle]): The line or circle to drop a perpendicular to.

        Returns:
            Point: The foot of the perpendicular.

        Raises:
            ValueError: If an unsupported type is passed.

        Example:
            >>> p = Point(3, 4)
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> print(p.foot(l))
            P(3.5,3.5)
        """"""
        if isinstance(line, Line):
            l = line.perpendicular_line(self)
            return line_line_intersection(l, line)
        elif isinstance(line, Circle):
            c, r = line.center, line.radius
            return c + (self - c) * r / self.distance(c)
        raise ValueError('Dropping foot to weird type {}'.format(type(line)))

    def parallel_line(self, line: 'Line') -> 'Line':
        """"""
        Create a line parallel to a given line that passes through this point.

        Args:
            line (Line): The line to which the new line will be parallel.

        Returns:
            Line: A new line parallel to the given line.

        Note:
            This relies on the `parallel_line` method of the `Line` class.
        """"""
        return line.parallel_line(self)

    def norm(self) -> float:
        """"""
        Calculate the Euclidean norm (magnitude) of the point.

        Returns:
            float: The Euclidean norm of the point.

        Example:
            >>> p = Point(3, 4)
            >>> p.norm()
            5.0
        """"""
        return np.sqrt(self.x ** 2 + self.y ** 2)

    def cos(self, other: 'Point') -> float:
        """"""
        Calculate the cosine of the angle between this point and another point when
        both are treated as vectors from the origin.

        Args:
            other (Point): The other point.

        Returns:
            float: The cosine of the angle between the two points.

        Example:
            >>> p1 = Point(1, 0)
            >>> p2 = Point(0, 1)
            >>> p1.cos(p2)
            0.0
        """"""
        return (self.x * other.x + self.y * other.y) / self.norm() / other.norm()

    def dot(self, other: 'Point') -> float:
        """"""
        Calculate the dot product of this point with another point.

        Args:
            other (Point): The other point.

        Returns:
            float: The dot product of the two points.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(3, 4)
            >>> p1.dot(p2)
            11
        """"""
        return self.x * other.x + self.y * other.y

    def sign(self, line: 'Line') -> int:
        """"""
        Determine the sign of this point relative to a line. Returns 1 if the point is
        on one side of the line, -1 if on the other side, and 0 if on the line.

        Args:
            line (Line): The line to compare against.

        Returns:
            int: The sign (-1, 0, 1) indicating the side of the line this point is on.

        Example:
            >>> p = Point(1, 2)
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p.sign(l)
            1
        """"""
        return line.sign(self)

    def is_same(self, other: 'Point') -> bool:
        """"""
        Check if this point is the same as another point, within a small tolerance.

        Args:
            other (Point): The other point to compare against.

        Returns:
            bool: True if the points are the same within a small tolerance, False otherwise.

        Example:
            >>> p1 = Point(1.0000001, 2.0000001)
            >>> p2 = Point(1, 2)
            >>> p1.is_same(p2)
            True
        """"""
        return self.distance(other) <= ATOM
class Line:
    """"""
    Represents a numerical line in 2D space, defined either by two points or by its
    coefficients in the standard line equation (ax + by + c = 0).

    Methods are defined to enable geometric operations like checking parallelism,
    perpendicularity, intersection, and calculating distance to points.

    Attributes:
        coefficients (tuple[float, float, float]): The coefficients a, b, c of the line equation.

    Methods:
        __init__: Initialize the line (self) object
        parallel_line: Create a line parallel to this line that passes through a given point.
        perpendicular_line: Create a line perpendicular to this line that passes through a given point.
        greater_than: Check if this line is 'greater than' another line based on the slope.
        __gt__: Overloads the '>' operator to compare two lines based on their slopes. (uses `greater_than`)
        __lt__: Overloads the '<' operator to compare two lines based on their slopes. (uses `greater_than`)
        intersect: Find the intersection points between this line and another line or a circle.
        distance: Calculate the shortest distance from a point to this line.
        __call__: Evaluate the line equation with a given point or x and y coordinates.
        is_parallel: Check if this line is parallel to another line.
        is_perp: Check if this line is perpendicular to another line.
        cross: Calculate the cross product of this line with another line.
        dot: Calculate the dot product of this line with another line.
        point_at: Get a point on this line closest to a given x or y coordinate.
        diff_side: Check if two points are on different sides of this line.
        same_side: Check if two points are on the same side of this line.
        sign: Determine the sign (positive, negative, or zero) of a point relative to this line.
        is_same: Checks whether the current line is the same as another line. 
        sample_within: This method samples a point within the boundary defined by a list of points. 
        same: Check if two lines are equivalent in the geometric sense, regardless of their coefficient representation.
        equal: Check if the slopes of two lines are equal, indicating they are parallel.
    """"""

    def __init__(self, p1: Point = None, p2: Point = None, coefficients: tuple[int, int, int] = None):
        """"""
        Initialize a Line object. 
        
        A line can be initialized with either two points (p1 and p2) 
            ... OR ...
        A line an be initialized directly with its coefficients (a, b, c) 
            - As in the equation ax + by + c = 0.

        Args:
            p1 (Point, optional): The first point through which the line passes.
            p2 (Point, optional): The second point through which the line passes.
            coefficients (tuple[int, int, int], optional): The coefficients of the line equation.

        Raises:
            ValueError: If insufficient data is provided to define a line.
        """"""
        if p1 is None and p2 is None and coefficients is None:
            raise ValueError(""Insufficient data to define a line."")

        # Calculate coefficients based on two points
        if coefficients is None:
            a = p1.y - p2.y
            b = p2.x - p1.x
            c = p1.x * p2.y - p2.x * p1.y
        else:
            a, b, c = coefficients

        # Normalize coefficients so that 'a' is non-negative (ensures standard form)
        if a < 0.0 or (a == 0.0 and b > 0.0):
            a, b, c = -a, -b, -c
        
        # Set the coefficients for the line equation that defines THIS line (self)
        self.coefficients = a, b, c

    def parallel_line(self, p: Point) -> 'Line':
        """"""
        Create a line parallel to this line that passes through a given point.

        Args:
            p (Point): The point through which the parallel line should pass.

        Returns:
            Line: A new line parallel to the original line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> parallel = l.parallel_line(Point(0, 1))
            >>> print(parallel.coefficients)
            (1, -1, 1)
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # The parallel line will have the same 'a' and 'b' coefficients
        return Line(coefficients=(a, b, -a * p.x - b * p.y))

    def perpendicular_line(self, p: Point) -> 'Line':
        """"""
        Create a line perpendicular to this line that passes through a given point.

        Args:
            p (Point): The point through which the perpendicular line should pass.

        Returns:
            Line: A new line perpendicular to the original line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> perp = l.perpendicular_line(Point(1, 0))
            >>> print(perp.coefficients)
            (1, 1, -1)
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # The perpendicular line will swap 'a' and 'b' and change one of their signs
        return Line(p, p + Point(a, b))

    def greater_than(self, other: 'Line') -> bool:
        """"""
        Check if this line is 'greater than' another line based on the slope.

        This is a utility method used for comparing lines. It compares the slopes of the lines.

        Args:
            other (Line): The line to compare against.

        Returns:
            bool: True if this line's slope is greater than the other line's slope, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 0), Point(1, 2))
            >>> l1.greater_than(l2)
            False
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # # Get the coefficients from the line equation that defines the OTHER line
        x, y, _ = other.coefficients
        
        # Compare the slopes
        return b * x > a * y

    def __gt__(self, other: 'Line') -> bool:
        """"""
        Overloads the '>' operator to compare two lines based on their slopes.

        Args:
            other (Line): The line to compare against.

        Returns:
            bool: True if this line is 'greater than' the other line, False otherwise.
        """"""
        return self.greater_than(other)

    def __lt__(self, other: 'Line') -> bool:
        """"""
        Overloads the '<' operator to compare two lines based on their slopes.

        Args:
            other (Line): The line to compare against.

        Returns:
            bool: True if this line is 'less than' the other line, False otherwise.
        """"""
        return other.greater_than(self)

    
    def intersect(self, obj: Union['Line', 'Circle']) -> tuple[Point, ...]:
        """"""
        Find the intersection points between this line and another line or a circle.

        Args:
            obj (Union[Line, Circle]): The line or circle to find intersections with.

        Returns:
            tuple[Point, ...]: A tuple of intersection points. Can be empty if no intersection.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 1), Point(1, 0))
            >>> intersections = l1.intersect(l2)
            >>> print(intersections[0])
            P(0.5,0.5)
        """"""
        
        # Determine the intersection points between this Line and another Line
        if isinstance(obj, Line):
            return line_line_intersection(self, obj)
        
        # Determine the intersection points between this Line and a Circle
        if isinstance(obj, Circle):
            return line_circle_intersection(self, obj)

    def distance(self, p: 'Point') -> float:
        """"""
        Calculate the shortest distance from a point to this line.

        Args:
            p (Point): The point from which to measure the distance.

        Returns:
            float: The shortest distance from the point to the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p = Point(1, 0)
            >>> l.distance(p)
            0.7071067811865476
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # 
        return abs(self(p.x, p.y)) / math.sqrt(a * a + b * b)

    def __call__(self, x: Union[Point, float], y: float = None) -> float:
        """"""
        Evaluate the line equation with a given point or x and y coordinates.
        
        The primary purpose of this method is to check where a point lies in relation to the line.
            - When the result of the line equation is zero, it indicates that the point lies exactly on the line.
            - A positive or negative result indicates that the point lies on one side or the other of the line.
        This method is versatile as it allows the line equation to be evaluated both for Point objects and for raw coordinate values.
        
        Args:
            x (Union[Point, float]): A Point object or the x-coordinate.
            y (float, optional): The y-coordinate. Not needed if 'x' is a Point.

        Returns:
            float: The result of the line equation ax + by + c.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> l(1, 1)  # Should be close to 0 as (1,1) is on the line
            0.0
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # Retrieve the actual x,y coordinates from the point if passed
        if isinstance(x, Point):
            return a * x.x + b * x.y + c
        
        # Otherwise we use the directly passed x,y coordinates
        return a * x + b * y + c

    
    def is_parallel(self, other: 'Line') -> bool:
        """"""
        Check if this line is parallel to another line.

        Parallel lines have the same slope, which translates to A1/B1 = A2/B2 in line coefficients. 
        This method compares the slopes for equality.

        Args:
            other (Line): The line to check parallelism with.

        Returns:
            bool: True if the lines are parallel, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 1), Point(2, 2))
            >>> l1.is_parallel(l2)
            True
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Check if the slopes are the same (within tolerance 1e-12)
        return abs(a * y - b * x) < ATOM

    def is_perp(self, other: 'Line') -> bool:
        """"""
        Check if this line is perpendicular to another line.

        Perpendicular lines have slopes that are negative reciprocals of each other,
        which translates to A1*A2 + B1*B2 = 0 in line coefficients.

        Args:
            other (Line): The line to check perpendicularity with.

        Returns:
            bool: True if the lines are perpendicular, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 0), Point(-1, 1))
            >>> l1.is_perp(l2)
            True
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Checking if slopes are negative reciprocals (within tolerance 1e-12)
        return abs(a * x + b * y) < ATOM  

    def cross(self, other: 'Line') -> float:
        """"""
        Calculate the cross product of this line with another line.

        The cross product, in this context, refers to the determinant of the matrix formed
        by the coefficients of the two lines. It's useful for understanding the relationship
        between the two lines (like finding area of parallelogram formed by them).

        Args:
            other (Line): The other line.

        Returns:
            float: The cross product of the two lines.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 1), Point(2, 2))
            >>> l1.cross(l2)
            0.0  # Zero indicates parallel lines
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Determinant of a 2x2 matrix formed by line coefficients
        return a * y - b * x  

    def dot(self, other: 'Line') -> float:
        """"""
        Calculate the dot product of this line with another line.

        The dot product here is a scalar value representing the sum of the products of
        their corresponding coefficients. It's useful in various geometric calculations.

        Args:
            other (Line): The other line.

        Returns:
            float: The dot product of the two lines.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 1), Point(2, 2))
            >>> l1.dot(l2)
            2.0
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Sum of the products of corresponding coefficients
        return a * x + b * y  

    def point_at(self, x: float = None, y: float = None) -> Optional[Point]:
        """"""
        Get a point on this line closest to a given x or y coordinate.

        If only x is given, finds the y on the line such that (x, y) is on the line.
        If only y is given, finds the x on the line such that (x, y) is on the line.
        If both are given, returns the point if it lies on the line, else None.

        Args:
            x (float, optional): The x-coordinate.
            y (float, optional): The y-coordinate.

        Returns:
            Optional[Point]: The point on the line closest to the given coordinates, or None.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> print(l.point_at(x=2))
            P(2,2)
            >>> print(l.point_at(y=2))
            P(2,2)
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # If only x is given, finds the y on the line such that (x, y) is on the line.
        if x is not None and y is None:
            # Find y for given x
            return Point(x, (-c - a * x) / b) if b != 0 else None
        
        # If only y is given, finds the x on the line such that (x, y) is on the line.
        elif x is None and y is not None:
            # Find x for given y
            return Point((-c - b * y) / a, y) if a != 0 else None
        
        # If both are given, returns the point if it lies on the line, else None.
        elif x is not None and y is not None:
            # Check if the point (x, y) is on the line
            return Point(x, y) if a * x + b * y + c == 0 else None
        
        # If neither are given we return None
        return None

    def diff_side(self, p1: Point, p2: Point) -> Optional[bool]:
        """"""
        Check if two points are on different sides of this line.

        Args:
            p1 (Point): The first point.
            p2 (Point): The second point.

        Returns:
            Optional[bool]: True if the points are on different sides
                            False if on the same side
                            None if either point lies on the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p1 = Point(1, 2)
            >>> p2 = Point(2, 1)
            >>> l.diff_side(p1, p2)
            True
        """"""
        # Evaluate the line equation for both points
        #   - Evaluates 'ax + by + c' (self.__call__) for point 'p1' and 'p2' respectively
        d1 = self(p1.x, p1.y)  
        d2 = self(p2.x, p2.y)

        # One of the points is on the line, so can't determine different sides
        if d1 == 0 or d2 == 0:
            return None  

        # If the signs of the evaluations are different, the points are on different sides
        return d1 * d2 < 0

    # Seems like this could be inverse of `diff_side`
    def same_side(self, p1: Point, p2: Point) -> Optional[bool]:
        """"""
        Check if two points are on the same side of this line.

        Args:
            p1 (Point): The first point.
            p2 (Point): The second point.

        Returns:
            Optional[bool]: True if the points are on the same side
                            False if on different sides
                            None if either point lies on the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p1 = Point(1, 1)
            >>> p2 = Point(2, 2)
            >>> l.same_side(p1, p2)
            True
        """"""
        # Evaluate the line equation for both points
        #   - Evaluates 'ax + by + c' (self.__call__) for point 'p1' and 'p2' respectively
        d1 = self(p1.x, p1.y)
        d2 = self(p2.x, p2.y)

        # One of the points is on the line, so can't determine same sides
        if d1 == 0 or d2 == 0:
            return None  

        # If the signs of the evaluations are the same, the points are on the same side
        return d1 * d2 > 0
    
    def sign(self, point: Point) -> int:
        """"""
        Determine the sign (positive, negative, or zero) of a point relative to this line.

        The sign indicates which side of the line the point lies on. 
        It's calculated by plugging the point's coordinates into the line's equation.

        Args:
            point (Point): The point to check.

        Returns:
            int: 1 if the point is on one side of the line, -1 if on the other side, 0 if on the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p = Point(1, 2)
            >>> l.sign(p)
            1  # Point is above the line
        """"""
        # Evaluate (self.__call__) the line equation (ax + by + c) for the respective point
        s = self(point.x, point.y)

        # Determine the sign based on the evaluation
        if s > 0:
            return 1  # Point is on one side of the line
        elif s < 0:
            return -1  # Point is on the other side of the line
        return 0  # Point is on the line

    def is_same(self, other: Line) -> bool:
        """"""
        Checks whether the current line is the same as another line. 
        
        This comparison is based on comparison of the coefficients of the two lines.
        This comparison measures EXACT EQUALITY (as opposed to `self.same`)

        Args:
            other (Line): The other line.

        Returns:
            bool: True if the lines evaluate to be the same within tolerance

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 0), Point(1, 1))
            >>> l1.is_same(other=l2)
            True
        """"""
        # Extract the coefficients of THIS line (a,b,c) and the OTHER line (x,y,z)
        a, b, c = self.coefficients
        x, y, z = other.coefficients

        # Check if the lines have the same slope and intercept (within tolerance of 1e-12)
        #   - 'abs(a * y - b * x)' checks if the slopes (b/a and y/x) are equal
        #   - 'abs(b * z - c * y)' checks if the intercepts (c/b and z/y) are the same
        return abs(a * y - b * x) <= ATOM and abs(b * z - c * y) <= ATOM

    def sample_within(self, points: list[Point], n: int = 5) -> list[Point]:
        """"""
        This method samples a point within the boundary defined by a list of points. 
        
        Sampling Procedure:
            - A circle is created with a radius equal to the maximum distance from the center to any of the boundary points. 
            - Then find points where the line intersects this circle
            - Then sample points along the line segment within the circle
            - Finally, choose the point farthest from the boundary points (best point).

        Args:
            points (List[Point]): The points that define the boundary of the circle
            n (int, optional): The number of points to randomly sample
            
        Returns:
            List: The sampled point that is the farthest from the boundary points (best point)
        """"""
        # Find the center of the given points
        center = sum(points, Point(0.0, 0.0)) * (1.0 / len(points))

        # Find the maximum distance from the center to any point to define a boundary
        radius = max([p.distance(center) for p in points])

        # Adjust the center to the nearest point on the line if it's outside the radius
        if close_enough(center.distance(self), radius):
            center = center.foot(self)

        # Find two points where the line intersects the circle around the center
        a, b = line_circle_intersection(self, Circle(center.foot(self), radius))

        # Initialize placeholder/values
        result = None
        best = -1.0
        
        # Randomly sample points on the line segment defined by the intersection points
        for _ in range(n):
            
            # Generate a random number between 0 and 1
            rand = unif(0.0, 1.0)  
            
            # Linear interpolation between points a and b
            x = a + (b - a) * rand  
            
            # Minimum distance to the boundary points
            mind = min([x.distance(p) for p in points])  
            
            # Update the best (farthest) point found
            if mind > best:
                best = mind    
                result = x  
        
        # Return the list containing the best point found
        return [result]  

    def same(self, other: Line) -> bool:
        """""" 
        Check if two lines are equivalent in the geometric sense, regardless of their coefficient representation.

        This method determines if two lines represent the same geometric line, even if their coefficients differ.
        It compares the proportional relationship of the coefficients of the two lines. For example, the lines
        y = x and 2y = 2x are different in representation but are geometrically the same line.

        Args:
            other (Line): The other line to compare with.

        Returns:
            bool: True if the lines are geometrically equivalent, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(coefficients=(2, -2, 0))
            >>> l1.same(l2)
            True
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, z = other.coefficients
    
        # Check for equivalence of lines
        #   - The first condition compares the proportional relationship of a and b to x and y
        #   - The second condition does a similar check for the offsets (c to y and z to y)
        # This allows for lines that are the same but represented with different coefficients
        return close_enough(a * y, b * x) and close_enough(b * z, c * y)

    def equal(self, other: Line) -> bool:
        """""" 
        Check if the slopes of two lines are equal, indicating they are parallel.

        This method compares the slopes of two lines to determine if they are parallel. It does not consider
        the intercepts, so parallel lines with different intercepts will still be considered 'equal' in terms of slope.

        Args:
            other (Line): The other line to compare with.

        Returns:
            bool: True if the slopes of the two lines are equal, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 0), Point(2, 1))
            >>> l1.equal(l2)
            True
        """"""        
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # The line 'b * x == a * y' may require a bit of explanation
        #   Slope Comparison: 
        #     - The comment # b/a == y/x --> b*x == a*y is explaining the logic behind the comparison. 
        #     - In the context of line equations:
        #       - The slope of a line given by ax + by + c = 0 is -a/b.
        #       - So, for two lines to be parallel, their slopes must be equal. 
        #       - This means -a/b for the first line should be equal to -x/y for the second line.
        #       - This is equivalent to saying b/a == y/x.
        #   Cross-Multiplying for Comparison: 
        #     - The expression b*x == a*y is a result of cross-multiplying b/a == y/x. 
        #     - This is done to avoid division (either b or y may be zero) and to simplify the comparison.
        #     - If b/a equals y/x, then b*x should equal a*y.
        return b * x == a * y

class HalfLine(Line):
    """"""
    Represents a numerical half-line or ray in 2D space.

    A HalfLine is a part of a line that starts at a point (the 'tail') and extends infinitely
    in one direction (towards the 'head').

    Inherits from Line class to utilize common line functionalities.

    Attributes:
        tail (Point): The starting point of the half-line.
        head (Point): A point that the half-line passes through, determining its direction.
        line (Line): The underlying Line object that represents the full line.

    Methods:
        __init__: Initialize the HalfLine object with a tail and head.
        intersect: Find the intersection point of the HalfLine with another geometric object.
        sample_within: Samples a point within a boundary defined by a list of points.
    """"""

    def __init__(self, tail: Point, head: Point):
        """"""
        Initialize a HalfLine object with a tail and head point.

        The tail is the starting point of the half-line, and the head is another point
        which the half-line passes through, defining its direction.

        Args:
            tail (Point): The starting point of the half-line.
            head (Point): A point through which the half-line passes.

        Example Usage:
            >>> tail = Point(0, 0)
            >>> head = Point(1, 1)
            >>> half_line = HalfLine(tail, head)
        """"""
        # Initialize the underlying Line object from the tail to the head
        self.line = Line(tail, head)

        # Store the coefficients of the underlying Line
        self.coefficients = self.line.coefficients

        # Store the tail and head points
        self.tail = tail
        self.head = head

    def intersect(self, obj: Union[Line, HalfLine, Circle, HoleCircle]) -> Point:
        """"""
        Find the intersection point of the HalfLine with another geometric object.

        This method extends the intersection functionality to consider the nature of a half-line,
        which extends infinitely from the tail through the head.

        Args:
            obj (Union[Line, HalfLine, Circle, HoleCircle]): The geometric object to find
            intersections with. It can be a Line, HalfLine, Circle, or HoleCircle.

        Returns:
            Point: The intersection point if one exists.

        Raises:
            InvalidLineIntersectError: If the intersection cannot be determined or does not exist.

        Example Usage:
            >>> line = Line(Point(0, 0), Point(1, 1))
            >>> half_line = HalfLine(Point(0, 0), Point(1, 1))
            >>> intersection = half_line.intersect(line)
            >>> print(intersection)
            P(0,0)
        """"""
        
        # Handling intersection with a Line or HalfLine
        if isinstance(obj, (HalfLine, Line)):
            return line_line_intersection(self.line, obj)

        # Create a list of exclusions (for intersection calculation) 
        #   - We initialize it with the 'tail' point
        exclude = [self.tail]

        # Special handling for HoleCircle, which has a 'hole' that should not be considered for intersection
        if isinstance(obj, HoleCircle):
            exclude += [obj.hole]

        # Find potential intersection points with a Circle or HoleCircle
        a, b = line_circle_intersection(self.line, obj)

        # Exclude intersection points that are close to the exclusion points
        if any([a.close(x) for x in exclude]):
            return b
        if any([b.close(x) for x in exclude]):
            return a

        # Determine which of the potential intersection points lies on the HalfLine
        v = self.head - self.tail  # Vector along the half-line
        va = a - self.tail  # Vector from the tail to point a
        vb = b - self.tail  # Vector from the tail to point b

        # Check if either of the intersection points extends in the same direction as the half-line
        if v.dot(va) > 0:
            return a
        if v.dot(vb) > 0:
            return b

        # If neither intersection point is valid, raise an error
        raise InvalidLineIntersectError()

    def sample_within(self, points: list[Point], n: int = 5) -> list[Point]:
        """"""
        Samples a point within a boundary defined by a list of points.

        This method finds a point on the HalfLine that is maximally distant from the boundary
        points, within a certain radius. It is useful for applications like diagram generation or
        optimization within a bounded area.

        Args:
            points (list[Point]): The points that define the boundary of the area.
            n (int, optional): The number of points to randomly sample.

        Returns:
            list[Point]: A list containing the best sampled point.

        Example:
            >>> boundary_points = [Point(0, 0), Point(1, 1), Point(0, 1)]
            >>> half_line = HalfLine(Point(0, 0), Point(1, 1))
            >>> best_point = half_line.sample_within(boundary_points)
            >>> print(best_point)
            [P(0.5,0.5)]
        """"""
        # Calculate the center of the given boundary points
        center = sum(points, Point(0.0, 0.0)) * (1.0 / len(points))

        # Find the radius as the maximum distance from the center to any of the boundary points
        radius = max([p.distance(center) for p in points])

        # Adjust the center to the nearest point on the half-line if it's outside the radius
        if close_enough(center.distance(self.line), radius):
            center = center.foot(self)
        
        # Find intersection points of the HalfLine with a circle defined by the center and radius
        a, b = line_circle_intersection(self, Circle(center.foot(self), radius))

        # Decide which of the intersection points to use based on the direction of the half-line
        if (a - self.tail).dot(self.head - self.tail) > 0:
            a, b = self.tail, a
        else:
            a, b = self.tail, b

        # Initialize variables to store the best point and its score
        result = None
        best = -1.0

        # Randomly sample points on the segment of the half-line inside the circle
        for _ in range(n):
            x = a + (b - a) * unif(0.0, 1.0)  # Random point between a and b
            mind = min([x.distance(p) for p in points])  # Minimum distance to the boundary points
            
            # Update the best point if a better one is found
            if mind > best:
                best = mind
                result = x

        # Return the list containing the best point found
        return [result]

class Circle:
    """"""
    Represents a circle in 2D space.

    A circle can be defined by providing a center point and a radius, or by three points
    on its circumference (from which the center and radius are calculated).

    Attributes:
        center (Point): The center point of the circle.
        radius (float): The radius of the circle.
        a, b (float): The x and y coordinates of the center, respectively.
        r2 (float): The square of the radius of the circle.

    Methods:
        __init__: Initialize the circle object.
        intersect: Find the intersection points with another geometric object.
        sample_within: Sample a random point within a defined boundary.

    Raises:
        ValueError: If insufficient data is provided to define a circle.
    """"""

    def __init__(
            self,
            center: Optional[Point] = None,
            radius: Optional[float] = None,
            p1: Optional[Point] = None,
            p2: Optional[Point] = None,
            p3: Optional[Point] = None,
    ):
        """"""
        Initialize a Circle object. The circle can be defined either by a center and radius, 
        or by three points on its circumference.

        Args:
            center (Point, optional): The center of the circle.
            radius (float, optional): The radius of the circle.
            p1, p2, p3 (Point, optional): Three points on the circumference of the circle.

        Raises:
            ValueError: If insufficient data is provided to define a circle.
        """"""

        # If the center is not provided, calculate it using three points on the circle.
        if not center:
            # Ensure all three points are provided to calculate the center.
            if not (p1 and p2 and p3):
                self.center = self.radius = self.r2 = None
                return  # Could raise ValueError('Circle without center need p1 p2 p3')
            
            # Calculate the perpendicular bisectors of lines between the points.
            l12 = _perpendicular_bisector(p1, p2)
            l23 = _perpendicular_bisector(p2, p3)

            # Find the intersection of these bisectors to determine the center.
            center = line_line_intersection(l12, l23)

        # Set the center of the circle.
        self.center = center
        
        # Extract x and y coordinates of the center.
        self.a, self.b = center.x, center.y  

        # If the radius is not provided, calculate it using one of the points.
        if not radius:
            # Ensure at least one point is provided if radius is not given.
            if not (p1 or p2 or p3):
                raise ValueError('Circle needs radius or p1 or p2 or p3')

            # Choose any one of the provided points to calculate the radius.
            p = p1 or p2 or p3

            # Calculate the squared radius based on the distance from the center to the point.
            self.r2 = (self.a - p.x) ** 2 + (self.b - p.y) ** 2
            
            # Calculate the radius.
            self.radius = math.sqrt(self.r2)  
        else:
            # If the radius is provided, set it directly.
            self.radius = radius
            
            # Calculate the squared radius.
            self.r2 = radius * radius  

    def intersect(self, obj: Union[Line, Circle]) -> tuple[Point, ...]:
        """"""
        Find the intersection points between the circle and another geometric object (line or circle).

        Args:
            obj (Union[Line, Circle]): The geometric object to intersect with.

        Returns:
            tuple[Point, ...]: A tuple of Points where the objects intersect. Can be empty if no intersection.
        """"""
        # Delegate the intersection calculation based on the type of 'obj'.
        if isinstance(obj, Line):
            return obj.intersect(self)
        if isinstance(obj, Circle):
            return circle_circle_intersection(self, obj)

    def sample_within(self, points: list[Point], n: int = 5) -> list[Point]:
        """"""
        Sample a point within the boundary defined by a list of points.

        This method randomly samples points on the circle's circumference and selects
        the one farthest from the boundary points.

        Args:
            points (list[Point]): The points defining the boundary.
            n (int, optional): The number of points to sample. Default is 5.

        Returns:
            list[Point]: A list containing the best sampled point.

        Example:
            >>> circle = Circle(center=Point(0, 0), radius=1)
            >>> boundary_points = [Point(1, 1), Point(-1, -1), Point(1, -1)]
            >>> best_point = circle.sample_within(boundary_points)
            >>> print(best_point)
            [Point(0.707, 0.707)]
        """"""
        
        # Initialize
        result = None
        best = -1.0
        
        # Iterate up to n random sampled points to find the 'best' point
        for _ in range(n):
            # Randomly generate an angle to find a point on the circle's circumference.
            ang = unif(0.0, 2.0) * np.pi
            x = self.center + Point(np.cos(ang), np.sin(ang)) * self.radius

            # Find the minimum distance of this point from the boundary points.
            mind = min([x.distance(p) for p in points])

            # Update the best point if this one is farther from the boundary.
            if mind > best:
                best = mind
                result = x

        # Return the best point found.
        return [result]


class HoleCircle(Circle):
    """"""Numerical circle with a missing point.""""""
    
    def __init__(self, center: Point, radius: float, hole: Point):
        """"""
        Initializes a HoleCircle object.

        This constructor creates a HoleCircle, which is essentially a Circle with an additional
        attribute 'hole' representing a point that is conceptually not part of the circle.

        Args:
            center (Point): The center point of the circle.
            radius (float): The radius of the circle.
            hole (Point): The point on the circle that is considered as the hole.

        Example Usage:
            >>> center_point = Point(0, 0)
            >>> hole_point = Point(1, 0)
            >>> hole_circle = HoleCircle(center=center_point, radius=1, hole=hole_point)
        """"""
        super().__init__(center, radius)  # Initialize the base Circle class
        self.hole = hole  # Define the hole point

    def intersect(self, obj: Union[Line, HalfLine, Circle, HoleCircle]) -> Point:
        """"""
        Find the intersection point between the HoleCircle and another geometric object.

        This method overrides the 'intersect' method in the Circle class to account for the 'hole' point.
        When calculating intersections, if one of the intersection points coincides with the 'hole', 
        that point is disregarded, and the other point is returned.

        Args:
            obj (Union[Line, HalfLine, Circle, HoleCircle]): The geometric object to intersect with.

        Returns:
            Point: The intersection point, excluding the hole if it coincides with one of the intersection points.

        Example:
            >>> line = Line(Point(0, 5), Point(5, 5))
            >>> hole_circle = HoleCircle(Point(0, 0), 5, Point(5, 0))
            >>> intersect_point = hole_circle.intersect(line)
            >>> print(intersect_point)
            Point(0, 5)
        """"""
        if isinstance(obj, Line):
            # Calculate intersections with a line.
            a, b = line_circle_intersection(obj, self)
            
            # If one of the points is the 'hole', return the other.
            if a.close(self.hole):
                return b
            return a
        
        # Delegate to HalfLine's intersect method.
        if isinstance(obj, HalfLine):
            return obj.intersect(self)
        
        # Delegate to Circle's intersect method.
        if isinstance(obj, Circle):
            # Calculate intersections with another circle.
            a, b = circle_circle_intersection(obj, self)
            # If one of the points is the 'hole', return the other.
            if a.close(self.hole):
                return b
            return a
        
        # Delegate to HoleCircle's intersect method.
        if isinstance(obj, HoleCircle):
            # Calculate intersections with another HoleCircle.
            a, b = circle_circle_intersection(obj, self)
            # Check if either of the intersection points is the 'hole' in either circle.
            if a.close(self.hole) or a.close(obj.hole):
                return b
            return a
def _perpendicular_bisector(p1: Point, p2: Point) -> Line:
    midpoint = (p1 + p2) * 0.5
    return Line(midpoint, midpoint + Point(p2.y - p1.y, p1.x - p2.x))


def same_sign(
        a: Point, b: Point, c: Point, d: Point, e: Point, f: Point
) -> bool:
    a, b, c, d, e, f = map(lambda p: p.sym, [a, b, c, d, e, f])
    ab, cb = a - b, c - b
    de, fe = d - e, f - e
    return (ab.x * cb.y - ab.y * cb.x) * (de.x * fe.y - de.y * fe.x) > 0


def solve_quad(a: float, b: float, c: float) -> tuple[float, float]:
    """"""Solve a x^2 + bx + c = 0.""""""
    a = 2 * a
    d = b * b - 2 * a * c
    if d < 0:
        return None  # the caller should expect this result.

    y = math.sqrt(d)
    return (-b - y) / a, (-b + y) / a


def circle_circle_intersection(c1: Circle, c2: Circle) -> tuple[Point, Point]:
    """"""Returns a pair of Points as intersections of c1 and c2.""""""
    # circle 1: (x0, y0), radius r0
    # circle 2: (x1, y1), radius r1
    x0, y0, r0 = c1.a, c1.b, c1.radius
    x1, y1, r1 = c2.a, c2.b, c2.radius

    d = math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2)
    if d == 0:
        raise InvalidQuadSolveError()

    a = (r0 ** 2 - r1 ** 2 + d ** 2) / (2 * d)
    h = r0 ** 2 - a ** 2
    if h < 0:
        raise InvalidQuadSolveError()
    h = np.sqrt(h)
    x2 = x0 + a * (x1 - x0) / d
    y2 = y0 + a * (y1 - y0) / d
    x3 = x2 + h * (y1 - y0) / d
    y3 = y2 - h * (x1 - x0) / d
    x4 = x2 - h * (y1 - y0) / d
    y4 = y2 + h * (x1 - x0) / d

    return Point(x3, y3), Point(x4, y4)


def line_circle_intersection(line: Line, circle: Circle) -> tuple[Point, Point]:
    """"""Returns a pair of points as intersections of line and circle.""""""
    a, b, c = line.coefficients
    r = float(circle.radius)
    center = circle.center
    p, q = center.x, center.y

    if b == 0:
        x = -c / a
        x_p = x - p
        x_p2 = x_p * x_p
        y = solve_quad(1, -2 * q, q * q + x_p2 - r * r)
        if y is None:
            raise InvalidQuadSolveError()
        y1, y2 = y
        return (Point(x, y1), Point(x, y2))

    if a == 0:
        y = -c / b
        y_q = y - q
        y_q2 = y_q * y_q
        x = solve_quad(1, -2 * p, p * p + y_q2 - r * r)
        if x is None:
            raise InvalidQuadSolveError()
        x1, x2 = x
        return (Point(x1, y), Point(x2, y))

    c_ap = c + a * p
    a2 = a * a
    y = solve_quad(
        a2 + b * b, 2 * (b * c_ap - a2 * q), c_ap * c_ap + a2 * (q * q - r * r)
    )
    if y is None:
        raise InvalidQuadSolveError()
    y1, y2 = y

    return Point(-(b * y1 + c) / a, y1), Point(-(b * y2 + c) / a, y2)


def _check_between(a: Point, b: Point, c: Point) -> bool:
    """"""Whether a is between b & c.""""""
    return (a - b).dot(c - b) > 0 and (a - c).dot(b - c) > 0


def circle_segment_intersect(
        circle: Circle, p1: Point, p2: Point
) -> list[Point]:
    l = Line(p1, p2)
    px, py = line_circle_intersection(l, circle)

    result = []
    if _check_between(px, p1, p2):
        result.append(px)
    if _check_between(py, p1, p2):
        result.append(py)
    return result


def line_segment_intersection(l: Line, A: Point, B: Point) -> Point:  # pylint: disable=invalid-name
    a, b, c = l.coefficients
    x1, y1, x2, y2 = A.x, A.y, B.x, B.y
    dx, dy = x2 - x1, y2 - y1
    alpha = (-c - a * x1 - b * y1) / (a * dx + b * dy)
    return Point(x1 + alpha * dx, y1 + alpha * dy)


def line_line_intersection(l1: Line, l2: Line) -> Point:
    a1, b1, c1 = l1.coefficients
    a2, b2, c2 = l2.coefficients
    # a1x + b1y + c1 = 0
    # a2x + b2y + c2 = 0
    d = a1 * b2 - a2 * b1
    if d == 0:
        raise InvalidLineIntersectError
    return Point((c2 * b1 - c1 * b2) / d, (c1 * a2 - c2 * a1) / d)


def check_too_close(
        newpoints: list[Point], points: list[Point], tol: int = 0.1
) -> bool:
    if not points:
        return False
    avg = sum(points, Point(0.0, 0.0)) * 1.0 / len(points)
    mindist = min([p.distance(avg) for p in points])
    for p0 in newpoints:
        for p1 in points:
            if p0.distance(p1) < tol * mindist:
                return True
    return False


def check_too_far(
        newpoints: list[Point], points: list[Point], tol: int = 4
) -> bool:
    if len(points) < 2:
        return False
    avg = sum(points, Point(0.0, 0.0)) * 1.0 / len(points)
    maxdist = max([p.distance(avg) for p in points])
    for p in newpoints:
        if p.distance(avg) > maxdist * tol:
            return True
    return False


def check_aconst(args: list[Point]) -> bool:
    a, b, c, d, num, den = args
    d = d + a - c
    ang = ang_between(a, b, d)
    if ang < 0:
        ang += np.pi
    return close_enough(ang, num * np.pi / den)


def check(name: str, args: list[Union[gm.Point, Point]]) -> bool:
    """"""Numerical check.""""""
    if name == 'eqangle6':
        name = 'eqangle'
    elif name == 'eqratio6':
        name = 'eqratio'
    elif name in ['simtri2', 'simtri*']:
        name = 'simtri'
    elif name in ['contri2', 'contri*']:
        name = 'contri'
    elif name == 'para':
        name = 'para_or_coll'
    elif name == 'on_line':
        name = 'coll'
    elif name in ['rcompute', 'acompute']:
        return True
    elif name in ['fixl', 'fixc', 'fixb', 'fixt', 'fixp']:
        return True

    fn_name = 'check_' + name
    if fn_name not in globals():
        return None

    fun = globals()['check_' + name]
    args = [p.num if isinstance(p, gm.Point) else p for p in args]
    return fun(args)


def check_circle(points: list[Point]) -> bool:
    if len(points) != 4:
        return False
    o, a, b, c = points
    oa, ob, oc = o.distance(a), o.distance(b), o.distance(c)
    return close_enough(oa, ob) and close_enough(ob, oc)


def check_coll(points: list[Point]) -> bool:
    a, b = points[:2]
    l = Line(a, b)
    for p in points[2:]:
        if abs(l(p.x, p.y)) > ATOM:
            return False
    return True


def check_ncoll(points: list[Point]) -> bool:
    return not check_coll(points)


def check_sameside(points: list[Point]) -> bool:
    b, a, c, y, x, z = points
    # whether b is to the same side of a & c as y is to x & z
    ba = b - a
    bc = b - c
    yx = y - x
    yz = y - z
    return ba.dot(bc) * yx.dot(yz) > 0


def check_para_or_coll(points: list[Point]) -> bool:
    return check_para(points) or check_coll(points)


def check_para(points: list[Point]) -> bool:
    a, b, c, d = points
    ab = Line(a, b)
    cd = Line(c, d)
    if ab.same(cd):
        return False
    return ab.is_parallel(cd)


def check_perp(points: list[Point]) -> bool:
    a, b, c, d = points
    ab = Line(a, b)
    cd = Line(c, d)
    return ab.is_perp(cd)


def check_cyclic(points: list[Point]) -> bool:
    points = list(set(points))
    (a, b, c), *ps = points
    circle = Circle(p1=a, p2=b, p3=c)
    for d in ps:
        if not close_enough(d.distance(circle.center), circle.radius):
            return False
    return True


def bring_together(
        a: Point, b: Point, c: Point, d: Point
) -> tuple[Point, Point, Point, Point]:
    ab = Line(a, b)
    cd = Line(c, d)
    x = line_line_intersection(ab, cd)
    unit = Circle(center=x, radius=1.0)
    y, _ = line_circle_intersection(ab, unit)
    z, _ = line_circle_intersection(cd, unit)
    return x, y, x, z


def same_clock(
        a: Point, b: Point, c: Point, d: Point, e: Point, f: Point
) -> bool:
    ba = b - a
    cb = c - b
    ed = e - d
    fe = f - e
    return (ba.x * cb.y - ba.y * cb.x) * (ed.x * fe.y - ed.y * fe.x) > 0


def check_const_angle(points: list[Point]) -> bool:
    """"""Check if the angle is equal to the given constant.""""""
    a, b, c, d, m, n = points
    a, b, c, d = bring_together(a, b, c, d)
    ba = b - a
    dc = d - c

    a3 = np.arctan2(ba.y, ba.x)
    a4 = np.arctan2(dc.y, dc.x)
    y = a3 - a4

    return close_enough(m / n % 1, y / np.pi % 1)


def check_eqangle(points: list[Point]) -> bool:
    """"""Check if 8 points make 2 equal angles.""""""
    a, b, c, d, e, f, g, h = points

    ab = Line(a, b)
    cd = Line(c, d)
    ef = Line(e, f)
    gh = Line(g, h)

    if ab.is_parallel(cd):
        return ef.is_parallel(gh)
    if ef.is_parallel(gh):
        return ab.is_parallel(cd)

    a, b, c, d = bring_together(a, b, c, d)
    e, f, g, h = bring_together(e, f, g, h)

    ba = b - a
    dc = d - c
    fe = f - e
    hg = h - g

    sameclock = (ba.x * dc.y - ba.y * dc.x) * (fe.x * hg.y - fe.y * hg.x) > 0
    if not sameclock:
        ba = ba * -1.0

    a1 = np.arctan2(fe.y, fe.x)
    a2 = np.arctan2(hg.y, hg.x)
    x = a1 - a2

    a3 = np.arctan2(ba.y, ba.x)
    a4 = np.arctan2(dc.y, dc.x)
    y = a3 - a4

    xy = (x - y) % (2 * np.pi)
    return close_enough(xy, 0, tol=1e-11) or close_enough(
        xy, 2 * np.pi, tol=1e-11
    )


def check_eqratio(points: list[Point]) -> bool:
    a, b, c, d, e, f, g, h = points
    ab = a.distance(b)
    cd = c.distance(d)
    ef = e.distance(f)
    gh = g.distance(h)
    return close_enough(ab * gh, cd * ef)


def check_cong(points: list[Point]) -> bool:
    a, b, c, d = points
    return close_enough(a.distance(b), c.distance(d))


def check_midp(points: list[Point]) -> bool:
    a, b, c = points
    return check_coll(points) and close_enough(a.distance(b), a.distance(c))


def check_simtri(points: list[Point]) -> bool:
    """"""Check if 6 points make a pair of similar triangles.""""""
    a, b, c, x, y, z = points
    ab = a.distance(b)
    bc = b.distance(c)
    ca = c.distance(a)
    xy = x.distance(y)
    yz = y.distance(z)
    zx = z.distance(x)
    tol = 1e-9
    return close_enough(ab * yz, bc * xy, tol) and close_enough(
        bc * zx, ca * yz, tol
    )


def check_contri(points: list[Point]) -> bool:
    a, b, c, x, y, z = points
    ab = a.distance(b)
    bc = b.distance(c)
    ca = c.distance(a)
    xy = x.distance(y)
    yz = y.distance(z)
    zx = z.distance(x)
    tol = 1e-9
    return (
            close_enough(ab, xy, tol)
            and close_enough(bc, yz, tol)
            and close_enough(ca, zx, tol)
    )


def check_ratio(points: list[Point]) -> bool:
    a, b, c, d, m, n = points
    ab = a.distance(b)
    cd = c.distance(d)
    return close_enough(ab * n, cd * m)


def draw_angle(
        ax: matplotlib.axes.Axes,
        head: Point,
        p1: Point,
        p2: Point,
        color: Any = 'red',
        alpha: float = 0.5,
        frac: float = 1.0,
) -> None:
    """"""Draw an angle on plt ax.""""""
    d1 = p1 - head
    d2 = p2 - head

    a1 = np.arctan2(float(d1.y), float(d1.x))
    a2 = np.arctan2(float(d2.y), float(d2.x))
    a1, a2 = a1 * 180 / np.pi, a2 * 180 / np.pi
    a1, a2 = a1 % 360, a2 % 360

    if a1 > a2:
        a1, a2 = a2, a1

    if a2 - a1 > 180:
        a1, a2 = a2, a1

    b1, b2 = a1, a2
    if b1 > b2:
        b2 += 360
    d = b2 - b1
    # if d >= 90:
    #   return

    scale = min(2.0, 90 / d)
    scale = max(scale, 0.4)
    fov = matplotlib.patches.Wedge(
        (float(head.x), float(head.y)),
        unif(0.075, 0.125) * scale * frac,
        a1,
        a2,
        color=color,
        alpha=alpha,
    )
    ax.add_artist(fov)


def naming_position(
        ax: matplotlib.axes.Axes, p: Point, lines: list[Line], circles: list[Circle]
) -> tuple[float, float]:
    """"""Figure out a good naming position on the drawing.""""""
    _ = ax
    r = 0.08
    c = Circle(center=p, radius=r)
    avoid = []
    for p1, p2 in lines:
        try:
            avoid.extend(circle_segment_intersect(c, p1, p2))
        except InvalidQuadSolveError:
            continue
    for x in circles:
        try:
            avoid.extend(circle_circle_intersection(c, x))
        except InvalidQuadSolveError:
            continue

    if not avoid:
        return [p.x + 0.01, p.y + 0.01]

    angs = sorted([ang_of(p, a) for a in avoid])
    angs += [angs[0] + 2 * np.pi]
    angs = [(angs[i + 1] - a, a) for i, a in enumerate(angs[:-1])]

    d, a = max(angs)
    ang = a + d / 2

    name_pos = p + Point(np.cos(ang), np.sin(ang)) * r

    x, y = (name_pos.x - r / 1.5, name_pos.y - r / 1.5)
    return x, y


def draw_point(
        ax: matplotlib.axes.Axes,
        p: Point,
        name: str,
        lines: list[Line],
        circles: list[Circle],
        color: Any = 'white',
        size: float = 15,
) -> None:
    """"""draw a point.""""""
    ax.scatter(p.x, p.y, color=color, s=size)

    if color == 'white':
        color = 'lightgreen'
    else:
        color = 'grey'

    name = name.upper()
    if len(name) > 1:
        name = name[0] + '_' + name[1:]

    ax.annotate(
        name, naming_position(ax, p, lines, circles), color=color, fontsize=15
    )


def _draw_line(
        ax: matplotlib.axes.Axes,
        p1: Point,
        p2: Point,
        color: Any = 'white',
        lw: float = 1.2,
        alpha: float = 0.8,
) -> None:
    """"""Draw a line in matplotlib.""""""
    ls = '-'
    if color == '--':
        color = 'black'
        ls = '--'

    lx, ly = (p1.x, p2.x), (p1.y, p2.y)
    ax.plot(lx, ly, color=color, lw=lw, alpha=alpha, ls=ls)


def draw_line(
        ax: matplotlib.axes.Axes, line: Line, color: Any = 'white'
) -> tuple[Point, Point]:
    """"""Draw a line.""""""
    points = line.neighbors(gm.Point)
    if len(points) <= 1:
        return

    points = [p.num for p in points]
    p1, p2 = points[:2]

    pmin, pmax = (p1, 0.0), (p2, (p2 - p1).dot(p2 - p1))

    for p in points[2:]:
        v = (p - p1).dot(p2 - p1)
        if v < pmin[1]:
            pmin = p, v
        if v > pmax[1]:
            pmax = p, v

    p1, p2 = pmin[0], pmax[0]
    _draw_line(ax, p1, p2, color=color)
    return p1, p2


def _draw_circle(
        ax: matplotlib.axes.Axes, c: Circle, color: Any = 'cyan', lw: float = 1.2
) -> None:
    ls = '-'
    if color == '--':
        color = 'black'
        ls = '--'

    ax.add_patch(
        plt.Circle(
            (c.center.x, c.center.y),
            c.radius,
            color=color,
            alpha=0.8,
            fill=False,
            lw=lw,
            ls=ls,
        )
    )


def draw_circle(
        ax: matplotlib.axes.Axes, circle: Circle, color: Any = 'cyan'
) -> Circle:
    """"""Draw a circle.""""""
    if circle.num is not None:
        circle = circle.num
    else:
        points = circle.neighbors(gm.Point)
        if len(points) <= 2:
            return
        points = [p.num for p in points]
        p1, p2, p3 = points[:3]
        circle = Circle(p1=p1, p2=p2, p3=p3)

    _draw_circle(ax, circle, color)
    return circle


def mark_segment(
        ax: matplotlib.axes.Axes, p1: Point, p2: Point, color: Any, alpha: float
) -> None:
    _ = alpha
    x, y = (p1.x + p2.x) / 2, (p1.y + p2.y) / 2
    ax.scatter(x, y, color=color, alpha=1.0, marker='o', s=50)


def highlight_angle(
        ax: matplotlib.axes.Axes,
        a: Point,
        b: Point,
        c: Point,
        d: Point,
        color: Any,
        alpha: float,
) -> None:
    """"""Highlight an angle between ab and cd with (color, alpha).""""""
    try:
        a, b, c, d = bring_together(a, b, c, d)
    except:  # pylint: disable=bare-except
        return
    draw_angle(ax, a, b, d, color=color, alpha=alpha, frac=1.0)


def highlight(
        ax: matplotlib.axes.Axes,
        name: str,
        args: list[gm.Point],
        lcolor: Any,
        color1: Any,
        color2: Any,
) -> None:
    """"""Draw highlights.""""""
    args = list(map(lambda x: x.num if isinstance(x, gm.Point) else x, args))

    if name == 'cyclic':
        a, b, c, d = args
        _draw_circle(ax, Circle(p1=a, p2=b, p3=c), color=color1, lw=2.0)
    if name == 'coll':
        a, b, c = args
        a, b = max(a, b, c), min(a, b, c)
        _draw_line(ax, a, b, color=color1, lw=2.0)
    if name == 'para':
        a, b, c, d = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color2, lw=2.0)
    if name == 'eqangle':
        a, b, c, d, e, f, g, h = args

        x = line_line_intersection(Line(a, b), Line(c, d))
        if b.distance(x) > a.distance(x):
            a, b = b, a
        if d.distance(x) > c.distance(x):
            c, d = d, c
        a, b, d = x, a, c

        y = line_line_intersection(Line(e, f), Line(g, h))
        if f.distance(y) > e.distance(y):
            e, f = f, e
        if h.distance(y) > g.distance(y):
            g, h = h, g
        e, f, h = y, e, g

        _draw_line(ax, a, b, color=lcolor, lw=2.0)
        _draw_line(ax, a, d, color=lcolor, lw=2.0)
        _draw_line(ax, e, f, color=lcolor, lw=2.0)
        _draw_line(ax, e, h, color=lcolor, lw=2.0)
        if color1 == '--':
            color1 = 'red'
        draw_angle(ax, a, b, d, color=color1, alpha=0.5)
        if color2 == '--':
            color2 = 'red'
        draw_angle(ax, e, f, h, color=color2, alpha=0.5)
    if name == 'perp':
        a, b, c, d = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color1, lw=2.0)
    if name == 'ratio':
        a, b, c, d, m, n = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color2, lw=2.0)
    if name == 'cong':
        a, b, c, d = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color2, lw=2.0)
    if name == 'midp':
        m, a, b = args
        _draw_line(ax, a, m, color=color1, lw=2.0, alpha=0.5)
        _draw_line(ax, b, m, color=color2, lw=2.0, alpha=0.5)
    if name == 'eqratio':
        a, b, c, d, m, n, p, q = args
        _draw_line(ax, a, b, color=color1, lw=2.0, alpha=0.5)
        _draw_line(ax, c, d, color=color2, lw=2.0, alpha=0.5)
        _draw_line(ax, m, n, color=color1, lw=2.0, alpha=0.5)
        _draw_line(ax, p, q, color=color2, lw=2.0, alpha=0.5)

        
def _draw(
        ax: matplotlib.axes.Axes,
        points: list[gm.Point],
        lines: list[gm.Line],
        circles: list[gm.Circle],
        goal: Any,
        equals: list[tuple[Any, Any]],
        highlights: list[tuple[str, list[gm.Point]]],
):
    """"""Draw everything.""""""
    colors = ['red', 'green', 'blue', 'orange', 'magenta', 'purple']
    pcolor = 'black'
    lcolor = 'black'
    ccolor = 'grey'
    if get_theme() == 'dark':
        pcolor, lcolor, ccolor = 'white', 'white', 'cyan'
    elif get_theme() == 'light':
        pcolor, lcolor, ccolor = 'black', 'black', 'blue'
    elif get_theme() == 'grey':
        pcolor, lcolor, ccolor = 'black', 'black', 'grey'
        colors = ['grey']

    line_boundaries = []
    for l in lines:
        p1, p2 = draw_line(ax, l, color=lcolor)
        line_boundaries.append((p1, p2))
    circles = [draw_circle(ax, c, color=ccolor) for c in circles]

    for p in points:
        draw_point(ax, p.num, p.name, line_boundaries, circles, color=pcolor)

    if equals:
        for i, segs in enumerate(equals['segments']):
            color = colors[i % len(colors)]
            for a, b in segs:
                mark_segment(ax, a, b, color, 0.5)

        for i, angs in enumerate(equals['angles']):
            color = colors[i % len(colors)]
            for a, b, c, d in angs:
                highlight_angle(ax, a, b, c, d, color, 0.5)

    if highlights:
        global HCOLORS
        if HCOLORS is None:
            HCOLORS = [k for k in mcolors.TABLEAU_COLORS.keys() if 'red' not in k]

        for i, (name, args) in enumerate(highlights):
            color_i = HCOLORS[i % len(HCOLORS)]
            highlight(ax, name, args, 'black', color_i, color_i)

    if goal:
        name, args = goal
        lcolor = color1 = color2 = 'red'
        highlight(ax, name, args, lcolor, color1, color2)


def set_theme(theme) -> None:
    global THEME
    THEME = theme


def get_theme() -> str:
    return THEME


def draw(
        points: list[gm.Point],
        lines: list[gm.Line],
        circles: list[gm.Circle],
        segments: list[gm.Segment],
        goal: Any = None,
        highlights: list[tuple[str, list[gm.Point]]] = None,
        equals: list[tuple[Any, Any]] = None,
        block: bool = True,
        save_to: str = None,
        theme: str = 'dark',
) -> None:
    """"""Draw everything on the same canvas.""""""
    plt.close()
    imsize = 512 / 100
    fig, ax = plt.subplots(figsize=(imsize, imsize), dpi=100)

    set_theme(theme)

    if get_theme() == 'dark':
        ax.set_facecolor((0.0, 0.0, 0.0))
    else:
        ax.set_facecolor((1.0, 1.0, 1.0))

    _draw(ax, points, lines, circles, goal, equals, highlights)

    plt.axis('equal')
    fig.subplots_adjust(left=0, right=1, top=1, bottom=0, wspace=0, hspace=0)
    if points:
        xmin = min([p.num.x for p in points])
        xmax = max([p.num.x for p in points])
        ymin = min([p.num.y for p in points])
        ymax = max([p.num.y for p in points])
        plt.margins((xmax - xmin) * 0.1, (ymax - ymin) * 0.1)

    plt.show(block=block)


def close_enough(a: float, b: float, tol: float = 1e-12) -> bool:
    return abs(a - b) < tol


def assert_close_enough(a: float, b: float, tol: float = 1e-12) -> None:
    assert close_enough(a, b, tol), f'|{a}-{b}| = {abs(a - b)} >= {tol}'


def ang_of(tail: Point, head: Point) -> float:
    vector = head - tail
    arctan = np.arctan2(vector.y, vector.x) % (2 * np.pi)
    return arctan


def ang_between(tail: Point, head1: Point, head2: Point) -> float:
    ang1 = ang_of(tail, head1)
    ang2 = ang_of(tail, head2)
    diff = ang1 - ang2
    # return diff % (2*np.pi)
    if diff > np.pi:
        return diff - 2 * np.pi
    if diff < -np.pi:
        return 2 * np.pi + diff
    return diff


def head_from(tail: Point, ang: float, length: float = 1) -> Point:
    vector = Point(np.cos(ang) * length, np.sin(ang) * length)
    return tail + vector


def random_points(n: int = 3) -> list[Point]:
    return [Point(unif(-1, 1), unif(-1, 1)) for _ in range(n)]


def random_rfss(*points: list[Point]) -> list[Point]:
    """"""Random rotate-flip-scale-shift a point cloud.""""""
    # center point cloud.
    average = sum(points, Point(0.0, 0.0)) * (1.0 / len(points))
    points = [p - average for p in points]

    # rotate
    ang = unif(0.0, 2 * np.pi)
    sin, cos = np.sin(ang), np.cos(ang)
    # scale and shift
    scale = unif(0.5, 2.0)
    shift = Point(unif(-1, 1), unif(-1, 1))
    points = [p.rotate(sin, cos) * scale + shift for p in points]

    # randomly flip
    if np.random.rand() < 0.5:
        points = [p.flip() for p in points]

    return points


def reduce(
        objs: list[Union[Point, Line, Circle, HalfLine, HoleCircle]],
        existing_points: list[Point],
) -> list[Point]:
    """"""Reduce intersecting objects into one point of intersections.""""""
    if all(isinstance(o, Point) for o in objs):
        return objs

    elif len(objs) == 1:
        return objs[0].sample_within(existing_points)

    elif len(objs) == 2:
        a, b = objs
        result = a.intersect(b)
        if isinstance(result, Point):
            return [result]
        a, b = result
        a_close = any([a.close(x) for x in existing_points])
        if a_close:
            return [b]
        b_close = any([b.close(x) for x in existing_points])
        if b_close:
            return [a]
        return [np.random.choice([a, b])]

    else:
        raise ValueError(f'Cannot reduce {objs}')


def sketch(
        name: str, args: list[Union[Point, gm.Point]]
) -> list[Union[Point, Line, Circle, HalfLine, HoleCircle]]:
    fun = globals()['sketch_' + name]
    args = [p.num if isinstance(p, gm.Point) else p for p in args]
    out = fun(args)

    # out can be one or multiple {Point/Line/HalfLine}
    if isinstance(out, (tuple, list)):
        return list(out)
    return [out]


def sketch_on_opline(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b = args
    return HalfLine(a, a + a - b)


def sketch_on_hline(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b = args
    return HalfLine(a, b)


def sketch_ieq_triangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)

    c, _ = Circle(a, p1=b).intersect(Circle(b, p1=a))
    return a, b, c


def sketch_incenter2(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    l1 = sketch_bisect([b, a, c])
    l2 = sketch_bisect([a, b, c])
    i = line_line_intersection(l1, l2)
    x = i.foot(Line(b, c))
    y = i.foot(Line(c, a))
    z = i.foot(Line(a, b))
    return x, y, z, i


def sketch_excenter2(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    l1 = sketch_bisect([b, a, c])
    l2 = sketch_exbisect([a, b, c])
    i = line_line_intersection(l1, l2)
    x = i.foot(Line(b, c))
    y = i.foot(Line(c, a))
    z = i.foot(Line(a, b))
    return x, y, z, i


def sketch_centroid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    x = (b + c) * 0.5
    y = (c + a) * 0.5
    z = (a + b) * 0.5
    i = line_line_intersection(Line(a, x), Line(b, y))
    return x, y, z, i


def sketch_ninepoints(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    x = (b + c) * 0.5
    y = (c + a) * 0.5
    z = (a + b) * 0.5
    c = Circle(p1=x, p2=y, p3=z)
    return x, y, z, c.center


def sketch_2l1c(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch a circle touching two lines and another circle.""""""
    a, b, c, p = args
    bc, ac = Line(b, c), Line(a, c)
    circle = Circle(p, p1=a)

    d, d_ = line_circle_intersection(p.perpendicular_line(bc), circle)
    if bc.diff_side(d_, a):
        d = d_

    e, e_ = line_circle_intersection(p.perpendicular_line(ac), circle)
    if ac.diff_side(e_, b):
        e = e_

    df = d.perpendicular_line(Line(p, d))
    ef = e.perpendicular_line(Line(p, e))
    f = line_line_intersection(df, ef)

    g, g_ = line_circle_intersection(Line(c, f), circle)
    if bc.same_side(g_, a):
        g = g_

    b_ = c + (b - c) / b.distance(c)
    a_ = c + (a - c) / a.distance(c)
    m = (a_ + b_) * 0.5
    x = line_line_intersection(Line(c, m), Line(p, g))
    return x.foot(ac), x.foot(bc), g, x


def sketch_3peq(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    ab, bc, ca = Line(a, b), Line(b, c), Line(c, a)

    z = b + (c - b) * np.random.uniform(-0.5, 1.5)

    z_ = z * 2 - c
    l = z_.parallel_line(ca)
    x = line_line_intersection(l, ab)
    y = z * 2 - x
    return x, y, z


def try_to_sketch_intersect(
        name1: str,
        args1: list[Union[gm.Point, Point]],
        name2: str,
        args2: list[Union[gm.Point, Point]],
        existing_points: list[Point],
) -> Optional[Point]:
    """"""Try to sketch an intersection between two objects.""""""
    obj1 = sketch(name1, args1)[0]
    obj2 = sketch(name2, args2)[0]

    if isinstance(obj1, Line) and isinstance(obj2, Line):
        fn = line_line_intersection
    elif isinstance(obj1, Circle) and isinstance(obj2, Circle):
        fn = circle_circle_intersection
    else:
        fn = line_circle_intersection
        if isinstance(obj2, Line) and isinstance(obj1, Circle):
            obj1, obj2 = obj2, obj1

    try:
        x = fn(obj1, obj2)
    except:  # pylint: disable=bare-except
        return None

    if isinstance(x, Point):
        return x

    x1, x2 = x

    close1 = check_too_close([x1], existing_points)
    far1 = check_too_far([x1], existing_points)
    if not close1 and not far1:
        return x1
    close2 = check_too_close([x2], existing_points)
    far2 = check_too_far([x2], existing_points)
    if not close2 and not far2:
        return x2

    return None


def sketch_acircle(args: tuple[gm.Point, ...]) -> Circle:
    a, b, c, d, f = args
    de = sketch_aline([c, a, b, f, d])
    fe = sketch_aline([a, c, b, d, f])
    e = line_line_intersection(de, fe)
    return Circle(p1=d, p2=e, p3=f)


def sketch_aline(args: tuple[gm.Point, ...]) -> HalfLine:
    """"""Sketch the construction aline.""""""
    A, B, C, D, E = args
    ab = A - B
    cb = C - B
    de = D - E

    dab = A.distance(B)
    ang_ab = np.arctan2(ab.y / dab, ab.x / dab)

    dcb = C.distance(B)
    ang_bc = np.arctan2(cb.y / dcb, cb.x / dcb)

    dde = D.distance(E)
    ang_de = np.arctan2(de.y / dde, de.x / dde)

    ang_ex = ang_de + ang_bc - ang_ab
    X = E + Point(np.cos(ang_ex), np.sin(ang_ex))
    return HalfLine(E, X)


def sketch_amirror(args: tuple[gm.Point, ...]) -> HalfLine:
    """"""Sketch the angle mirror.""""""
    A, B, C = args  # pylint: disable=invalid-name
    ab = A - B
    cb = C - B

    dab = A.distance(B)
    ang_ab = np.arctan2(ab.y / dab, ab.x / dab)
    dcb = C.distance(B)
    ang_bc = np.arctan2(cb.y / dcb, cb.x / dcb)

    ang_bx = 2 * ang_bc - ang_ab
    X = B + Point(np.cos(ang_bx), np.sin(ang_bx))  # pylint: disable=invalid-name
    return HalfLine(B, X)


def sketch_bisect(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    ab = a.distance(b)
    bc = b.distance(c)
    x = b + (c - b) * (ab / bc)
    m = (a + x) * 0.5
    return Line(b, m)


def sketch_exbisect(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    return sketch_bisect(args).perpendicular_line(b)


def sketch_bline(args: tuple[gm.Point, ...]) -> Line:
    a, b = args
    m = (a + b) * 0.5
    return m.perpendicular_line(Line(a, b))


def sketch_dia(args: tuple[gm.Point, ...]) -> Circle:
    a, b = args
    return Circle((a + b) * 0.5, p1=a)


def sketch_tangent(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, o, b = args
    dia = sketch_dia([a, o])
    return circle_circle_intersection(Circle(o, p1=b), dia)


def sketch_circle(args: tuple[gm.Point, ...]) -> Circle:
    a, b, c = args
    return Circle(center=a, radius=b.distance(c))


def sketch_cc_tangent(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch tangents to two circles.""""""
    o, a, w, b = args
    ra, rb = o.distance(a), w.distance(b)

    ow = Line(o, w)
    if close_enough(ra, rb):
        oo = ow.perpendicular_line(o)
        oa = Circle(o, ra)
        x, z = line_circle_intersection(oo, oa)
        y = x + w - o
        t = z + w - o
        return x, y, z, t

    swap = rb > ra
    if swap:
        o, a, w, b = w, b, o, a
        ra, rb = rb, ra

    oa = Circle(o, ra)
    q = o + (w - o) * ra / (ra - rb)

    x, z = circle_circle_intersection(sketch_dia([o, q]), oa)
    y = w.foot(Line(x, q))
    t = w.foot(Line(z, q))

    if swap:
        x, y, z, t = y, x, t, z

    return x, y, z, t


def sketch_hcircle(args: tuple[gm.Point, ...]) -> HoleCircle:
    a, b = args
    return HoleCircle(center=a, radius=a.distance(b), hole=b)


def sketch_e5128(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b, c, d = args
    ad = Line(a, d)

    g = (a + b) * 0.5
    de = Line(d, g)

    e, f = line_circle_intersection(de, Circle(c, p1=b))

    if e.distance(d) < f.distance(d):
        e = f
    return e, g


def sketch_eq_quadrangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch quadrangle with two equal opposite sides.""""""
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)

    length = np.random.uniform(0.5, 2.0)
    ang = np.random.uniform(np.pi / 3, np.pi * 2 / 3)
    d = head_from(a, ang, length)

    ang = ang_of(b, d)
    ang = np.random.uniform(ang / 10, ang / 9)
    c = head_from(b, ang, length)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_eq_trapezoid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)
    l = unif(0.5, 2.0)

    height = unif(0.5, 2.0)
    c = Point(0.5 + l / 2.0, height)
    d = Point(0.5 - l / 2.0, height)

    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_eqangle2(args: tuple[gm.Point, ...]) -> Point:
    """"""Sketch the def eqangle2.""""""
    a, b, c = args

    d = c * 2 - b

    ba = b.distance(a)
    bc = b.distance(c)
    l = ba * ba / bc

    if unif(0.0, 1.0) < 0.5:
        be = min(l, bc)
        be = unif(be * 0.1, be * 0.9)
    else:
        be = max(l, bc)
        be = unif(be * 1.1, be * 1.5)

    e = b + (c - b) * (be / bc)
    y = b + (a - b) * (be / l)
    return line_line_intersection(Line(c, y), Line(a, e))


def sketch_eqangle3(args: tuple[gm.Point, ...]) -> Circle:
    a, b, d, e, f = args
    de = d.distance(e)
    ef = e.distance(f)
    ab = b.distance(a)
    ang_ax = ang_of(a, b) + ang_between(e, d, f)
    x = head_from(a, ang_ax, length=de / ef * ab)
    return Circle(p1=a, p2=b, p3=x)


def sketch_eqdia_quadrangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch quadrangle with two equal diagonals.""""""
    m = unif(0.3, 0.7)
    n = unif(0.3, 0.7)
    a = Point(-m, 0.0)
    c = Point(1 - m, 0.0)
    b = Point(0.0, -n)
    d = Point(0.0, 1 - n)

    ang = unif(-0.25 * np.pi, 0.25 * np.pi)
    sin, cos = np.sin(ang), np.cos(ang)
    b = b.rotate(sin, cos)
    d = d.rotate(sin, cos)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_free(args: tuple[gm.Point, ...]) -> Point:
    return random_points(1)[0]


def sketch_isos(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    base = unif(0.5, 1.5)
    height = unif(0.5, 1.5)

    b = Point(-base / 2, 0.0)
    c = Point(base / 2, 0.0)
    a = Point(0.0, height)
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_line(args: tuple[gm.Point, ...]) -> Line:
    a, b = args
    return Line(a, b)


def sketch_cyclic(args: tuple[gm.Point, ...]) -> Circle:
    a, b, c = args
    return Circle(p1=a, p2=b, p3=c)


def sketch_hline(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b = args
    return HalfLine(a, b)


def sketch_midp(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    return (a + b) * 0.5


def sketch_pentagon(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    points = [Point(1.0, 0.0)]
    ang = 0.0

    for i in range(4):
        ang += (2 * np.pi - ang) / (5 - i) * unif(0.5, 1.5)
        point = Point(np.cos(ang), np.sin(ang))
        points.append(point)

    a, b, c, d, e = points  # pylint: disable=unbalanced-tuple-unpacking
    a, b, c, d, e = random_rfss(a, b, c, d, e)
    return a, b, c, d, e


def sketch_pline(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    return a.parallel_line(Line(b, c))


def sketch_pmirror(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    return b * 2 - a


def sketch_quadrangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch a random quadrangle.""""""
    m = unif(0.3, 0.7)
    n = unif(0.3, 0.7)

    a = Point(-m, 0.0)
    c = Point(1 - m, 0.0)
    b = Point(0.0, -unif(0.25, 0.75))
    d = Point(0.0, unif(0.25, 0.75))

    ang = unif(-0.25 * np.pi, 0.25 * np.pi)
    sin, cos = np.sin(ang), np.cos(ang)
    b = b.rotate(sin, cos)
    d = d.rotate(sin, cos)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_r_trapezoid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 1.0)
    d = Point(0.0, 0.0)
    b = Point(unif(0.5, 1.5), 1.0)
    c = Point(unif(0.5, 1.5), 0.0)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_r_triangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(0.0, unif(0.5, 2.0))
    c = Point(unif(0.5, 2.0), 0.0)
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_rectangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(0.0, 1.0)
    l = unif(0.5, 2.0)
    c = Point(l, 1.0)
    d = Point(l, 0.0)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_reflect(args: tuple[gm.Point, ...]) -> Point:
    a, b, c = args
    m = a.foot(Line(b, c))
    return m * 2 - a


def sketch_risos(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(0.0, 1.0)
    c = Point(1.0, 0.0)
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_rotaten90(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    ang = -np.pi / 2
    return a + (b - a).rotate(np.sin(ang), np.cos(ang))


def sketch_rotatep90(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    ang = np.pi / 2
    return a + (b - a).rotate(np.sin(ang), np.cos(ang))


def sketch_s_angle(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b, y = args
    ang = y / 180 * np.pi
    x = b + (a - b).rotatea(ang)
    return HalfLine(b, x)


def sketch_segment(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b = random_points(2)
    return a, b


def sketch_shift(args: tuple[gm.Point, ...]) -> Point:
    a, b, c = args
    return c + (b - a)


def sketch_square(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b = args
    c = b + (a - b).rotatea(-np.pi / 2)
    d = a + (b - a).rotatea(np.pi / 2)
    return c, d


def sketch_isquare(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)
    c = Point(1.0, 1.0)
    d = Point(0.0, 1.0)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_tline(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    return a.perpendicular_line(Line(b, c))


def sketch_trapezoid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    d = Point(0.0, 0.0)
    c = Point(1.0, 0.0)

    base = unif(0.5, 2.0)
    height = unif(0.5, 2.0)
    a = Point(unif(0.2, 0.5), height)
    b = Point(a.x + base, height)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_triangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)
    ac = unif(0.5, 2.0)
    ang = unif(0.2, 0.8) * np.pi
    c = head_from(a, ang, ac)
    return a, b, c


def sketch_triangle12(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    b = Point(0.0, 0.0)
    c = Point(unif(1.5, 2.5), 0.0)
    a, _ = circle_circle_intersection(Circle(b, 1.0), Circle(c, 2.0))
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_trisect(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    """"""Sketch two trisectors of an angle.""""""
    a, b, c = args
    ang1 = ang_of(b, a)
    ang2 = ang_of(b, c)

    swap = 0
    if ang1 > ang2:
        ang1, ang2 = ang2, ang1
        swap += 1

    if ang2 - ang1 > np.pi:
        ang1, ang2 = ang2, ang1 + 2 * np.pi
        swap += 1

    angx = ang1 + (ang2 - ang1) / 3
    angy = ang2 - (ang2 - ang1) / 3

    x = b + Point(np.cos(angx), np.sin(angx))
    y = b + Point(np.cos(angy), np.sin(angy))

    ac = Line(a, c)
    x = line_line_intersection(Line(b, x), ac)
    y = line_line_intersection(Line(b, y), ac)

    if swap == 1:
        return y, x
    return x, y


def sketch_trisegment(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b = args
    x, y = a + (b - a) * (1.0 / 3), a + (b - a) * (2.0 / 3)
    return x, y
import types

# Create the module Numericals as nm
nm = types.ModuleType('nm')

# Add classes to nm
nm.Point = Point
nm.Line = Line
nm.HalfLine = HalfLine
nm.Circle = Circle
nm.HoleCircle = HoleCircle
nm.InvalidLineIntersectError = InvalidLineIntersectError
nm.InvalidQuadSolveError = InvalidQuadSolveError

# Add functions to nm
nm._perpendicular_bisector = _perpendicular_bisector
nm.same_sign = same_sign
nm.solve_quad = solve_quad
nm.circle_circle_intersection = circle_circle_intersection
nm.line_circle_intersection = line_circle_intersection
nm._check_between = _check_between
nm.circle_segment_intersect = circle_segment_intersect
nm.line_segment_intersection = line_segment_intersection
nm.line_line_intersection = line_line_intersection
nm.check_too_close = check_too_close
nm.check_too_far = check_too_far
nm.check_aconst = check_aconst
nm.check = check
nm.check_circle = check_circle
nm.check_coll = check_coll
nm.check_ncoll = check_ncoll
nm.check_sameside = check_sameside
nm.check_para_or_coll = check_para_or_coll
nm.check_para = check_para
nm.check_perp = check_perp
nm.check_cyclic = check_cyclic
nm.bring_together = bring_together
nm.same_clock = same_clock
nm.check_const_angle = check_const_angle
nm.check_eqangle = check_eqangle
nm.check_eqratio = check_eqratio
nm.check_cong = check_cong
nm.check_midp = check_midp
nm.check_simtri = check_simtri
nm.check_contri = check_contri
nm.check_ratio = check_ratio
nm.draw_angle = draw_angle
nm.naming_position = naming_position
nm.draw_point = draw_point
nm._draw_line = _draw_line
nm.draw_line = draw_line
nm._draw_circle = _draw_circle
nm.draw_circle = draw_circle
nm.mark_segment = mark_segment
nm.highlight_angle = highlight_angle
nm.highlight = highlight
nm._draw = _draw
nm.set_theme = set_theme
nm.get_theme = get_theme
nm.draw = draw
nm.close_enough = close_enough
nm.assert_close_enough = assert_close_enough
nm.ang_of = ang_of
nm.ang_between = ang_between
nm.head_from = head_from
nm.random_points = random_points
nm.random_rfss = random_rfss
nm.reduce = reduce
nm.sketch = sketch
nm.sketch_on_opline = sketch_on_opline
nm.sketch_on_hline = sketch_on_hline
nm.sketch_ieq_triangle = sketch_ieq_triangle
nm.sketch_incenter2 = sketch_incenter2
nm.sketch_excenter2 = sketch_excenter2
nm.sketch_centroid = sketch_centroid
nm.sketch_ninepoints = sketch_ninepoints
nm.sketch_2l1c = sketch_2l1c
nm.sketch_3peq = sketch_3peq
nm.try_to_sketch_intersect = try_to_sketch_intersect
nm.sketch_acircle = sketch_acircle
nm.sketch_aline = sketch_aline
nm.sketch_amirror = sketch_amirror
nm.sketch_bisect = sketch_bisect
nm.sketch_exbisect = sketch_exbisect
nm.sketch_bline = sketch_bline
nm.sketch_dia = sketch_dia
nm.sketch_tangent = sketch_tangent
nm.sketch_circle = sketch_circle
nm.sketch_cc_tangent = sketch_cc_tangent
nm.sketch_hcircle = sketch_hcircle
nm.sketch_e5128 = sketch_e5128
nm.sketch_eq_quadrangle = sketch_eq_quadrangle
nm.sketch_eq_trapezoid = sketch_eq_trapezoid
nm.sketch_eqangle2 = sketch_eqangle2
nm.sketch_eqangle3 = sketch_eqangle3
nm.sketch_eqdia_quadrangle = sketch_eqdia_quadrangle
nm.sketch_free = sketch_free
nm.sketch_isos = sketch_isos
nm.sketch_line = sketch_line
nm.sketch_cyclic = sketch_cyclic
nm.sketch_hline = sketch_hline
nm.sketch_midp = sketch_midp
nm.sketch_pentagon = sketch_pentagon
nm.sketch_pline = sketch_pline
nm.sketch_pmirror = sketch_pmirror
nm.sketch_quadrangle = sketch_quadrangle
nm.sketch_r_trapezoid = sketch_r_trapezoid
nm.sketch_r_triangle = sketch_r_triangle
nm.sketch_rectangle = sketch_rectangle
nm.sketch_reflect = sketch_reflect
nm.sketch_risos = sketch_risos
nm.sketch_rotaten90 = sketch_rotaten90
nm.sketch_rotatep90 = sketch_rotatep90
nm.sketch_s_angle = sketch_s_angle
nm.sketch_segment = sketch_segment
nm.sketch_shift = sketch_shift
nm.sketch_square = sketch_square
nm.sketch_isquare = sketch_isquare
nm.sketch_tline = sketch_tline
nm.sketch_trapezoid = sketch_trapezoid
nm.sketch_triangle = sketch_triangle
nm.sketch_triangle12 = sketch_triangle12
nm.sketch_trisect = sketch_trisect
nm.sketch_trisegment = sketch_trisegment

**GRAPH UTILS**
""""""Utilizations for graph representation.

In these functions, we're dealing with permutations and combinations.
These are fundamental concepts in combinatorics. 

A permutation of a set is an arrangement of its members into a sequence or linear order. 
In contrast, a combination is a way of selecting items from a collection, such that the order of selection does not matter. 

The functions 'perm3' and 'perm4' extend these ideas to 3 and 4 elements, respectively.
""""""



def _cross(elems1, elems2):
    """"""Generator function for producing all pairs of elements from two lists.

    Args:
        elems1 (list): The first list of elements.
        elems2 (list): The second list of elements.

    Yields:
        tuple: A pair of elements, one from each list.

    Example:
        >>> list(_cross([1, 2], ['a', 'b']))
        [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
    """"""
    for e1 in elems1:
        for e2 in elems2:
            yield e1, e2


def cross(elems1, elems2):
    """"""Function to get all pairs of elements from two lists.

    Args:
        elems1 (list): The first list of elements.
        elems2 (list): The second list of elements.

    Returns:
        list of tuples: A list containing all pairs of elements.

    Example:
        >>> cross([1, 2], ['a', 'b'])
        [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
    """"""
    return list(_cross(elems1, elems2))


def _comb2(elems):
    """"""Generator function for producing all 2-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 2-element combination of the list.

    Example:
        >>> list(_comb2([1, 2, 3]))
        [(1, 2), (1, 3), (2, 3)]
    """"""
    if len(elems) < 2:
        return
    for i, e1 in enumerate(elems[:-1]):
        for e2 in elems[i + 1:]:
            yield e1, e2


def comb2(elems):
    """"""Function to get all 2-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 2-element combinations.

    Example:
        >>> comb2([1, 2, 3])
        [(1, 2), (1, 3), (2, 3)]
    """"""
    return list(_comb2(elems))


def _comb3(elems):
    """"""Generator function for producing all 3-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 3-element combination of the list.

    Example:
        >>> list(_comb3([1, 2, 3, 4]))
        [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]
    """"""
    if len(elems) < 3:
        return
    for i, e1 in enumerate(elems[:-2]):
        for j, e2 in enumerate(elems[i + 1: -1]):
            for e3 in elems[i + j + 2:]:
                yield e1, e2, e3


def comb3(elems):
    """"""Function to get all 3-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 3-element combinations.

    Example:
        >>> comb3([1, 2, 3, 4])
        [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]
    """"""
    return list(_comb3(elems))


def _comb4(elems):
    """"""Generator function for producing all 4-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 4-element combination of the list.

    Example:
        >>> list(_comb4([1, 2, 3, 4, 5]))
        [(1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 4, 5), (1, 3, 4, 5), (2, 3, 4, 5)]
    """"""
    if len(elems) < 4:
        return
    for i, e1 in enumerate(elems[:-3]):
        for j, e2 in enumerate(elems[i + 1: -2]):
            for e3, e4 in _comb2(elems[i + j + 2:]):
                yield e1, e2, e3, e4


def comb4(elems):
    """"""Function to get all 4-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 4-element combinations.

    Example:
        >>> comb4([1, 2, 3, 4, 5])
        [(1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 4, 5), (1, 3, 4, 5), (2, 3, 4, 5)]
    """"""
    return list(_comb4(elems))


def _perm2(elems):
    """"""Generator function for producing all 2-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 2-element permutation of the list.

    Example:
        >>> list(_perm2([1, 2]))
        [(1, 2), (2, 1)]
    """"""
    for e1, e2 in comb2(elems):
        yield e1, e2
        yield e2, e1


def perm2(elems):
    """"""Function to get all 2-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 2-element permutations.

    Example:
        >>> perm2([1, 2])
        [(1, 2), (2, 1)]
    """"""
    return list(_perm2(elems))


def _all_4points(l1, l2):
    """"""Generator function for producing all 4-point permutations from two lines.

    Args:
        l1 (Line): The first line.
        l2 (Line): The second line.

    Yields:
        tuple: A 4-point permutation, two from each line.

    Example:
        >>> line1 = Line(Point(0, 0), Point(1, 1))
        >>> line2 = Line(Point(0, 1), Point(1, 0))
        >>> list(_all_4points(line1, line2))
        # Yields all permutations of points on line1 and line2
    """"""
    p1s = l1.neighbors(gm.Point)
    p2s = l2.neighbors(gm.Point)
    for a, b in perm2(p1s):
        for c, d in perm2(p2s):
            yield a, b, c, d


def all_4points(l1, l2):
    """"""Function to get all 4-point permutations from two lines.

    Args:
        l1 (Line): The first line.
        l2 (Line): The second line.

    Returns:
        list of tuples: A list of all 4-point permutations, two from each line.

    Example:
        >>> line1 = Line(Point(0, 0), Point(1, 1))
        >>> line2 = Line(Point(0, 1), Point(1, 0))
        >>> all_4points(line1, line2)
        # Returns all permutations of points on line1 and line2
    """"""
    return list(_all_4points(l1, l2))


def _all_8points(l1, l2, l3, l4):
    """"""Generator function for producing all 8-point permutations from four lines.

    Args:
        l1, l2, l3, l4 (Line): The four lines.

    Yields:
        tuple: An 8-point permutation, two from each line.

    Example:
        >>> line1, line2, line3, line4 = [Line(Point(0, 0), Point(1, 1))] * 4
        >>> list(_all_8points(line1, line2, line3, line4))
        # Yields all permutations of points on the four lines
    """"""
    for a, b, c, d in all_4points(l1, l2):
        for e, f, g, h in all_4points(l3, l4):
            yield (a, b, c, d, e, f, g, h)


def all_8points(l1, l2, l3, l4):
    """"""Function to get all 8-point permutations from four lines.

    Each line contributes two points, resulting in permutations of 8 points total.

    Args:
        l1, l2, l3, l4 (Line): The four lines.

    Returns:
        list of tuples: A list of all 8-point permutations, two from each line.

    Example:
        >>> line1, line2, line3, line4 = [Line(Point(0, 0), Point(1, 1))] * 4
        >>> all_8points(line1, line2, line3, line4)
        # Returns all permutations of points on the four lines
    """"""
    return list(_all_8points(l1, l2, l3, l4))


def _perm3(elems):
    """"""Generator function for producing all 3-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 3-element permutation of the list.

    Example:
        >>> list(_perm3([1, 2, 3]))
        [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
    """"""
    for x in elems:
        for y in elems:
            if y == x:
                continue
            for z in elems:
                if z not in (x, y):
                    yield x, y, z


def perm3(elems):
    """"""Function to get all 3-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 3-element permutations.

    Example:
        >>> perm3([1, 2, 3])
        [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
    """"""
    return list(_perm3(elems))


def _perm4(elems):
    """"""Generator function for producing all 4-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 4-element permutation of the list.

    Example:
        >>> list(_perm4([1, 2, 3, 4]))
        # Yields all 4-element permutations of [1, 2, 3, 4]
    """"""
    for x in elems:
        for y in elems:
            if y == x:
                continue
            for z in elems:
                if z in (x, y):
                    continue
                for t in elems:
                    if t not in (x, y, z):
                        yield x, y, z, t


def perm4(elems):
    """"""Function to get all 4-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 4-element permutations.

    Example:
        >>> perm4([1, 2, 3, 4])
        # Returns all 4-element permutations of [1, 2, 3, 4]
    """"""
    return list(_perm4(elems))

**GRAPH**
# Defining lists of sketch types

# List of sketch types that don't depend on existing elements.
#   - These are 'freely' created without prerequisites.
FREE = [
    'free', 'segment', 'r_triangle', 'risos', 'triangle', 'triangle12',
    'ieq_triangle', 'eq_quadrangle', 'eq_trapezoid', 'eqdia_quadrangle',
    'quadrangle', 'r_trapezoid', 'rectangle', 'isquare', 'trapezoid',
    'pentagon', 'iso_triangle',
]

# List of sketch types that depend on the intersection of elements.
#   - These are created at the intersection of existing elements like lines and circles.
INTERSECT = [
    'angle_bisector', 'angle_mirror', 'eqdistance', 'lc_tangent',
    'on_aline', 'on_bline', 'on_circle', 'on_line', 'on_pline', 'on_tline',
    'on_dia', 's_angle', 'on_opline', 'eqangle3',
]


class DepCheckFailError(Exception):
    """"""Exception raised when a dependency check fails.

    This exception is used to indicate a failure in checking dependencies 
    for geometric constructions.

    Attributes:
        message (str): Explanation of the error.
    """"""
    pass


class PointTooCloseError(Exception):
    """"""Exception raised when a newly generated point is too close to existing points.

    This exception is used to avoid clustering of points in geometric constructions.

    Attributes:
        message (str): Explanation of the error.
    """"""
    pass


class PointTooFarError(Exception):
    """"""Exception raised when a newly generated point is too far from existing points.

    This exception is used to maintain a reasonable proximity of points in geometric constructions.

    Attributes:
        message (str): Explanation of the error.
    """"""
    pass


def create_consts_str(g: Graph, s: str) -> Union[Ratio, Angle]:
    """"""Create constants in string format and add them to the graph.

    This function takes a string representation of a constant (either a ratio or an angle)
    and adds the corresponding constant node to the graph.

    Args:
        g (Graph): The graph to which the constant is added.
        s (str): The string representation of the constant.

    Returns:
        Union[Ratio, Angle]: The created constant node.

    Raises:
        ValueError: If the string format is incorrect.

    Example:
        >>> g = Graph()
        >>> create_consts_str(g, '180/pi')
        # This will create an Angle constant in the graph
    """"""
        # If the string contains 'pi/', it is treated as an angle. 
        #   - The format is expected to be ""npi/d"" where n and d are integers.
        if 'pi/' in s:
            # Splitting the string into numerator (n) and denominator (d) parts.
            n, d = s.split('pi/')  
            
            # Converting both parts to integers.
            n, d = int(n), int(d)  
            
            # Creating or retrieving an angle constant from the graph.
            p0, _ = g.get_or_create_const_ang(n, d)  
            
        # If the string does not contain 'pi/', it is treated as a ratio. 
        #   - The format is expected to be ""n/d"".
        else:
            # Splitting the string into numerator (n) and denominator (d) parts.
            n, d = s.split('/')  
            
            # Converting both parts to integers.
            n, d = int(n), int(d)  
            
            # Creating or retrieving a ratio constant from the graph.
            p0, _ = g.get_or_create_const_rat(n, d)  
        
        # Return the constant node
        return p0 


def create_consts(g: Graph, p: gm.Node) -> Union[Ratio, Angle]:
    """"""Create constants based on a geometric node and add them to the graph.

    This function extracts the ratio or angle information from a geometric node
    and adds the corresponding constant node to the graph.

    Args:
        g (Graph): The graph to which the constant is added.
        p (gm.Node): The geometric node containing constant information.

    Returns:
        Union[Ratio, Angle]: The created constant node.

    Raises:
        ValueError: If the node type is unsupported.

    Example:
        >>> g = Graph()
        >>> angle_node = Angle('90/pi')
        >>> create_consts(g, angle_node)
        # This will create an Angle constant in the graph
    """"""
    # If the node is an Angle, extract the angle ratio from its name.
    if isinstance(p, Angle):
        
        # The format is expected to be ""npi/d"" where n and d are integers.
        n, d = p.name.split('pi/')
        
        # Converting both parts to integers.
        n, d = int(n), int(d)
        
        # Creating or retrieving an angle constant from the graph.
        p0, _ = g.get_or_create_const_ang(n, d)
    
    # If the node is a Ratio, extract the ratio values from its name.
    elif isinstance(p, Ratio):
        
        # The format is expected to be ""n/d"".
        n, d = p.name.split('/')  
        
        # Converting both parts to integers.
        n, d = int(n), int(d)  
        
        # Creating or retrieving a ratio constant from the graph.
        p0, _ = g.get_or_create_const_rat(n, d)  
    
    # If the node is neither an Angle nor a Ratio, raise an error.
    else:
        raise ValueError(f""Unsupported node type: {type(p)}"")
        
    # Returning the constant node.
    return p0  
<br>

<a id=""ar""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""ar"">6&nbsp;&nbsp;ALGEBRAIC REASONING &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.1 <code><b>AR.PY</b></code> FILE <b>IMPORTS</b></h3>
<hr>

We can see by the imports that we are mostly dealing the **`geometry`** submodule, the **`problem`** submodule and a few additional packages (i.e. <a href=""https://docs.python.org/3/library/fractions.html"">`Fractions`</a>, `NumPy`, `SciPy`, etc.)

We also include the license information here as found within the original file:
* https://github.com/google-deepmind/alphageometry/blob/main/ar.py
* **Apache License, Version 2.0**
class InfQuotientError(Exception):
    pass


def _gcd(x: int, y: int) -> int:
    while y:
        x, y = y, x % y
    return x


def simplify(n: int, d: int) -> tuple[int, int]:
    g = _gcd(n, d)
    return (n // g, d // g)


# maximum denominator for a fraction.
MAX_DENOMINATOR = 1000000

# tolerance for fraction approximation
TOL = 1e-15


def get_quotient(v: float) -> tuple[int, int]:
    n = v
    d = 1
    while abs(n - round(n)) > TOL:
        d += 1
        n += v
        if d > MAX_DENOMINATOR:
            e = InfQuotientError(v)
            raise e

    n = int(round(n))
    return simplify(n, d)


def fix_v(v: float) -> float:
    n, d = get_quotient(v)
    return n / d


def fix(e: dict[str, float]) -> dict[str, float]:
    return {k: fix_v(v) for k, v in e.items()}


def frac_string(f: frac) -> str:
    n, d = get_quotient(f)
    return f'{n}/{d}'


def hashed(e: dict[str, float]) -> tuple[tuple[str, float], ...]:
    return tuple(sorted(list(e.items())))


def is_zero(e: dict[str, float]) -> bool:
    return len(strip(e)) == 0  # pylint: disable=g-explicit-length-test


def strip(e: dict[str, float]) -> dict[str, float]:
    return {v: c for v, c in e.items() if c != 0}


def plus(e1: dict[str, float], e2: dict[str, float]) -> dict[str, float]:
    e = dict(e1)
    for v, c in e2.items():
        if v in e:
            e[v] += c
        else:
            e[v] = c
    return strip(e)


def plus_all(*es: list[dict[str, float]]) -> dict[str, float]:
    result = {}
    for e in es:
        result = plus(result, e)
    return result


def mult(e: dict[str, float], m: float) -> dict[str, float]:
    return {v: m * c for v, c in e.items()}


def minus(e1: dict[str, float], e2: dict[str, float]) -> dict[str, float]:
    return plus(e1, mult(e2, -1))


def div(e1: dict[str, float], e2: dict[str, float]) -> float:
    """"""Divide e1 by e2.""""""
    e1 = strip(e1)
    e2 = strip(e2)
    if set(e1.keys()) != set(e2.keys()):
        return None

    n, d = None, None

    for v, c1 in e1.items():
        c2 = e2[v]  # we want c1/c2 = n/d => c1*d=c2*n
        if n is not None and c1 * d != c2 * n:
            return None
        n, d = c1, c2
    return frac(n) / frac(d)


def recon(e: dict[str, float], const: str) -> tuple[str, dict[str, float]]:
    """"""Reconcile one variable in the expression e=0, given const.""""""
    e = strip(e)
    if len(e) == 0:  # pylint: disable=g-explicit-length-test
        return None

    v0 = None
    for v in e:
        if v != const:
            v0 = v
            break
    if v0 is None:
        return v0

    c0 = e.pop(v0)
    return v0, {v: -c / c0 for v, c in e.items()}


def replace(
        e: dict[str, float], v0: str, e0: dict[str, float]
) -> dict[str, float]:
    if v0 not in e:
        return e
    e = dict(e)
    m = e.pop(v0)
    return plus(e, mult(e0, m))


def comb2(elems: list[Any]) -> Generator[tuple[Any, Any], None, None]:
    if len(elems) < 1:
        return
    for i, e1 in enumerate(elems[:-1]):
        for e2 in elems[i + 1:]:
            yield e1, e2


def perm2(elems: list[Any]) -> Generator[tuple[Any, Any], None, None]:
    for e1, e2 in comb2(elems):
        yield e1, e2
        yield e2, e1


def chain2(elems: list[Any]) -> Generator[tuple[Any, Any], None, None]:
    if len(elems) < 2:
        return
    for i, e1 in enumerate(elems[:-1]):
        yield e1, elems[i + 1]


def update_groups(
        groups1: list[Any], groups2: list[Any]
) -> tuple[list[Any], list[tuple[Any, Any]], list[list[Any]]]:
    """"""Update groups of equivalent elements.
  
    Given groups1 = [set1, set2, set3, ..]
    where all elems within each set_i is defined to be ""equivalent"" to each other.
    (but not across the sets)
  
    Incoming groups2 = [set1, set2, ...] similar to set1 - it is the
    additional equivalent information on elements in groups1.
  
    Return the new updated groups1 and the set of links
    that make it that way.
  
    Example:
      groups1 = [{1, 2}, {3, 4, 5}, {6, 7}]
      groups2 = [{2, 3, 8}, {9, 10, 11}]
  
    => new groups1 and links:
      groups1 = [{1, 2, 3, 4, 5, 8}, {6, 7}, {9, 10, 11}]
      links = (2, 3), (3, 8), (9, 10), (10, 11)
  
    Explain: since groups2 says 2 and 3 are equivalent (with {2, 3, 8}),
    then {1, 2} and {3, 4, 5} in groups1 will be merged,
    because 2 and 3 each belong to those 2 groups.
    Additionally 8 also belong to this same group.
    {3, 4, 5} is left alone, while {9, 10, 11} is a completely new set.
  
    The links to make this all happens is:
    (2, 3): to merge {1, 2} and {3, 4, 5}
    (3, 8): to link 8 into the merged({1, 2, 3, 4, 5})
    (9, 10) and (10, 11): to make the new group {9, 10, 11}
  
    Args:
      groups1: a list of sets.
      groups2: a list of sets.
  
    Returns:
      groups1, links, history: result of the update.
    """"""
    history = []
    links = []
    for g2 in groups2:
        joins = [None] * len(groups1)  # mark which one in groups1 is merged
        merged_g1 = set()  # merge them into this.
        old = None  # any elem in g2 that belong to any set in groups1 (old)
        new = []  # all elem in g2 that is new

        for e in g2:
            found = False
            for i, g1 in enumerate(groups1):
                if e not in g1:
                    continue

                found = True
                if joins[i]:
                    continue

                joins[i] = True
                merged_g1.update(g1)

                if old is not None:
                    links.append((old, e))  # link to make merging happen.
                old = e

            if not found:  # e is new!
                new.append(e)

        # now chain elems in new together.
        if old is not None and new:
            links.append((old, new[0]))
            merged_g1.update(new)

        links += chain2(new)

        new_groups1 = []
        if merged_g1:  # put the merged_g1 in first
            new_groups1.append(merged_g1)

        # put the remaining (unjoined) groups in
        new_groups1 += [g1 for j, g1 in zip(joins, groups1) if not j]

        if old is None and new:
            new_groups1 += [set(new)]

        groups1 = new_groups1
        history.append(groups1)

    return groups1, links, history


class Table:
    """"""The coefficient matrix.""""""

    def __init__(self, const: str = '1'):
        self.const = const
        self.v2e = {}
        self.add_free(const)  # the table {var: expression}

        # to cache what is already derived/inputted
        self.eqs = set()
        self.groups = []  # groups of equal pairs.

        # for why (linprog)
        self.c = []
        self.v2i = {}  # v -> index of row in A.
        self.deps = []  # equal number of columns.
        self.A = np.zeros([0, 0])  # pylint: disable=invalid-name
        self.do_why = True

    def add_free(self, v: str) -> None:
        self.v2e[v] = {v: frac(1)}

    def replace(self, v0: str, e0: dict[str, float]) -> None:
        for v, e in list(self.v2e.items()):
            self.v2e[v] = replace(e, v0, e0)

    def add_expr(self, vc: list[tuple[str, float]]) -> bool:
        """"""Add a new equality, represented by the list of tuples vc=[(v, c), ..].""""""
        result = {}
        free = []

        for v, c in vc:
            c = frac(c)
            if v in self.v2e:
                result = plus(result, mult(self.v2e[v], c))
            else:
                free += [(v, c)]

        if free == []:  # pylint: disable=g-explicit-bool-comparison
            if is_zero(self.modulo(result)):
                return False
            result = recon(result, self.const)
            if result is None:
                return False
            v, e = result
            self.replace(v, e)

        elif len(free) == 1:
            v, m = free[0]
            self.v2e[v] = mult(result, frac(-1, m))

        else:
            dependent_v = None
            for v, m in free:
                if dependent_v is None and v != self.const:
                    dependent_v = (v, m)
                    continue

                self.add_free(v)
                result = plus(result, {v: m})

            v, m = dependent_v
            self.v2e[v] = mult(result, frac(-1, m))

        return True

    def register(self, vc: list[tuple[str, float]], dep: pr.Dependency) -> None:
        """"""Register a new equality vc=[(v, c), ..] with traceback dependency dep.""""""
        result = plus_all(*[{v: c} for v, c in vc])
        if is_zero(result):
            return

        vs, _ = zip(*vc)
        for v in vs:
            if v not in self.v2i:
                self.v2i[v] = len(self.v2i)

        (m, n), l = self.A.shape, len(self.v2i)
        if l > m:
            self.A = np.concatenate([self.A, np.zeros([l - m, n])], 0)

        new_column = np.zeros([len(self.v2i), 2])  # N, 2
        for v, c in vc:
            new_column[self.v2i[v], 0] += float(c)
            new_column[self.v2i[v], 1] -= float(c)

        self.A = np.concatenate([self.A, new_column], 1)
        self.c += [1.0, -1.0]
        self.deps += [dep]

    def register2(
            self, a: str, b: str, m: float, n: float, dep: pr.Dependency
    ) -> None:
        self.register([(a, m), (b, -n)], dep)

    def register3(self, a: str, b: str, f: float, dep: pr.Dependency) -> None:
        self.register([(a, 1), (b, -1), (self.const, -f)], dep)

    def register4(
            self, a: str, b: str, c: str, d: str, dep: pr.Dependency
    ) -> None:
        self.register([(a, 1), (b, -1), (c, -1), (d, 1)], dep)

    def why(self, e: dict[str, float]) -> list[Any]:
        """"""AR traceback == MILP.""""""
        if not self.do_why:
            return []
        # why expr == 0?
        # Solve min(c^Tx) s.t. A_eq * x = b_eq, x >= 0
        e = strip(e)
        if not e:
            return []

        b_eq = [0] * len(self.v2i)
        for v, c in e.items():
            b_eq[self.v2i[v]] += float(c)

        try:
            x = optimize.linprog(c=self.c, A_eq=self.A, b_eq=b_eq, method='highs')[
                'x'
            ]
        except:  # pylint: disable=bare-except
            x = optimize.linprog(
                c=self.c,
                A_eq=self.A,
                b_eq=b_eq,
            )['x']

        deps = []
        for i, dep in enumerate(self.deps):
            if x[2 * i] > 1e-12 or x[2 * i + 1] > 1e-12:
                if dep not in deps:
                    deps.append(dep)
        return deps

    def record_eq(self, v1: str, v2: str, v3: str, v4: str) -> None:
        self.eqs.add((v1, v2, v3, v4))
        self.eqs.add((v2, v1, v4, v3))
        self.eqs.add((v3, v4, v1, v2))
        self.eqs.add((v4, v3, v2, v1))

    def check_record_eq(self, v1: str, v2: str, v3: str, v4: str) -> bool:
        if (v1, v2, v3, v4) in self.eqs:
            return True
        if (v2, v1, v4, v3) in self.eqs:
            return True
        if (v3, v4, v1, v2) in self.eqs:
            return True
        if (v4, v3, v2, v1) in self.eqs:
            return True
        return False

    def add_eq2(
            self, a: str, b: str, m: float, n: float, dep: pr.Dependency
    ) -> None:
        # a/b = m/n
        if not self.add_expr([(a, m), (b, -n)]):
            return []
        self.register2(a, b, m, n, dep)

    def add_eq3(self, a: str, b: str, f: float, dep: pr.Dependency) -> None:
        # a - b = f * constant
        self.eqs.add((a, b, frac(f)))
        self.eqs.add((b, a, frac(1 - f)))

        if not self.add_expr([(a, 1), (b, -1), (self.const, -f)]):
            return []

        self.register3(a, b, f, dep)

    def add_eq4(self, a: str, b: str, c: str, d: str, dep: pr.Dependency) -> None:
        # a - b = c - d
        self.record_eq(a, b, c, d)
        self.record_eq(a, c, b, d)

        expr = list(minus({a: 1, b: -1}, {c: 1, d: -1}).items())

        if not self.add_expr(expr):
            return []

        self.register4(a, b, c, d, dep)
        self.groups, _, _ = update_groups(
            self.groups, [{(a, b), (c, d)}, {(b, a), (d, c)}]
        )

    def pairs(self) -> Generator[list[tuple[str, str]], None, None]:
        for v1, v2 in perm2(list(self.v2e.keys())):  # pylint: disable=g-builtin-op
            if v1 == self.const or v2 == self.const:
                continue
            yield v1, v2

    def modulo(self, e: dict[str, float]) -> dict[str, float]:
        return strip(e)

    def get_all_eqs(
            self,
    ) -> dict[tuple[tuple[str, float], ...], list[tuple[str, str]]]:
        h2pairs = defaultdict(list)
        for v1, v2 in self.pairs():
            e1, e2 = self.v2e[v1], self.v2e[v2]
            e12 = minus(e1, e2)
            h12 = hashed(self.modulo(e12))
            h2pairs[h12].append((v1, v2))
        return h2pairs

    def get_all_eqs_and_why(
            self, return_quads: bool = True
    ) -> Generator[Any, None, None]:
        """"""Check all 4/3/2-permutations for new equalities.""""""
        groups = []

        for h, vv in self.get_all_eqs().items():
            if h == ():  # pylint: disable=g-explicit-bool-comparison
                for v1, v2 in vv:
                    if (v1, v2) in self.eqs or (v2, v1) in self.eqs:
                        continue
                    self.eqs.add((v1, v2))
                    # why v1 - v2 = e12 ?  (note modulo(e12) == 0)
                    why_dict = minus({v1: 1, v2: -1}, minus(self.v2e[v1], self.v2e[v2]))
                    yield v1, v2, self.why(why_dict)
                continue

            if len(h) == 1 and h[0][0] == self.const:
                for v1, v2 in vv:
                    frac = h[0][1]  # pylint: disable=redefined-outer-name
                    if (v1, v2, frac) in self.eqs:
                        continue
                    self.eqs.add((v1, v2, frac))
                    # why v1 - v2 = e12 ?  (note modulo(e12) == 0)
                    why_dict = minus({v1: 1, v2: -1}, minus(self.v2e[v1], self.v2e[v2]))
                    value = simplify(frac.numerator, frac.denominator)
                    yield v1, v2, value, self.why(why_dict)
                continue

            groups.append(vv)

        if not return_quads:
            return

        self.groups, links, _ = update_groups(self.groups, groups)
        for (v1, v2), (v3, v4) in links:
            if self.check_record_eq(v1, v2, v3, v4):
                continue
            e12 = minus(self.v2e[v1], self.v2e[v2])
            e34 = minus(self.v2e[v3], self.v2e[v4])

            why_dict = minus(  # why (v1-v2)-(v3-v4)=e12-e34?
                minus({v1: 1, v2: -1}, {v3: 1, v4: -1}), minus(e12, e34)
            )
            self.record_eq(v1, v2, v3, v4)
            yield v1, v2, v3, v4, self.why(why_dict)


class GeometricTable(Table):
    """"""Abstract class representing the coefficient matrix (table) A.""""""

    def __init__(self, name: str = ''):
        super().__init__(name)
        self.v2obj = {}

    def get_name(self, objs: list[Any]) -> list[str]:
        self.v2obj.update({o.name: o for o in objs})
        return [o.name for o in objs]

    def map2obj(self, names: list[str]) -> list[Any]:
        return [self.v2obj[n] for n in names]

    def get_all_eqs_and_why(
            self, return_quads: bool
    ) -> Generator[Any, None, None]:
        for out in super().get_all_eqs_and_why(return_quads):
            if len(out) == 3:
                x, y, why = out
                x, y = self.map2obj([x, y])
                yield x, y, why
            if len(out) == 4:
                x, y, f, why = out
                x, y = self.map2obj([x, y])
                yield x, y, f, why
            if len(out) == 5:
                a, b, x, y, why = out
                a, b, x, y = self.map2obj([a, b, x, y])
                yield a, b, x, y, why


class RatioTable(GeometricTable):
    """"""Coefficient matrix A for log(distance).""""""

    def __init__(self, name: str = ''):
        name = name or '1'
        super().__init__(name)
        self.one = self.const

    def add_eq(self, l1: gm.Length, l2: gm.Length, dep: pr.Dependency) -> None:
        l1, l2 = self.get_name([l1, l2])
        return super().add_eq3(l1, l2, 0.0, dep)

    def add_const_ratio(
            self, l1: gm.Length, l2: gm.Length, m: float, n: float, dep: pr.Dependency
    ) -> None:
        l1, l2 = self.get_name([l1, l2])
        return super().add_eq2(l1, l2, m, n, dep)

    def add_eqratio(
            self,
            l1: gm.Length,
            l2: gm.Length,
            l3: gm.Length,
            l4: gm.Length,
            dep: pr.Dependency,
    ) -> None:
        l1, l2, l3, l4 = self.get_name([l1, l2, l3, l4])
        return self.add_eq4(l1, l2, l3, l4, dep)

    def get_all_eqs_and_why(self) -> Generator[Any, None, None]:
        return super().get_all_eqs_and_why(True)


class AngleTable(GeometricTable):
    """"""Coefficient matrix A for slope(direction).""""""

    def __init__(self, name: str = ''):
        name = name or 'pi'
        super().__init__(name)
        self.pi = self.const

    def modulo(self, e: dict[str, float]) -> dict[str, float]:
        e = strip(e)
        if self.pi not in e:
            return super().modulo(e)

        e[self.pi] = e[self.pi] % 1
        return strip(e)

    def add_para(
            self, d1: gm.Direction, d2: gm.Direction, dep: pr.Dependency
    ) -> None:
        return self.add_const_angle(d1, d2, 0, dep)

    def add_const_angle(
            self, d1: gm.Direction, d2: gm.Direction, ang: float, dep: pr.Dependency
    ) -> None:
        if ang and d2._obj.num > d1._obj.num:  # pylint: disable=protected-access
            d1, d2 = d2, d1
            ang = 180 - ang

        d1, d2 = self.get_name([d1, d2])

        num, den = simplify(ang, 180)
        ang = frac(int(num), int(den))
        return super().add_eq3(d1, d2, ang, dep)

    def add_eqangle(
            self,
            d1: gm.Direction,
            d2: gm.Direction,
            d3: gm.Direction,
            d4: gm.Direction,
            dep: pr.Dependency,
    ) -> None:
        """"""Add the inequality d1-d2=d3-d4.""""""
        # Use string as variables.
        l1, l2, l3, l4 = [d._obj.num for d in [d1, d2, d3, d4]]  # pylint: disable=protected-access
        d1, d2, d3, d4 = self.get_name([d1, d2, d3, d4])
        ang1 = {d1: 1, d2: -1}
        ang2 = {d3: 1, d4: -1}

        if l2 > l1:
            ang1 = plus({self.pi: 1}, ang1)
        if l4 > l3:
            ang2 = plus({self.pi: 1}, ang2)

        ang12 = minus(ang1, ang2)
        self.record_eq(d1, d2, d3, d4)
        self.record_eq(d1, d3, d2, d4)

        expr = list(ang12.items())
        if not self.add_expr(expr):
            return []

        self.register(expr, dep)

    def get_all_eqs_and_why(self) -> Generator[Any, None, None]:
        return super().get_all_eqs_and_why(True)


class DistanceTable(GeometricTable):
    """"""Coefficient matrix A for position(point, line).""""""

    def __init__(self, name: str = ''):
        name = name or '1:1'
        self.merged = {}
        self.ratios = set()
        super().__init__(name)

    def pairs(self) -> Generator[tuple[str, str], None, None]:
        l2vs = defaultdict(list)
        for v in list(self.v2e.keys()):  # pylint: disable=g-builtin-op
            if v == self.const:
                continue
            l, p = v.split(':')
            l2vs[l].append(p)

        for l, ps in l2vs.items():
            for p1, p2 in perm2(ps):
                yield l + ':' + p1, l + ':' + p2

    def name(self, l: gm.Line, p: gm.Point) -> str:
        v = l.name + ':' + p.name
        self.v2obj[v] = (l, p)
        return v

    def map2obj(self, names: list[str]) -> list[gm.Point]:
        return [self.v2obj[n][1] for n in names]

    def add_cong(
            self,
            l12: gm.Line,
            l34: gm.Line,
            p1: gm.Point,
            p2: gm.Point,
            p3: gm.Point,
            p4: gm.Point,
            dep: pr.Dependency,
    ) -> None:
        """"""Add that distance between p1 and p2 (on l12) == p3 and p4 (on l34).""""""
        if p2.num > p1.num:
            p1, p2 = p2, p1
        if p4.num > p3.num:
            p3, p4 = p4, p3

        p1 = self.name(l12, p1)
        p2 = self.name(l12, p2)
        p3 = self.name(l34, p3)
        p4 = self.name(l34, p4)
        return super().add_eq4(p1, p2, p3, p4, dep)

    def get_all_eqs_and_why(self) -> Generator[Any, None, None]:
        for x in super().get_all_eqs_and_why(True):
            yield x

        # Now we figure out all the const ratios.
        h2pairs = defaultdict(list)
        for v1, v2 in self.pairs():
            if (v1, v2) in self.merged:
                continue
            e1, e2 = self.v2e[v1], self.v2e[v2]
            e12 = minus(e1, e2)
            h12 = hashed(e12)
            h2pairs[h12].append((v1, v2, e12))

        for (_, vves1), (_, vves2) in perm2(list(h2pairs.items())):
            v1, v2, e12 = vves1[0]
            for v1_, v2_, _ in vves1[1:]:
                self.merged[(v1_, v2_)] = (v1, v2)

            v3, v4, e34 = vves2[0]
            for v3_, v4_, _ in vves2[1:]:
                self.merged[(v3_, v4_)] = (v3, v4)

            if (v1, v2, v3, v4) in self.ratios:
                continue

            d12 = div(e12, e34)
            if d12 is None or d12 > 1 or d12 < 0:
                continue

            self.ratios.add((v1, v2, v3, v4))
            self.ratios.add((v2, v1, v4, v3))

            n, d = d12.numerator, d12.denominator

            # (v1 - v2) * d = (v3 - v4) * n
            why_dict = minus(
                minus({v1: d, v2: -d}, {v3: n, v4: -n}),
                minus(mult(e12, d), mult(e34, n)),  # there is no modulo, so this is 0
            )

            v1, v2, v3, v4 = self.map2obj([v1, v2, v3, v4])
            yield v1, v2, v3, v4, abs(n), abs(d), self.why(why_dict)



","# Run this to enable CSS types
from IPython.core.display import HTML
def css_styling():
    styles = open(""/kaggle/input/my-css-styles/kaggle_styles.css"", ""r"").read()
    return HTML(""<style>""+styles+""</style>"")
css_styling()
print(""\n... PACKAGE INSTALLS STARTING ...\n"")

# Imports Required for Installs
import os
import sys

# Define directory paths for installs
AG_REPO_DIR = ""/kaggle/input/alphageometry-github-repo/alphageometry""
AG_DATA_DIR=""/kaggle/working/ag_ckpt_vocab""
MELIAD_DIR=""/kaggle/working/meliad_lib/meliad""
sys.path.insert(0, AG_REPO_DIR)

# Define common hyperparameters for usage
DDAR_ARGS={
    ""defs_file"": os.path.join(AG_REPO_DIR, ""defs.txt""),
    ""rules_file"": os.path.join(AG_REPO_DIR, ""rules.txt"")
}
BATCH_SIZE=2
BEAM_SIZE=2
DEPTH=2
SEQ_LENGTH=128

LM_ARGS = {
    ""ckpt_path"": AG_DATA_DIR,
    ""vocab_path"": os.path.join(AG_DATA_DIR, ""geometry.757.model""),
    ""gin_search_paths"": os.path.join(MELIAD_DIR, ""transformer/configs""),
    ""gin_files"": [
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""base_htrans.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""size/medium_150M.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""options/positions_t5.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""options/lr_cosine_decay.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""options/seq_1024_nocache.gin""),
        os.path.join(MELIAD_DIR, ""transformer/configs"", ""geometry_150M_generate.gin"")
    ],
    ""gin_params"": {
        ""DecoderOnlyLanguageModelGenerate.output_token_losses"": True,
        ""TransformerTaskConfig.batch_size"": BATCH_SIZE,
        ""TransformerTaskConfig.sequence_length"": SEQ_LENGTH,
        ""Trainer.restore_state_variables"": False
    }
}

# Do the installs
!pip install -q -r {os.path.join(AG_REPO_DIR, ""requirements.in"")}
!pip install -q --upgrade gdown==4.7.3

if not os.path.isdir(AG_DATA_DIR):
    !gdown -q --folder https://bit.ly/alphageometry

if not os.path.isdir(MELIAD_DIR):
    os.makedirs(MELIAD_DIR, exist_ok=True)
    !git clone -q https://github.com/google-research/meliad {MELIAD_DIR}
    !export PYTHONPATH=$PYTHONPATH:/kaggle/working/meliad_lib/meliad
print(""\n... PIP INSTALLS COMPLETE ...\n"")

print(""\n... IMPORTS STARTING ...\n"")
print(""\n\tVERSION INFORMATION"")
# Machine Learning and Data Science Imports (basics)
import tensorflow as tf; print(f""\t\t– TENSORFLOW VERSION: {tf.__version__}"");
import pandas as pd; pd.options.mode.chained_assignment = None; pd.set_option('display.max_columns', None);
import numpy as np; print(f""\t\t– NUMPY VERSION: {np.__version__}"");
import sklearn; print(f""\t\t– SKLEARN VERSION: {sklearn.__version__}"");

# Built-In Imports (mostly don't worry about these)
from kaggle_datasets import KaggleDatasets
from collections import Counter
from datetime import datetime
from zipfile import ZipFile
from glob import glob
import Levenshtein
import subprocess
import warnings
import requests
import hashlib
import imageio
import IPython
import sklearn
import urllib
import zipfile
import pickle
import random
import shutil
import string
import json
import math
import time
import gzip
import ast
import sys
import io
import os
import gc
import re

# Visualization Imports (overkill)
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
from matplotlib.patches import Rectangle
import matplotlib.patches as patches
import plotly.graph_objects as go
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm; tqdm.pandas();
import plotly.express as px
import tifffile as tif
import seaborn as sns
from PIL import Image, ImageEnhance; Image.MAX_IMAGE_PIXELS = 5_000_000_000;
import matplotlib; print(f""\t\t– MATPLOTLIB VERSION: {matplotlib.__version__}"");
import plotly
import PIL
import cv2

import plotly.io as pio
print(pio.renderers)

def check_nvidia_gpu():
    try:
        subprocess.check_output('nvidia-smi')
        print('\n... NVIDIA GPU DETECTED ...\n')
        return True
    except Exception: # this command not being found can raise quite a few different errors depending on the configuration
        print('\n... NO NVIDIA GPU DETECTED ...\n')
        return False

def seed_it_all(seed=7):
    """""" Attempt to be Reproducible """"""
    os.environ['PYTHONHASHSEED'] = str(seed)
    random.seed(seed)
    np.random.seed(seed)
    tf.random.set_seed(seed)

seed_it_all()
print(f""ARE WE USING NVIDIA-GPU?\n\t--> {check_nvidia_gpu()}"")
print(""\n\n... IMPORTS COMPLETE ...\n"")
# Copyright 2023 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

""""""Implements geometric objects used in the graph representation.""""""
from __future__ import annotations

from collections import defaultdict  # pylint: disable=g-importing-member
from typing import Any, Type
class Node:
    """"""
    Represents a node in a proof state graph, which can be a Point, Line, Circle, etc.
    
    This class handles the complexities of graph-based relationships, including merging histories,
    equivalence relationships, and connections to other nodes.

    Attributes:
        name (str): The name of the node. Defaults to the object's string representation if empty.
        graph (Any): A reference to the graph that this node is a part of.
        edge_graph (dict): A dictionary representing connections to other nodes.
        merge_graph (dict): A dictionary maintaining the history of merges with other nodes.
        rep_by (Node or None): The node that this node is currently represented by, if any.
        members (set): A set of nodes that are members of the equivalence class this node belongs to.
        _val (Node or None): A private attribute for value-type relationships.
        _obj (Node or None): A private attribute for object-type relationships.
        deps (list): A list of dependencies.
        num (numeric or None): A numerical representation of the node, used for indexing or sorting.
        change (set): A set of nodes whose numerical representation depends on this node.
    
    Example Usage:
        >>> point = Node(name=""PointA"")
        >>> line = Node(name=""LineB"")
        >>> point.connect_to(line, deps=[""dependency1""])
    """"""

    def __init__(self, name: str = '', graph: Any = None):
        """"""
        Initialize a new Node instance.
        
        Args:
            name (str): The name of the node. If not provided, defaults to the object's string representation.
            graph (Any): The graph to which this node belongs. Can be any type.
        """"""
        self.name = name or str(self)  # Use the provided name or default to the object's string representation.
        self.graph = graph  # The graph this node is part of. Could be any structure or type.

        # Edge graph: Tracks what other nodes this node is connected to.
        # Structure: 
        #      edge_graph = {
        #          other_node1: {
        #              this_node1: deps, 
        #              this_node2: deps
        #          }, 
        #          other_node2: {
        #              this_node2: deps, 
        #              ...
        #          }
        #      }
        self.edge_graph = {}

        # Merge graph: Keeps the history of merges with other nodes.
        # Structure: 
        #    merge_graph = {
        #        this_node1: {
        #            merged_node1: deps1, 
        #            merged_node2: deps2
        #        }, 
        #        ...
        #    }
        self.merge_graph = {}

        self.rep_by = None  # The node that this node is represented by, if any.
        self.members = {self}  # Starts as a set containing only this node, representing its equivalence class.

        self._val = None  # Private attribute for storing a value-type relationship (like length or angle).
        self._obj = None  # Private attribute for storing an object-type relationship.

        self.deps = []  # A list to track dependencies.

        # Numerical representation, possibly for indexing or sorting purposes within the graph.
        self.num = None

        # Set of nodes whose numerical representation ('num') is influenced by this node.
        self.change = set()

    def set_rep(self, node: 'Node') -> None:
        """"""
        Set another node as the representative of this node.

        This method is used when two nodes are determined to be equivalent, and one needs to act as the representative.

        Args:
            node (Node): The node to set as the representative.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.set_rep(node2)  # Node2 now represents Node1

        Raises:
            ValueError: If the provided node is the same as the current node.
        """"""
        if node == self:
            raise ValueError(""A node cannot represent itself."")
        
        # Set the representative node.
        self.rep_by = node

        # Merge the edge graph of the current node with the representative node.
        #   - This means combining their connections.
        node.merge_edge_graph(self.edge_graph)

        # Update the representative's members set to include members of this node.
        #   - This reflects that they are now part of the same equivalence class.
        node.members.update(self.members)

    def rep(self) -> 'Node':
        """"""
        Get the representative node of this node.

        If this node is part of an equivalence class (i.e., it has been merged with other nodes),
        this method will return the node that represents this equivalence class.

        Returns:
            Node: The representative node.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> rep_node = node.rep()  # Get the representative of 'node'

        """"""
        x = self
        # Traverse up the chain of representatives.
        #   - This is akin to finding the ""root"" or the primary representative in the equivalence class.
        while x.rep_by:
            x = x.rep_by
        return x

    def why_rep(self) -> list[Any]:
        """"""
        Explains the reason(s) why this node is represented by its current representative.

        This method utilizes the 'why_equal' method to trace back the series of merges or 
        equivalences that led to the current representation of this node.

        Returns:
            list[Any]: A list of reasons (dependencies) explaining the representative relationship.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.set_rep(node2)
            >>> node1.why_rep()  # Explains why node1 is represented by node2
        """"""
        # The method leverages the 'why_equal' function, passing the current representative node.
        return self.why_equal([self.rep()], None)
    
    def rep_and_why(self) -> tuple[Node, list[Any]]:
        """"""
        Retrieves the representative of this node and the reasons for its representation.

        This method combines the functionality of 'rep' and 'why_rep' to provide both the representative
        node and the reasons behind this representation in a single call.

        Returns:
            tuple[Node, list[Any]]: A tuple containing the representative node and a list of reasons for the representation.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> rep, reasons = node.rep_and_why()  # Get the representative and the reasons
        """"""
        # First, find the representative node of this node.
        rep = self.rep()
        
        # Then, get the reasons why this node is represented by the rep node.
        #   - This is done by tracing back the equivalence or merging history.
        return rep, self.why_equal([rep], None)

    def neighbors(self, oftype: Type[Node], return_set: bool = False, do_rep: bool = True) -> list[Node]:
        """"""
        Retrieves a list of neighboring nodes of a specific type.

        This method can return either direct neighbors or representatives of those neighbors, 
        depending on the 'do_rep' flag.

        Args:
            oftype (Type[Node]): The type of neighboring nodes to retrieve.
            return_set (bool): If True, returns a set instead of a list. Defaults to False.
            do_rep (bool): If True, returns representatives of the neighbors. Defaults to True.

        Returns:
            list[Node]: A list (or set, if return_set is True) of neighboring nodes or their representatives.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> neighbors = node.neighbors(Node, return_set=False, do_rep=True)
        """"""
        
        # Initialize the set of neighboring nodes (or their representatives)
        result = set()
        
        # Determine whether to use the representative of this node or the node itself.
        rep = self.rep() if do_rep else self

        # Iterate through each neighbor in the edge graph of the representative (or this node).
        for n in rep.edge_graph:
            # Check if the neighbor matches the specified type, if type is given.
            if oftype is None or isinstance(n, oftype):
                # Add either the representative of the neighbor or the neighbor itself to the result.
                result.add(n.rep() if do_rep else n)

        # Return the result as a set if specified, otherwise as a list.
        return result if return_set else list(result)

    def merge_edge_graph(self, new_edge_graph: dict[Node, dict[Node, list[Node]]]) -> None:
        """"""
        Merges a new edge graph into this node's existing edge graph.

        This method is essential for combining the connections (edges) of two nodes 
        when they are merged, ensuring that the merged node maintains all existing connections.

        Args:
            new_edge_graph (dict): The edge graph to be merged with this node's edge graph.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.merge_edge_graph(node2.edge_graph)
        """"""
        for x, xdict in new_edge_graph.items():
            # Iterate through each node and its associated dictionary in the new edge graph.
            if x in self.edge_graph:
                # If this node already exists in our edge graph, update its dependencies.
                self.edge_graph[x].update(dict(xdict))
            else:
                # If this node is new to our edge graph, add it along with its dependencies.
                self.edge_graph[x] = dict(xdict)
                
    def merge(self, nodes: list[Node], deps: list[Any]) -> None:
        """"""
        Merges a list of nodes into this node, updating the merge graph.

        Each node in the list will be merged with this node, and the dependencies
        for each merge will be recorded.

        Args:
            nodes (list[Node]): The nodes to merge with this node.
            deps (list[Any]): The dependencies associated with each merge.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node3 = Node(name=""Node3"")
            >>> node1.merge([node2, node3], deps=[""dep1"", ""dep2""])
        """"""
        # Merge each node in the list with this node ... one by one
        for node in nodes:
            self.merge_one(node, deps)

    def merge_one(self, node: Node, deps: list[Any]) -> None:
        """"""
        Merges a single node into this node, updating the merge graph.

        This method is used for merging one node at a time, setting this node as the representative
        for the merged node and recording the dependencies for the merge.

        Args:
            node (Node): The node to be merged with this node.
            deps (list[Any]): The dependencies associated with the merge.
        
        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.merge_one(node2, deps=[""dep1""])
        """"""
        # Update the representative of the node to be this node's representative.
        node_rep = node.rep()
        node_rep.set_rep(self.rep())

        if node in self.merge_graph:
            # If the node is already merged, no further action is required.
            return

        # Update the merge graph for both nodes to reflect the new dependencies.
        #   - The node we are bringing in and the node we represent (self)
        self.merge_graph[node] = deps
        node.merge_graph[self] = deps
        
    def is_val(self, node: Node) -> bool:
        """"""
        Checks if the relationship between this node and another node is of a specific value type.

        This method is used to determine if there's a specific value-type relationship between 
        two nodes. Some examples of this are:
            - a `Line` (self) and a `Direction` (node)
            - a `Segment` (self) and a `Length` (node)
            - an `Angle` (self) and a `Measure` (node)
            - a `Ratio` (self) and a `Value` (node)

        Args:
            node (Node): The other node to check the relationship with.

        Returns:
            bool: True if there is a value-type relationship, False otherwise.

        Example Usage:
            >>> line = Node(name=""Line"")
            >>> direction = Node(name=""Direction"")
            >>> line.is_val(direction)  # Returns True if 'direction' is a value-type for 'line'
        """"""
        # The following checks are specific to the types of nodes and their value relationships.
        #   - This is typically used in geometric or other domain-specific contexts.
        #   - If none of the following relationships are matched than we return False.
        return (
            # Is this node a Line and is the other node a Direction
            (isinstance(self, Line) and isinstance(node, Direction)) or
            
            # Is this node a Segment and the other node is a Length
            (isinstance(self, Segment) and isinstance(node, Length)) or
            
            # Is this node an Angle and the other node is a Measure
            (isinstance(self, Angle) and isinstance(node, Measure)) or
            
            # Is this node a Ratio and the other node is a Value
            (isinstance(self, Ratio) and isinstance(node, Value))
        )

    def set_val(self, node: Node) -> None:
        """"""
        Sets a node as the value-type relationship of this node.

        This method is used when you want to associate a value-type relationship with this node,
        like associating a Length (value not the object) with a Segment.

        Args:
            node (Node): The node to set as the value-type relationship.

        Example Usage:
            >>> segment = Node(name=""Segment"")
            >>> length = Node(name=""Length"")
            >>> segment.set_val(length)  # Sets 'length' as the value for 'segment'
        """"""
        self._val = node  # Set the provided node as the value-type relationship.

    def set_obj(self, node: Node) -> None:
        """"""
        Sets a node as the object-type relationship of this node.

        This method is similar to 'set_val' but is used for setting object-type relationships.
        For example, associating a Segment with a Length.

        Args:
            node (Node): The node to set as the object-type relationship.

        Example Usage:
            >>> length = Node(name=""Length"")
            >>> segment = Node(name=""Segment"")
            >>> length.set_obj(segment)  # Sets 'segment' as the object for 'length'
        """"""
        self._obj = node  # Set the provided node as the object-type relationship.

    # Properties are defined to give easy access to the value and object relationships.
    @property
    def val(self) -> Node:
        """"""
        A property to get the node representing the value-type relationship of this node.

        Returns the representative of the value-type node if it exists, otherwise None.

        Returns:
            Node or None: The representative of the value-type relationship node.

        Example usage:
            >>> segment = Node(name=""Segment"")
            >>> length = Node(name=""Length"")
            >>> segment.set_val(length)
            >>> segment.val  # Returns the representative of 'length'
        """"""
        return self._val.rep() if self._val else None

    @property
    def obj(self) -> Node:
        """"""
        A property to get the node representing the object-type relationship of this node.

        Returns the representative of the object-type node if it exists, otherwise None.

        Returns:
            Node or None: The representative of the object-type relationship node.

        Example Usage:
            >>> length = Node(name=""Length"")
            >>> segment = Node(name=""Segment"")
            >>> length.set_obj(segment)
            >>> length.obj  # Returns the representative of 'segment'
        """"""
        return self._obj.rep() if self._obj else None
    
    def equivs(self) -> set[Node]:
        """"""
        Retrieves all nodes that are equivalent to this node.

        This method returns all the members of the equivalence class that this node belongs to, 
        including itself.

        Returns:
            set[Node]: A set of nodes that are equivalent to this node.

        Example usage:
            >>> node = Node(name=""Node"")
            >>> equivalent_nodes = node.equivs()
        """"""
        # Retrieve the representative of this node and return all its members.
        #   - This will represent the equivalence class of this node.
        return self.rep().members

    def connect_to(self, node: Node, deps: list[Any] = None) -> None:
        """"""
        Connects this node to another node, updating the edge graph.

        This method is used to establish a connection or relationship between this node and another,
        optionally with a list of dependencies that describe the nature of the connection.

        Args:
            node (Node): The node to connect to.
            deps (list[Any], optional): The dependencies associated with the connection.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.connect_to(node2, deps=[""dependency1""])
        """"""
        
        # Get the representative of this node.
        rep = self.rep()  

        if node in rep.edge_graph:
            # If there's already a connection to the node, update the dependencies.
            rep.edge_graph[node].update({self: deps})
        else:
            # If this is a new connection, add it to the edge graph with the dependencies.
            rep.edge_graph[node] = {self: deps}

        if self.is_val(node):
            # If there is a value-type relationship between this node and the other... set it accordingly.
            self.set_val(node)
            node.set_obj(self)

    def equivs_upto(self, level: int) -> dict[Node, Node]:
        """"""
        Retrieves the equivalent nodes up to a certain level of depth in the merge graph.

        This method is useful for understanding the depth of equivalence relationships between nodes. 
            - This mechanism is essential for understanding the node's equivalence relationships up to a certain depth
        
        Details:
            - A breadth-first search (BFS) approach is employed to traverse the merge_graph. 
            - The queue is used to process each node in a level-by-level manner. 
            - For each node, its neighbors (other nodes it's merged with) are examined. 
            - The traversal considers the 'level' of the merge relationship, allowing control over how deep the search goes in the graph. 

        Args:
            level (int): The level up to which equivalent nodes should be retrieved.

        Returns:
            dict[Node, Node]: A dictionary where keys are nodes and values are their parents in the merge graph up to the specified level.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> equivalents_up_to_level = node.equivs_upto(2)
        """"""
        parent = {self: None}  # Start with the current node as its own parent.
        visited = set()  # Keep track of visited nodes.
        queue = [self]  # Queue for BFS traversal.
        i = 0

        while i < len(queue):
            # Get the current node from the queue.
            current = queue[i]
            i += 1  # Increment the index for the next iteration.

            # Mark the current node as visited to avoid reprocessing it.
            visited.add(current)

            # Iterate through each neighbor connected to the current node in the merge graph.
            for neighbor in current.merge_graph:
                # Check if the level of the merge relationship is within the specified limit.
                # If the level is too high (i.e., exceeds the specified 'level'), skip this neighbor.
                if level is not None and current.merge_graph[neighbor].level is not None and current.merge_graph[neighbor].level >= level:
                    continue

                # If this neighbor hasn't been visited yet, add it to the queue for processing.
                if neighbor not in visited:
                    queue.append(neighbor)
                    # Record the parent (current node) of this neighbor. This is useful for backtracking.
                    parent[neighbor] = current

        return parent
    
    def why_equal(self, others: list[Node], level: int) -> list[Any]:
        """"""
        Explains why this node is considered equal to other nodes, up to a certain level.

        This method performs a breadth-first search (BFS) in the merge graph to find 
        the path to the specified nodes, considering the level of merges.

        Args:
            others (list[Node]): The nodes to compare with.
            level (int): The level up to which the search is performed.

        Returns:
            list[Any]: A list of reasons (dependencies) explaining why the nodes are considered equal.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> reasons = node1.why_equal([node2], level=2)
        """"""
        
        # Convert the list of other nodes to a set for efficient look-up.
        others = set(others)
        
        # Initialize the counter for the number of 'other' nodes found.
        found = 0  
        
        # Initialize the dictionary to keep track of each node's parent in the BFS tree.
        parent = {}
        
        # Initialize the BFS queue with the current node.
        queue = [self]  
        
        # Initialize the index for iterating over the queue.
        i = 0  
        
        # Iterate until the queue is exhausted
        while i < len(queue):
            current = queue[i]  # Get the current node from the queue.
            if current in others:
                # If the current node is one of the 'others', increment the found counter.
                found += 1
            if found == len(others):
                # If all 'other' nodes are found, break out of the loop.
                break
            i += 1  # Move to the next node in the queue.

            # Iterate over the neighbors of the current node in the merge graph.
            for neighbor in current.merge_graph:
                # Check if the merge level of the neighbor is within the specified limit.
                if level is not None and current.merge_graph[neighbor].level is not None and current.merge_graph[neighbor].level >= level:
                    continue  # Skip neighbors beyond the specified level.

                if neighbor not in parent:
                    # If the neighbor hasn't been visited yet, add it to the queue and record its parent.
                    queue.append(neighbor)
                    parent[neighbor] = current

        # Perform backtracking from the found nodes to the current node, 
        #   - This uses the parent dictionary to find the path and reasons for equality.
        return bfs_backtrack(self, others, parent)


    def why_equal_groups(self, groups: list[list[Node]], level: int) -> tuple[list[Any], list[Node]]:
        """"""
        Performs a breadth-first search (BFS) to determine why this node is equal to at least one member of each group.

        This method is useful for understanding complex equivalence relationships across multiple groups
        of nodes, particularly in scenarios where a node might be equivalent to different nodes in different contexts.

        Args:
            groups (list[list[Node]]): A list of groups, each containing multiple nodes.
            level (int): The level up to which the search is conducted in the merge graph.

        Returns:
            tuple[list[Any], list[Node]]: A tuple containing a list of reasons for equivalence and a list of equivalent nodes from each group.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> group1 = [Node(name=""Node1""), Node(name=""Node2"")]
            >>> group2 = [Node(name=""Node3""), Node(name=""Node4"")]
            >>> reasons, equivalents = node.why_equal_groups([group1, group2], level=2)
        """"""
        
        # Initialize a list to hold the found equivalent node in each group.
        others = [None for _ in groups]  
        
        # Initialize the counter for the number of groups where an equivalent node is found.
        found = 0  
        
        # Initialize the dictionary to track the parent of each node in the BFS tree.
        parent = {}  
        
        # Initialize the queue for BFS, starting with the current node.
        queue = [self]  
        
        # Initialize the index for iterating over the queue.
        i = 0
        
        # Iterate until the queue is exhausted
        while i < len(queue):
            current = queue[i]
            # Check each group for an equivalent node.
            for j, grp in enumerate(groups):
                if others[j] is None and current in grp:
                    others[j] = current  # Record the equivalent node found in this group.
                    found += 1  # Increment the counter for found groups.

            if found == len(others):  # If equivalents are found in all groups, stop the search.
                break

            i += 1

            # Process the neighbors of the current node in the merge graph.
            for neighbor in current.merge_graph:
                # Only consider neighbors within the specified level.
                if level is not None and current.merge_graph[neighbor].level is not None and current.merge_graph[neighbor].level >= level:
                    continue
                # Only consider neighbors not already contained within the parent
                if neighbor not in parent:
                    queue.append(neighbor)
                    parent[neighbor] = current

        # Backtrack from the found nodes to determine the path and reasons for equivalence.
        return bfs_backtrack(self, others, parent), others

    def why_val(self, level: int) -> list[Any]:
        """"""
        Explains why the value of this node is considered equal to its current value, up to a certain level.

        This method is useful for understanding the reasoning behind the value assignment of this node,
        especially in complex graphs where values are determined through a series of equivalences.

        Args:
            level (int): The level up to which the search for equivalence is performed.

        Returns:
            list[Any]: A list of reasons (dependencies) explaining the value equivalence.

        Example Usage:
            >>> node = Node(name=""Node"")
            >>> value_node = Node(name=""ValueNode"")
            >>> node.set_val(value_node)
            >>> reasons = node.why_val(level=2)
        """"""
        
        # If there are no values assigned we exit early and return None.
        if self._val is None:
            return None
        
        # Perform a BFS to find the reason why this node's value is equal to the representative of its value.
        return self._val.why_equal([self.val], level)


    def why_connect(self, node: Node, level: int = None) -> list[Any]:
        """"""
        Explains the reasons behind the connection between this node and another node, up to a certain level.

        This method is particularly useful in scenarios where the graph represents complex interdependencies,
        and understanding these connections is crucial.

        Args:
            node (Node): The node to which the connection is established.
            level (int, optional): The level up to which the search is conducted in the edge graph.

        Returns:
            list[Any]: A list of dependencies explaining the connection to the specified node.

        Example Usage:
            >>> node1 = Node(name=""Node1"")
            >>> node2 = Node(name=""Node2"")
            >>> node1.connect_to(node2, deps=[""dependency1""])
            >>> reasons = node1.why_connect(node2, level=2)
        """"""
        # Get the representative of this node.
        rep = self.rep()  # Get the representative of this node.
        
        # Get the list which contains all the nodes that are connected to the specified node vai the rep's edge_graph
        equivs = list(rep.edge_graph[node].keys())
        
        # Return None if there are no equivalent connections.
        if not equivs:
            return None  
        
        # Consider the first equivalent node for simplicity.
        equiv = equivs[0]  
        
        # Find the reasons/dependencies for the equivalence/connection between this node and the specified node.
        dep = rep.edge_graph[node][equiv]
        return [dep] + self.why_equal(equiv, level)
class Point(Node):
    """""" Inherits all behavior from Node without any modification. """"""
    pass


class Direction(Node):
    """"""Node of type Direction, representing a geometric direction.

    Inherits from Node and represents the concept of direction in geometry.
    """"""
    # No additional attributes or methods beyond those provided by Node.
    pass

class Measure(Node):
    """"""
    Node representing a geometric measure, such as the measure of an angle.

    This class extends the Node class, specializing in representing a geometric measure.
    It could represent various measurements like angles, lengths, etc.

    Example Usage:
        >>> measure1 = Measure()
    """"""
    # Inherits all behavior from Node without any modification.
    pass


class Length(Node):
    """"""
    Node representing a geometric length, such as the length of a segment.

    This class extends the Node class, specializing in representing lengths in geometry.

    Example Usage:
        >>> length1 = Length()
    """"""
    # Inherits all behavior from Node without any modification.
    pass


class Segment(Node):
    """"""Node of type Segment, representing a geometrical segment.

    Inherits from Node and adds specific functionality for segments in geometry.
    A segment is a part of a line that is bounded by two distinct end points.
    """"""

    def new_val(self) -> Length:
        """"""Creates a new Length instance.

        Overrides the `new_val` method in Node for segments, where the value
        associated with a segment is its length.

        Returns:
            Length: A new instance of the Length class.
        """"""
        return Length()

class Line(Node):
    """"""Node of type Line, representing a geometrical line.

    Inherits from Node and adds specific functionality for lines in geometry.
    A line is an infinitely long straight path with no thickness.
    
    NOTE: If it had a finite length it would be a 'Segment'
    """"""

    def new_val(self) -> Direction:
        """"""Creates a new Direction instance.

        This method overrides the `new_val` method in the Node class,
        providing a specific implementation for Line, where the value
        associated with a line is its direction.

        Returns:
            Direction: A new instance of the Direction class.
        """"""
        return Direction()

    def why_coll(self, points: list[Point], level: int = None) -> list[Any]:
        """"""Explains why a set of points are collinear with this line.

        This method is used to determine the reasons behind the collinearity of a set of points with this line.
        It checks at various levels of abstraction as defined by 'level'.

        Args:
            points (list[Point]): A list of Point instances to check for collinearity.
            level (int, optional): The level of abstraction for checking collinearity. Defaults to infinity.

        Returns:
            list[Any] or None: A list of reasons for collinearity, or None if no collinearity is found.
        """"""

        # Default level is infinity if not specified.
        level = level or float('inf')

        # Create a list to hold groups of lines connected to each point.
        groups = []

        for p in points:
            # Extract lines connected to point `p` with dependencies below the specified level.
            group = [l for l, d in self.edge_graph[p].items() if d is None or d.level < level]

            # If no group is formed, return None as collinearity cannot be established.
            if not group:
                return None

            groups.append(group)

        # Initialize a variable to hold the minimum set of dependencies that explain the collinearity.
        min_deps = None

        for line in groups[0]:
            # For each line, find equal groups and their dependencies.
            deps, others = line.why_equal_groups(groups[1:], level)
            if deps is None:
                continue  # Skip if no dependencies are found.

            # Add dependencies to the list for each point-line pair.
            for p, o in zip(points, [line] + others):
                deps.append(self.edge_graph[p][o])

            # Update min_deps if it's None or found dependencies are fewer.
            if min_deps is None or len(deps) < len(min_deps):
                min_deps = deps

        # If no minimal dependencies are found, return None. Otherwise, return the found dependencies.
        if min_deps is None:
            return None

        # Return the subset of deps (paths) that is not None
        return [d for d in min_deps if d is not None]


class Circle(Node):
    """"""Node of type Circle, representing a geometrical circle.

    Inherits from Node and adds specific functionality for circles in geometry.
    A circle is a set of points in a plane that are all at a given distance (the radius) from a fixed point (the center).
    """"""

    def why_cyclic(self, points: list[Point], level: int = None) -> list[Any]:
        """"""Explains why a set of points are cyclic with respect to this circle.

        Determines the reasons behind the cyclic nature (all points lie on the circumference)
        of a set of points with respect to this circle.

        Args:
            points (list[Point]): A list of Point instances to check for cyclic nature.
            level (int, optional): The level of abstraction for checking cyclic nature. Defaults to infinity.

        Returns:
            list[Any] or None: A list of reasons for cyclic nature, or None if it's not cyclic.
        """"""
        # Default level is infinity if not specified.
        level = level or float('inf')

        # Create a list to hold groups of circles connected to each point.
        groups = []

        for p in points:
            # Extract circles connected to point `p` with dependencies below the specified level.
            group = [c for c, d in self.edge_graph[p].items() if d is None or d.level < level]

            # If no group is formed, return None as the cyclic nature cannot be established.
            if not group:
                return None
            groups.append(group)

        # Initialize a variable to hold the minimum set of dependencies that explain the cyclic nature.
        min_deps = None

        for circle in groups[0]:
            # For each circle, find equal groups and their dependencies.
            deps, others = circle.why_equal_groups(groups[1:], level)
            if deps is None:
                continue  # Skip if no dependencies are found.

            # Add dependencies to the list for each point-circle pair.
            for p, o in zip(points, [circle] + others):
                deps.append(self.edge_graph[p][o])

            # Update min_deps if it's None or found dependencies are fewer.
            if min_deps is None or len(deps) < len(min_deps):
                min_deps = deps

        # If no minimal dependencies are found, return None. Otherwise, return the found dependencies.
        if min_deps is None:
            return None

        # Return the subset of deps (paths) that is not None
        return [d for d in min_deps if d is not None]


class Angle(Node):
    """"""Node of type Angle, representing a geometrical angle.

    Inherits from Node and adds specific functionality for angles in geometry.
    """"""

    def new_val(self) -> Measure:
        """"""Creates a new Measure instance.

        Overrides the `new_val` method in Node for angles, where the value
        associated with an angle is its measure.

        Returns:
            Measure: A new instance of the Measure class.
        """"""
        return Measure()

    def set_directions(self, d1: Direction, d2: Direction) -> None:
        """"""Sets the directions forming the angle.

        Args:
            d1 (Direction): The first direction of the angle.
            d2 (Direction): The second direction of the angle.
        """"""
        self._d = d1, d2  # Store the directions as a tuple.

    @property
    def directions(self) -> tuple[Direction, Direction]:
        """"""Gets the directions forming the angle.

        Returns:
            tuple[Direction, Direction]: A tuple containing the two directions of the angle.
        """"""

        # The two directions
        #   - d1 (Direction): The first direction of the angle.
        #   - d2 (Direction): The second direction of the angle.
        d1, d2 = self._d

        # If either direction is None, return them as is.
        #   - Otherwise, get their representative directions.
        return (d1, d2) if d1 is None or d2 is None else (d1.rep(), d2.rep())



class Ratio(Node):
    """"""
    Node of type Ratio, representing a ratio of lengths or other measures.

    Inherits from Node and adds specific functionality for representing ratios in geometry.

    Example Usage:
        >>> ratio = Ratio()
    """"""

    def new_val(self) -> Value:
        """"""
        Creates a new Value instance.

        Overrides the `new_val` method in Node for ratios, where the value associated with a ratio
        is a generic value.

        Returns:
            Value: A new instance of the Value class.
        """"""
        return Value()

    def set_lengths(self, l1: Length, l2: Length) -> None:
        """"""
        Sets the lengths involved in the ratio.

        Args:
            l1 (Length): The first length in the ratio.
            l2 (Length): The second length in the ratio.
        """"""
        self._l = l1, l2  # Store the lengths as a tuple.

    @property
    def lengths(self) -> tuple[Length, Length]:
        """"""
        Gets the lengths involved in the ratio.

        Returns:
            tuple[Length, Length]: A tuple containing the two lengths in the ratio.
        """"""
        # The lengths
        #   - l1 (Length): The first length in the ratio.
        #   - l2 (Length): The second length in the ratio.
        l1, l2 = self._l

        # If either length is None, return them as is.
        #   - Otherwise, get their representative lengths.
        return (l1, l2) if l1 is None or l2 is None else (l1.rep(), l2.rep())


class Value(Node):
    """"""
    Node representing a generic value, used in various contexts like ratios.

    This class extends the Node class, providing a way to encapsulate a generic value.

    Example Usage:
        >>> value = Value()
    """"""
    # Inherits all behavior from Node without any modification.
    pass


def why_connect(*pairs: list[tuple[Node, Node]]) -> list[Any]:
    """"""
    Finds reasons for connection between pairs of nodes.

    This function takes pairs of nodes and for each pair, it determines why they are connected in the graph.
    It leverages the `why_connect` method of the `Node` class.

    Args:
        pairs (list[tuple[Node, Node]]): A list of tuples, each containing two nodes for which the connection
        reason is to be found.

    Returns:
        list[Any]: A list containing the reasons for connection for each pair of nodes.

    Example Usage:
        >>> node1 = Node()
        >>> node2 = Node()
        >>> why_connect((node1, node2))
        [connection_reason]
    """"""
    # Initialize an empty list to store the results.
    result = []

    # Iterate over each pair of nodes provided as input.
    for node1, node2 in pairs:
        # For each pair, call the 'why_connect' method on the first node (node1)
        #   - pass the second node (arg) to find out the connection reason
        #   - Append the result of 'why_connect' to the 'result' list.
        result += node1.why_connect(node2)

    # After processing all pairs, return the list of connection reasons.
    return result


def is_equiv(x: Node, y: Node, level: int = None) -> bool:
    """"""
    Determines if two nodes are equivalent at a certain level of abstraction.

    The function checks if two nodes, x and y, are equivalent. The level of abstraction for checking
    equivalence can be specified. If no level is given, it defaults to infinity, meaning it checks at all levels.

    Args:
        x (Node): The first node.
        y (Node): The second node.
        level (int, optional): The level of abstraction for the equivalence check. Defaults to None.

    Returns:
        bool: True if the nodes are equivalent at the specified level, False otherwise.

    Example Usage:
        >>> point1 = Point()
        >>> point2 = Point()
        >>> is_equiv(point1, point2)
        False
    """"""
    # If the 'level' argument is None, set it to infinity.
    #   - This indicates the check should consider all levels of abstraction.
    level = level or float('inf')

    # Call the 'why_equal' method on node 'x' with node 'y' and 'level'.
    #   - The method returns None if they ARE NOT equivalent
    #   - The method returns a non-None value if they ARE equivalent.
    # We then check this result and convert it into a boolean value
    return x.why_equal([y], level) is not None


def is_equal(x: Node, y: Node, level: int = None) -> bool:
    """"""
    Checks if two nodes are equal based on their values and equivalence.

    This function compares two nodes for equality. It first checks if they are the same instance,
    then verifies if their values (`_val` attributes) are not None and finally checks if their values are equal.
    If the values are equal, it additionally checks for their equivalence using `is_equiv`.

    Args:
        x (Node): The first node.
        y (Node): The second node.
        level (int, optional): The level of abstraction for equivalence check. Defaults to None.

    Returns:
        bool: True if the nodes are equal, False otherwise.

    Example Usage:
        >>> nodeA = Node()
        >>> nodeB = Node()
        >>> is_equal(nodeA, nodeB)
        False
    """"""
    # First, check if the two nodes are exactly the same instance.
    #  - If so they are equivalent (trivial case)
    if x == y:
        return True

    # Check if either of the nodes has a None value for '_val'.
    #   - If so, the nodes cannot be considered equal, so return False.
    if x._val is None or y._val is None:
        return False

    # Compare the '_val' attributes of the nodes.
    #   - If they are different, the nodes are not equal, so return False.
    if x.val != y.val:
        return False

    # If the '_val' attributes are the same...
    # We have to further check if the nodes are equivalent using 'is_equiv'
    #   - This is a deeper check to see if they are considered equal
    #   - It operates at a specific level of abstraction ('level').
    return is_equiv(x._val, y._val, level)


def why_equal(x: Node, y: Node, level: int = None) -> list[Any]:
    """"""
    Determines the reasons for the equality of two nodes at a specified level of abstraction.

    This function is crucial for understanding why two nodes in the graph are considered equal.
    It checks for direct equality, and if not directly equal, it checks the equality of their values.

    Args:
        x (Node): The first node to compare.
        y (Node): The second node to compare.
        level (int, optional): The level of abstraction for checking equality. Defaults to None (all levels).

    Returns:
        list[Any] or None: A list of reasons for equality if they are equal; None otherwise.

    Example Usage:
        >>> node1 = Node()
        >>> node2 = Node()
        >>> why_equal(node1, node2)
        None  # or [reasons] if they are equal
    """"""

    # First, check if the two nodes are exactly the same instance.
    #  - If so they are equivalent (trivial case)
    if x == y:
        return []

    # Check if either node has a Falsey value
    #   - If so, the nodes cannot be considered equal, so return None.
    if not x._val or not y._val:
        return None

    # Check if the values of the nodes are the same
    #  - If so, they are equivalent.
    if x._val == y._val:
        return []

    # If values are not the same, check for equality at a deeper level using 'why_equal'.
    return x._val.why_equal([y._val], level)


def val_type(x: Node) -> Type[Node]:
    """"""
    Determines the type of value associated with a given node.

    This function helps to find out what kind of value a node represents, such as direction, length, etc.

    Args:
        x (Node): The node whose value type is to be determined.

    Returns:
        Type[Node]: The type of value associated with the node.

    Example Usage:
        >>> node = Line()
        >>> val_type(node)
        <class 'Direction'>
    """"""

    # Determine the value type based on the node's class.
    # The function can be extended to include other node types and their associated value types.

    if isinstance(x, Line):
        # If 'x' is an instance of the Line class, return the Direction class.
        # This indicates that for a Line node, the associated value type is Direction.
        return Direction

    if isinstance(x, Segment):
        # If 'x' is an instance of the Segment class, return the Length class.
        # This indicates that for a Segment node, the associated value type is Length.
        return Length

    if isinstance(x, Angle):
        # If 'x' is an instance of the Angle class, return the Measure class.
        # This indicates that for an Angle node, the associated value type is Measure.
        return Measure

    if isinstance(x, Ratio):
        # If 'x' is an instance of the Ratio class, return the Value class.
        # This indicates that for a Ratio node, the associated value type is Value.
        return Value
    
    
def name_map(struct: Any) -> Any:
    """"""
    Recursively maps a data structure of nodes to their names.

    This utility function is useful for converting complex structures containing nodes
    into a more readable format by using the names of the nodes.

    Args:
        struct (Any): A data structure (like list, tuple, set, dict) containing nodes.

    Returns:
        Any: A similar structure where nodes are replaced with their names.

    Example Usage:
        >>> my_structure = [Node(name=""A""), Node(name=""B"")]
        >>> name_map(my_structure)
        [""A"", ""B""]
    """"""

    # Handle different types of data structures recursively.
    if isinstance(struct, list):
        # If 'struct' is a list, apply 'name_map' to each element in the list.
        # This creates a new list
        #   - Each element is the result of applying 'name_map' to the original elements.
        return [name_map(x) for x in struct]

    elif isinstance(struct, tuple):
        # If 'struct' is a tuple, apply 'name_map' to each element in the tuple.
        # This creates a new tuple
        #   - Each element is the result of applying 'name_map' to the original elements.
        return tuple([name_map(x) for x in struct])

    elif isinstance(struct, set):
        # If 'struct' is a set, apply 'name_map' to each element in the set.
        # This creates a new set
        #   - Each element is the result of applying 'name_map' to the original elements.
        return set([name_map(x) for x in struct])

    elif isinstance(struct, dict):
        # If 'struct' is a dictionary, apply 'name_map' to both keys and values.
        # This creates a new dictionary
        #   - Each key-value pair is the result of applying 'name_map' to the original pairs.
        return {name_map(key): name_map(value) for key, value in struct.items()}

    else:
        # If 'struct' is not a list, tuple, set, or dictionary, it's assumed to be a single node.
        #   - We then Use 'getattr' to get the 'name' attribute of the node.
        #     - If the node does not have a 'name', return an empty string.
        #     - Otherwise we return the respective name from the 'name' attribute
        return getattr(struct, 'name', '')


def bfs_backtrack(
        root: Node, leafs: list[Node], parent: dict[Node, Node]
) -> list[Any]:
    """"""
    Backtracks from leaf nodes to the root node in a BFS traversal.

    Given a root node, a list of leaf nodes, and a parent mapping (as typically generated by a BFS traversal),
    this function reconstructs the path from each leaf node back to the root node. It stops backtracking
    when it reaches the root node or any node that has already been backtracked.

    Args:
        root (Node): The root node of the BFS traversal.
        leafs (list[Node]): A list of leaf nodes to backtrack from.
        parent (dict[Node, Node]): A dictionary mapping each node to its parent in the BFS traversal.

    Returns:
        list[Any]: A list containing the paths (in terms of edges) backtracked from the leafs to the root.

    Raises:
        None: This function does not explicitly raise any exceptions, but may implicitly raise if
              there are inconsistencies in the input data.

    Example Usage:
        >>> root_node = Node()
        >>> leaf_nodes = [Node(), Node()]
        >>> parent_map = {leaf_nodes[0]: root_node, leaf_nodes[1]: root_node}
        >>> bfs_backtrack(root_node, leaf_nodes, parent_map)
        [path1, path2]
    """"""
    # Create a set 'backtracked' and add the 'root' node to it.
    #   - This set will keep track of visited nodes during backtracking.
    backtracked = {root}

    # Initialize a list to store the dependencies (paths) found during backtracking.
    deps = []

    # Iterate over each node in the 'leafs' list.
    for node in leafs:
        # If a leaf node is None, this is an invalid case, so return None.
        if node is None:
            return None

        # If the current node is already in the 'backtracked' set, skip to the next node.
        if node in backtracked:
            continue

        # If the current node does not have a parent in the 'parent' dictionary...
        #   - This means there's a missing link in the path, so return None.
        if node not in parent:
            return None

        # Continue backtracking until break condition
        #   - This condition is that a node is already in the 'backtracked' set
        while node not in backtracked:
            # Add the current node to the 'backtracked' set to mark it as visited.
            backtracked.add(node)

            # Append the dependency (edge) between the current node and its parent to the 'deps' list.
            deps.append(node.merge_graph[parent[node]])

            # Move to the parent of the current node for the next iteration.
            node = parent[node]

    # After processing all leaf nodes, return the list of dependencies (paths) found.
    return deps


def get_lines_thru_all(*points: list[Point]) -> list[Line]:
    """"""
    Retrieves all lines that pass through a given set of points.

    This function is used to find all Line nodes in the graph that are connected to all
    the given Point nodes. It's a way to discover common lines shared by multiple points.

    Args:
        points (list[Point]): Variable number of Point instances.

    Returns:
        list[Line]: A list of Line instances that pass through all the given points.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> lines = get_lines_thru_all(point1, point2, point3)
    """"""

    # Default dictionary to count lines through each point.
    #   - A default dict is one that when initialized assumes the value as defined (0 in this case)
    line2count = defaultdict(lambda: 0)

    # Get the set of all unique points
    points = set(points)

    # Iterate over each point (unique) and count the lines connected to each point.
    for p in points:
        for l in p.neighbors(Line):
            line2count[l] += 1

    # Return the lines that are connected to all points.
    return [l for l, count in line2count.items() if count == len(points)]


def line_of_and_why(points: list[Point], level: int = None) -> tuple[Line, list[Any]]:
    """"""
    Determines the line on which given points are collinear and explains why.

    This function tries to find a Line node that all the given Point nodes are collinear with.
    Additionally, it provides the reasons for their collinearity.

    Args:
        points (list[Point]): A list of Point instances.
        level (int, optional): The level of abstraction for checking collinearity. Defaults to None.

    Returns:
        tuple[Line, list[Any]]: A tuple containing the Line instance and a list of reasons for collinearity,
        or (None, None) if no such line exists.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> line, reasons = line_of_and_why([point1, point2, point3])
    """"""
    # Find all lines that pass through all given points.
    for l0 in get_lines_thru_all(*points):

        # Check equivalent lines for collinearity.
        for l in l0.equivs():

            # Confirm all points are in the edge graph of the line.
            if all([p in l.edge_graph for p in points]):

                # Extract end points of the line and combine with the given points.
                x, y = l.points
                colls = list({x, y} | set(points))

                # Determine the reasons for collinearity.
                why = l.why_coll(colls, level)

                # If there is a valid reason then we return the line and the reason
                if why is not None:
                    return l, why

    # Return None if no line and reasons are found.
    return None, None


def get_circles_thru_all(*points: list[Point]) -> list[Circle]:
    """"""
    Retrieves all circles that pass through a given set of points.

    This function finds all Circle nodes in the graph that are connected to all the given Point nodes.
    It's used to identify common circles that encompass multiple points.

    Args:
        points (list[Point]): A variable number of Point instances.

    Returns:
        list[Circle]: A list of Circle instances that pass through all the given points.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> circles = get_circles_thru_all(point1, point2, point3)
    """"""

    # Initialize a dictionary to count the number of circles passing through each point.
    circle2count = defaultdict(lambda: 0)

    # Convert to set to ensure uniqueness of each point
    points = set(points)

    # Iterate through each point.
    for p in points:
        # For each circle connected to the point, increment its count.
        for c in p.neighbors(Circle):
            circle2count[c] += 1

    # Return circles that pass through all points.
    return [c for c, count in circle2count.items() if count == len(points)]


def circle_of_and_why(points: list[Point], level: int = None) -> tuple[Circle, list[Any]]:
    """"""
    Determines the circle on which given points are concyclic and explains why.

    This function finds a Circle node that encompasses all the given Point nodes and provides
    reasons for their concyclicity (all points lying on the circumference of the circle).

    Args:
        points (list[Point]): A list of Point instances.
        level (int, optional): The level of abstraction for checking concyclicity. Defaults to None.

    Returns:
        tuple[Circle, list[Any]]: A tuple containing the Circle instance and a list of reasons for concyclicity,
        or (None, None) if no such circle exists.

    Example Usage:
        >>> point1, point2, point3 = Point(), Point(), Point()
        >>> circle, reasons = circle_of_and_why([point1, point2, point3])
    """"""

    # Find all circles that pass through all given points.
    for c0 in get_circles_thru_all(*points):

        # Check equivalent circles for concyclicity.
        for c in c0.equivs():

            # Ensure all points are in the edge graph of the circle.
            if all([p in c.edge_graph for p in points]):

                # Create a list of unique points.
                cycls = list(set(points))

                # Determine the reasons for concyclicity.
                why = c.why_cyclic(cycls, level)

                # If a valid reason is found then we return the circle and reason
                if why is not None:
                    return c, why

    # Return None if no circle and reasons are found.
    return None, None


def all_angles(d1: Direction, d2: Direction, level: int = None) -> tuple[Angle, list[Direction], list[Direction]]:
    """"""
    Generates all angles formed by two directions up to a certain level of abstraction.

    Args:
        d1 (Direction): The first direction.
        d2 (Direction): The second direction.
        level (int, optional): The level of abstraction. Defaults to infinity.

    Yields:
        tuple[Angle, list[Direction], list[Direction]]: A tuple with an Angle instance and lists of equivalent
        directions for d1 and d2.

    Example Usage:
        >>> direction1, direction2 = Direction(), Direction()
        >>> for angle, d1_equivs, d2_equivs in all_angles(direction1, direction2):
        >>>     print(angle, d1_equivs, d2_equivs)
    """"""

    # Default level is infinity if not specified.
    level = level or float('inf')

    # Get all equivalent directions for d1 up to the specified level.
    d1s = d1.equivs_upto(level)

    # Get all equivalent directions for d2 up to the specified level.
    d2s = d2.equivs_upto(level)

    # Iterate over all angles connected to the representative direction of d1.
    for ang in d1.rep().neighbors(Angle):

        # Get the directions forming the angle.
        d1_, d2_ = ang._d

        # Yield the angle and equivalent directions if they match d1 and d2.
        if d1_ in d1s and d2_ in d2s:
            yield ang, d1s, d2s


def all_ratios(d1, d2, level=None) -> tuple[Angle, list[Direction], list[Direction]]:
    """"""
    Generates all ratios formed by two values up to a certain level of abstraction.

    Args:
        d1 (Node): The first value.
        d2 (Node): The second value.
        level (int, optional): The level of abstraction. Defaults to infinity.

    Yields:
        tuple[Angle, list[Direction], list[Direction]]: A tuple with a Ratio instance and lists of equivalent
        values for d1 and d2.

    Example Usage:
        >>> value1, value2 = Value(), Value()
        >>> for ratio, v1_equivs, v2_equivs in all_ratios(value1, value2):
        >>>     print(ratio, v1_equivs, v2_equivs)
    """"""
    level = level or float('inf')  # Default level is infinity if not specified.
    d1s = d1.equivs_upto(level)  # Get all equivalent values for d1 up to the specified level.
    d2s = d2.equivs_upto(level)  # Get all equivalent values for d2 up to the specified level.

    # Iterate over all ratios connected to the representative value of d1.
    for rat in d1.rep().neighbors(Ratio):
        d1_, d2_ = rat._l  # Get the values forming the ratio.

        # Yield the ratio and equivalent values if they match d1 and d2.
        if d1_ in d1s and d2_ in d2s:
            yield rat, d1s, d2s


# This dictionary defines a ranking for different types of nodes.
#   - It's used to prioritize or differentiate between node types
#   - I'm not sure why yet...
RANKING = {
    Point: 0,
    Line: 1,
    Segment: 2,
    Circle: 3,
    Direction: 4,
    Length: 5,
    Angle: 6,
    Ratio: 7,
    Measure: 8,
    Value: 9,
}
import types

# Create the module Geometry as gm
gm = types.ModuleType('gm')

# Add Node class to gm
gm.Node = Node

# Add other classes to gm
gm.Point = Point
gm.Direction = Direction
gm.Measure = Measure
gm.Length = Length
gm.Segment = Segment
gm.Line = Line
gm.Circle = Circle
gm.Angle = Angle
gm.Ratio = Ratio
gm.Value = Value

# Add functions to gm
gm.why_connect = why_connect
gm.is_equiv = is_equiv
gm.is_equal = is_equal
gm.why_equal = why_equal
gm.val_type = val_type
gm.name_map = name_map
gm.bfs_backtrack = bfs_backtrack
gm.get_lines_thru_all = get_lines_thru_all
gm.line_of_and_why = line_of_and_why
gm.get_circles_thru_all = get_circles_thru_all
gm.circle_of_and_why = circle_of_and_why
gm.all_angles = all_angles
gm.all_ratios = all_ratios
# Copyright 2023 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

""""""Implements objects to represent problems, theorems, proofs, traceback.""""""

from __future__ import annotations

from collections import defaultdict  # pylint: disable=g-importing-member
from typing import Any

# import geometry as gm --> defined above
# import pretty as pt --> defined below
# pylint: disable=protected-access
# pylint: disable=unused-variable
# pylint: disable=unused-argument
# pylint: disable=unused-assignment
# This dictionary maps single character symbols to their respective geometric meanings.
#   - Each key is a character that represents a geometric concept (like 'T' for perpendicular)
#   - The corresponding value is a string that describes the concept in a more readable format.
MAP_SYMBOL = {
    'T': 'perp',      # Perpendicular
    'P': 'para',      # Parallel
    'D': 'cong',      # Congruent
    'S': 'simtri',    # Similar Triangles
    'I': 'circle',    # Circle
    'M': 'midp',      # Midpoint
    'O': 'cyclic',    # Concyclic points (lying on the same circle)
    'C': 'coll',      # Collinear
    '^': 'eqangle',   # Equal Angle
    '/': 'eqratio',   # Equal Ratio
    '%': 'eqratio',   # Equal Ratio (alternative symbol)
    '=': 'contri',    # Congruent Triangles
    'X': 'collx',     # Collinear (extended)
    'A': 'acompute',  # Angle computation
    'R': 'rcompute',  # Ratio computation
    'Q': 'fixc',      # Fixed constant
    'E': 'fixl',      # Fixed line
    'V': 'fixb',      # Fixed bisector
    'H': 'fixt',      # Fixed tangent
    'Z': 'fixp',      # Fixed point
    'Y': 'ind',       # Independent variable or parameter
}


def map_symbol(c: str) -> str:
    """"""
    Maps a single character representing a geometric concept to a more readable string format.

    Args:
        c (str): A single character symbol representing a geometric concept.

    Returns:
        str: A more readable string representation of the geometric concept.

    Raises:
        KeyError: If the symbol `c` is not found in the MAP_SYMBOL dictionary.

    Example Usage:
        >>> map_symbol('T')
        'perp'
    """"""
    return MAP_SYMBOL[c]


def map_symbol_inv(c: str) -> str:
    """"""
    Maps a geometric concept in string format back to its corresponding single character symbol.

    Args:
        c (str): A string representing a geometric concept.

    Returns:
        str: The corresponding single character symbol.

    Raises:
        KeyError: If the string `c` does not have a corresponding symbol in the MAP_SYMBOL dictionary.

    Example Usage:
        >>> map_symbol_inv('perp')
        'T'
    """"""
    # This creates a reverse mapping of the MAP_SYMBOL dictionary
    #   - i.e. the Keys become Values and viceaversa.
    return {v: k for k, v in MAP_SYMBOL.items()}[c]


def _gcd(x: int, y: int) -> int:
    """"""
    Computes the greatest common divisor (GCD) of two integers using the Euclidean algorithm.

    Args:
        x (int): The first integer.
        y (int): The second integer.

    Returns:
        int: The greatest common divisor of `x` and `y`.

    Example Usage:
        >>> _gcd(8, 12)
        4
    """"""
    # The Euclidean algorithm iteratively applies the 'modulus' operation until y becomes zero.
    #   - At that point, x holds the greatest common divisor.
    while y:
        x, y = y, x % y
    return x

def simplify(n: int, d: int) -> tuple[int, int]:
    """"""
    Simplifies a fraction by dividing both the numerator and denominator by their GCD.

    Args:
        n (int): The numerator of the fraction.
        d (int): The denominator of the fraction.

    Returns:
        tuple[int, int]: A tuple containing the simplified numerator and denominator.

    Raises:
        ZeroDivisionError: If the denominator `d` is zero.

    Example Usage:
        >>> simplify(8, 12)
        (2, 3)
    """"""

def pretty2r(a: str, b: str, c: str, d: str) -> str:
    """"""
    Formats a set of four points for a RATIO (r) comparison. 
    It ensures that the first point of each pair is not the common point in the RATIO (r) comparison.

    Args:
        a, b, c, d (str): Four points in a geometric context.

    Returns:
        str: A formatted string representing the ratio of segments AB:CD.

    Example Usage:
        >>> pretty2r('A', 'B', 'C', 'B')
        'B A C B'
    """"""
    # Swap a and b if b is the same as c or d. This is done to standardize the format for comparison.
    if b in (c, d):
        a, b = b, a

    # If a and d are the same, swap c and d to maintain the format.
    if a == d:
        c, d = d, c
    
    return f'{a} {b} {c} {d}'


def pretty2a(a: str, b: str, c: str, d: str) -> str:
    """"""
    Formats a set of four points for an ANGLE (a) comparison. 
    It ensures that the first point of each pair is not the common point in the ANGLE (a) comparison.

    Args:
        a, b, c, d (str): Four points in a geometric context.

    Returns:
        str: A formatted string representing the angles ∠AB and ∠CD for comparison.

    Example Usage:
        >>> pretty2a('A', 'B', 'C', 'B')
        'B A C B'
    """"""
    # Swap a and b if b is the same as c or d. This is done to standardize the format for comparison.
    if b in (c, d):
        a, b = b, a
    
    # If a and d are the same, swap c and d to maintain the format.
    if a == d:
        c, d = d, c

    return f'{a} {b} {c} {d}'


def pretty_angle(a: str, b: str, c: str, d: str) -> str:
    """"""
    Formats a representation of an angle.
    Specifically for the case where the points form an angle (like ∠ABC). 
    It uses Unicode characters (\u2220) to represent the angle symbol.

    Args:
        a, b, c, d (str): Four points in a geometric context.

    Returns:
        str: A Unicode string representing the angle. For example, ∠ABC or ∠(AB-CD).

    Example Usage:
        >>> pretty_angle('A', 'B', 'C', 'D')
        '∠(ABC-BCD)'
    """"""
    # Ensure the format aligns with the standard representation of an angle.
    #  - i.e. We swap a and b if b is the same as c or d. 
    #         This is done to standardize the format for comparison.
    if b in (c, d):
        a, b = b, a
    
    # If a and d are the same, swap c and d to maintain the format.
    if a == d:
        c, d = d, c

    # Return the formatted angle, using the Unicode character for angle (∠).
    if a == c:
        # Simple angle like ∠BAD.
        return f'\u2220{b}{a}{d}'  
    
    # More complex angle representation like ∠(AB-CD).
    return f'\u2220({a}{b}-{c}{d})'  


def pretty_nl(name: str, args: list[str]) -> str:
    """"""""
      Formats a geometric predicate into a natural language representation.

      Args:
          name (str): The name of the geometric predicate.
          args (list[str]): A list of arguments associated with the predicate.

      Returns:
          str: A natural language representation of the geometric predicate.

      Example Usage:
          >>> pretty_nl('coll', ['A', 'B', 'C'])
          'A,B,C are collinear'

      Notes:
          - The function handles a variety of geometric predicates, each requiring a different format.
          - This function is central to converting raw geometric data into a form that's easily readable.
      """"""

    # Handle the 'aconst' predicate, which represents a constant angle.
    if name == 'aconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # Format the angle using `pretty_angle`.
        return f'{pretty_angle(a, b, c, d)} = {y}'

    # Handle the 'rconst' predicate, which represents a constant ratio.
    if name == 'rconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # Format the ratio using `pretty2r`.
        return f'{a}{b}:{c}{d} = {y}'

    # Handle the 'acompute' predicate, which represents an angle computation.
    if name == 'acompute':
        # Unpack the arguments.
        a, b, c, d = args
        # Format the angle using `pretty_angle`.
        return f'{pretty_angle(a, b, c, d)}'

    # Handle the 'coll' predicate, which represents a collinear relationship.
    if name in ['coll', 'C']:
        # Format the collinear relationship as a comma-separated list with the words ' are collinear'.
        return '' + ','.join(args) + ' are collinear'

    # Handle the 'collx' predicate, which represents a collinear (extended) relationship.
    if name == 'collx':
        # Format the collinear relationship as a comma-separated list with the words ' are collinear'.
        return '' + ','.join(list(set(args))) + ' are collinear'

    # Handle the 'cyclic' predicate, which represents concyclic points (lying on the same circle)
    if name in ['cyclic', 'O']:
        # Format the cyclic relationship as a comma-separated list with the words ' are concyclic'.
        return '' + ','.join(args) + ' are concyclic'

    # Handle the 'midp' predicate, which represents a midpoint relationship.
    if name in ['midp', 'midpoint', 'M']:
        # Unpack the arguments.
        x, a, b = args
        # Format the midpoint relationship using a string.
        return f'{x} is midpoint of {a}{b}'

    # Handle the 'eqangle' (and 'eqangle6' amd '^' representations) predicate, which represents an equal angle relationship.
    if name in ['eqangle', 'eqangle6', '^']:
        # Unpack the arguments.
        a, b, c, d, e, f, g, h = args
        # Format the equal angle relationship using `pretty_angle`.
        return f'{pretty_angle(a, b, c, d)} = {pretty_angle(e, f, g, h)}'

    # Handle the 'eqratio' (and 'eqratio6' amd '/' representations) predicate, which represents an equal ratio
    # relationship.
    if name in ['eqratio', 'eqratio6', '/']:
        # Format the equal ratio relationship using string formatting
        return '{}{}:{}{} = {}{}:{}{}'.format(*args)

    # Handle the 'eqratio3' predicate, which represents an equal ratio relationship.
    if name == 'eqratio3':
        # Unpack the arguments.
        a, b, c, d, o, o = args  # pylint: disable=redeclared-assigned-name
        # Format the equal ratio relationship as space delimited with prefix symbol 'S'.
        return f'S {o} {a} {b} {o} {c} {d}'

    # Handle the 'cong' (and 'D' representation) predicate, which represents a congruent relationship.
    if name in ['cong', 'D']:
        # Unpack the arguments.
        a, b, c, d = args
        # Return the congruent relationship as a string.
        return f'{a}{b} = {c}{d}'

    # Handle the 'perp' (and 'T' representation) predicate, which represents a perpendicular relationship.
    if name in ['perp', 'T']:
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args
            # Return the perpendicular relationship as a string with the angle symbol.
            return f'{ab} \u27c2 {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the perpendicular relationship as a string with the angle symbol.
        return f'{a}{b} \u27c2 {c}{d}'

    # Handle the 'para' (and 'P' representation) predicate, which represents a parallel relationship.
    if name in ['para', 'P']:
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args
            # Return the parallel relationship as a string with the parallel symbol.
            return f'{ab} \u2225 {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the parallel relationship as a string with the parallel symbol.
        return f'{a}{b} \u2225 {c}{d}'

    # Handle the 'simtri2' (and 'simtri' and 'simtri*' representations) predicate, which represents a similar
    if name in ['simtri2', 'simtri', 'simtri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the similar triangle relationship as a string with the triangle symbol.
        return f'\u0394{a}{b}{c} is similar to \u0394{x}{y}{z}'

    # Handle the 'contri2' (and 'contri' and 'contri*' representations) predicate, which represents a congruent
    if name in ['contri2', 'contri', 'contri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the congruent triangle relationship as a string with the triangle symbol.
        return f'\u0394{a}{b}{c} is congruent to \u0394{x}{y}{z}'

    # Handle the 'circle' (and 'I' representation) predicate, which represents a circle relationship.
    if name in ['circle', 'I']:
        # Unpack the arguments.
        o, a, b, c = args
        # Return the circle relationship as a string with the circle symbol.
        return f'{o} is the circumcenter of \\Delta {a}{b}{c}'

    # Handle the 'foot' predicate, which represents a foot relationship.
    if name == 'foot':
        # Unpack the arguments.
        a, b, c, d = args
        # Return the foot relationship as a string with the foot symbol.
        return f'{a} is the foot of {b} on {c}{d}'


def pretty(txt: str) -> str:
    """"""
    Formats a geometric predicate string into a more readable form, either as a symbol or in natural language.

    Args:
        txt (str): A string representing a geometric predicate and its arguments.

    Returns:
        str: A formatted string either in symbolic or natural language form.

    Example Usage:
        >>> pretty('coll A B C')
        'C A B C are collinear'

    Notes:
        - This function decides whether to use symbolic or natural language format based on the predicate.
        - It's a higher-level formatter that either directly formats the string or delegates to `pretty_nl`.
    """"""

    # Check if the input is a string and split it into words for further processing.
    if isinstance(txt, str):
        txt = txt.split(' ')

    # Extract the predicate name and its arguments.
    name, *args = txt

    # Handle various predicates, each requiring a unique formatting approach.
    if name == 'ind':
        # 'ind' represents an independent variable or parameter.
        return 'Y ' + ' '.join(args)

    # These predicates represent fixed geometric elements like constants, lines, bisectors, etc.
    if name in ['fixc', 'fixl', 'fixb', 'fixt', 'fixp']:
        # The arguments are joined with a space and prefixed with the corresponding symbol.    
        return map_symbol_inv(name) + ' ' + ' '.join(args)

    # 'acompute' represents an angle computation.
    if name == 'acompute':
        
        # The arguments are joined with a space and prefixed with 'A'.
        return 'A ' + ' '.join(args)

    # 'rcompute' represents a ratio computation.
    if name == 'rcompute':
        # The arguments are joined with a space and prefixed with 'R'.
        return 'R ' + ' '.join(args)

    # 'aconst' represents a constant angle.
    if name == 'aconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # It uses `pretty2a` for formatting and is prefixed with '^'.
        return f'^ {pretty2a(a, b, c, d)} {y}'

    # 'rconst' represents a constant ratio.
    if name == 'rconst':
        # Unpack the arguments.
        a, b, c, d, y = args
        # It uses `pretty2r` for formatting and is prefixed with '/'.
        return f'/ {pretty2r(a, b, c, d)} {y}'
    
    # 'coll' represents a collinear relationship.
    if name == 'coll':
        # It's prefixed with 'C' and the arguments are joined with a space.
        return 'C ' + ' '.join(args)
    
    # 'collx' represents a collinear (extended) relationship.
    if name == 'collx':
        # It's prefixed with 'X' and the arguments are joined with a space.
        return 'X ' + ' '.join(args)
    
    # 'cyclic' represents a cyclic relationship.
    if name == 'cyclic':
        # It's prefixed with 'O' and the arguments are joined with a space.
        return 'O ' + ' '.join(args)
    
    # 'midp' represents a midpoint relationship.
    if name in ['midp', 'midpoint']:
        # Unpack the arguments.
        x, a, b = args
        # It's prefixed with 'M' and the arguments are joined with a space.
        return f'M {x} {a} {b}'
    
    # 'eqangle' (and 'eqangle6' and '^') represents an equal angle relationship.
    if name == 'eqangle':
        # Unpack the arguments.
        a, b, c, d, e, f, g, h = args
        # It uses `pretty2a` for formatting and is prefixed with '^'.
        return f'^ {pretty2a(a, b, c, d)} {pretty2a(e, f, g, h)}'
    
    # 'eqratio' (and 'eqratio6' and '/') represents an equal ratio relationship.
    if name == 'eqratio':
        # It uses `pretty2r` for formatting and is prefixed with '/'.
        a, b, c, d, e, f, g, h = args
        # Return the equal ratio relationship as a string with the ratio symbol.
        return f'/ {pretty2r(a, b, c, d)} {pretty2r(e, f, g, h)}'
    
    # 'eqratio3' represents an equal ratio relationship.
    if name == 'eqratio3':
        # Unpack the arguments.
        a, b, c, d, o, o = args  # pylint: disable=redeclared-assigned-name
        # Return the equal ratio relationship as a string with the ratio symbol.
        return f'S {o} {a} {b} {o} {c} {d}'
    
    # 'cong' (and 'D') represents a congruent relationship.
    if name == 'cong':
        # Unpack the arguments.
        a, b, c, d = args
        # Return the congruent relationship as a string with the congruent symbol.
        return f'D {a} {b} {c} {d}'
    
    # 'perp' (and 'T') represents a perpendicular relationship.
    if name == 'perp':
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args  
            # Return the perpendicular relationship as a string with the perpendicular symbol.
            return f'T {ab} {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the perpendicular relationship as a string with the perpendicular symbol.
        return f'T {a} {b} {c} {d}'
    
    # 'para' (and 'P') represents a parallel relationship.
    if name == 'para':
        # Handle the case where the predicate is an algebraic derivation.
        if len(args) == 2:
            # ab = 'd( ... )'
            ab, cd = args  
            # Return the parallel relationship as a string with the parallel symbol.
            return f'P {ab} {cd}'
        # Unpack the arguments.
        a, b, c, d = args
        # Return the parallel relationship as a string with the parallel symbol.
        return f'P {a} {b} {c} {d}'
    
    # 'simtri2' (and 'simtri' and 'simtri*') represents a similar triangle relationship.
    if name in ['simtri2', 'simtri', 'simtri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the similar triangle relationship as a string with the triangle symbol.
        return f'S {a} {b} {c} {x} {y} {z}'
    
    # 'contri2' (and 'contri' and 'contri*') represents a congruent triangle relationship.
    if name in ['contri2', 'contri', 'contri*']:
        # Unpack the arguments.
        a, b, c, x, y, z = args
        # Return the congruent triangle relationship as a string with the triangle symbol.
        return f'= {a} {b} {c} {x} {y} {z}'
    
    # 'circle' (and 'I') represents a circle relationship.
    if name == 'circle':
        # Unpack the arguments.
        o, a, b, c = args
        # Return the circle relationship as a string with the circle symbol.
        return f'I {o} {a} {b} {c}'
    
    # 'foot' represents a foot relationship.
    if name == 'foot':
        # Unpack the arguments.
        a, b, c, d = args
        # Return the foot relationship as a string with the foot symbol.
        return f'F {a} {b} {c} {d}'
    
    # If the predicate is not handled above, we format it as a space-delimited string.
    return ' '.join(txt)
import types

# Create a new module object
pt = types.ModuleType('pt') # pretty as pt

# Add functions to pt
pt.map_symbol = map_symbol
pt.map_symbol_inv = map_symbol_inv
pt._gcd = _gcd
pt.simplify = simplify
pt.pretty2r = pretty2r
pt.pretty2a = pretty2a
pt.pretty_angle = pretty_angle
pt.pretty_nl = pretty_nl
pt.pretty = pretty
# Importing necessary functions
from math import gcd

# MAP_SYMBOL dictionary
print(f""\n`MAP_SYMBOL` Dictionary:"")
for k,v in MAP_SYMBOL.items(): print(f""\t{k} --> {v}"")

# map_symbol function
print(f""\n\n`map_symbol` function\n\tmap_symbol('T') returns --> {map_symbol('T')}\n"")

# map_symbol_inv function
print(f""`map_symbol_inv` function\n\tmap_symbol_inv('perp') returns --> {map_symbol_inv('perp')}\n"")

# _gcd function
print(f""`_gcd` function\n\t_gcd(8, 12) returns --> {_gcd(8, 12)}\n"")

# simplify function
print(f""`simplify` function\n\tsimplify(8, 12) returns --> {simplify(8, 12)}\n"")

# pretty2r function
print(f""`pretty2r` function\n\tpretty2r('A', 'B', 'C', 'B') returns --> {pretty2r('A', 'B', 'C', 'B')}\n"")

# pretty2a function
print(f""`pretty2a` function\n\tpretty2a('A', 'B', 'C', 'B') returns --> {pretty2a('A', 'B', 'C', 'B')}\n"")

# pretty_angle function
print(f""`pretty_angle` function\n\tpretty_angle('A', 'B', 'C', 'D') returns --> {pretty_angle('A', 'B', 'C', 'D')}\n"")

# pretty_nl function
print(f""`pretty_nl` function\n\tpretty_nl('coll', ['A', 'B', 'C']) returns --> {pretty_nl('coll', ['A', 'B', 'C'])}\n"")

# pretty function - Example 1
example_1 = ""coll A B C""
print(f""`pretty` function - Example 1\n\tpretty('{example_1}') returns --> {pretty(example_1)}\n"")

# pretty function - Example 2
example_2 = ""perp AB CD""
print(f""`pretty` function - Example 2\n\tpretty('{example_2}') returns --> {pretty(example_2)}\n"")

# pretty function - Example 3
example_3 = ""simtri A B C X Y Z""
print(f""`pretty` function - Example 3\n\tpretty('{example_3}') returns --> {pretty(example_3)}\n"")
def reshape(l: list[Any], n: int = 1) -> list[list[Any]]:
    """"""
    Reshapes a list into a list of lists with each sublist containing n elements.

    Args:
        l (list[Any]): The original list to be reshaped.
        n (int): The number of elements each sublist should contain.

    Returns:
        list[tuple[Any]]: The reshaped list of tuples.

    Raises:
        AssertionError: If the original list's length is not a multiple of n.

    Example Usage:
        >>> reshape([1, 2, 3, 4, 5, 6], 3)
        [(1, 3, 5), (2, 4, 6)]

    Note:
        The function asserts that the length of the list l must be divisible by n.
        It then distributes the elements of l into n sublists in a round-robin fashion.
    """"""
    # Ensures the list can be evenly divided into n parts.
    assert len(l) % n == 0  
    
    # Initializes n empty sublists.
    columns = [[] for i in range(n)]  
    
    # Distributes elements into the sublists.
    for i, x in enumerate(l):
        columns[i % n].append(x)  
        
    # Zips the sublists to group nth elements together.
    return zip(*columns)


def isint(x: str) -> bool:
    """"""
    Checks if a string can be safely converted to an integer.

    Args:
        x (str): The string to be checked.

    Returns:
        bool: True if x can be converted to an integer, False otherwise.

    Example Usage:
        >>> isint(""123"")
        True
        >>> isint(""abc"")
        False

    Note:
        This function uses a try-except block to attempt conversion and catch any exceptions.
    """"""
    # Attempts to convert x to an integer.
    try:
        int(x)  
        return True
    
    # Catches any exception if conversion fails.
    except:  # pylint: disable=bare-except
        return False
    

def _gcd(x: int, y: int) -> int:
    """"""
    Computes the greatest common divisor (GCD) of two integers using the Euclidean algorithm.

    Args:
        x (int): The first integer.
        y (int): The second integer.

    Returns:
        int: The greatest common divisor of x and y.

    Example Usage:
        >>> _gcd(8, 12)
        4

    Note:
        The function uses the Euclidean algorithm, which involves repeated division.
    """"""
    # Continues finding the remainder until y becomes zero.
    while y:
        x, y = y, x % y  
    
    # The GCD is stored in x when y becomes zero.
    return x  


def simplify(n: int, d: int) -> tuple[int, int]:
    """"""
    Simplifies a fraction by dividing both the numerator and denominator by their GCD.

    Args:
        n (int): The numerator of the fraction.
        d (int): The denominator of the fraction.

    Returns:
        tuple[int, int]: The simplified numerator and denominator.

    Raises:
        ZeroDivisionError: If the denominator is zero.

    Example Usage:
        >>> simplify(8, 12)
        (2, 3)

    Note:
        This function uses the _gcd function to find the greatest common divisor.
    """"""
    g = _gcd(n, d)  # Finds the GCD of the numerator and denominator.
    return (n // g, d // g)  # Divides both by the GCD to simplify the fraction.

    
def parse_rely(s: str) -> dict[str, str]:
    """"""
    Parses a string representing dependencies and returns a dictionary of these mappings.

    Args:
        s (str): A string representing dependencies, formatted as 'a: b, c: d'.

    Returns:
        dict[str, str]: A dictionary where each key-value pair represents a dependency.

    Example Usage:
        >>> parse_rely(""a: b, c: d"")
        {'a': ['b'], 'c': ['d']}

    Note:
        This function splits the string by commas and then by colons to extract dependencies.
    """"""
    
    # Initialize the dependency map
    result = {}
    
    # If the string is empty (or Falsey) we return an empty dictionary
    if not s:
        return result
    
    # Splits the string into individual mappings.
    s = [x.strip() for x in s.split(',')]  
    
    # Iterate over the comma delimited mappings
    for x in s:
        
        # Splits each mapping at the colon.
        a, b = x.split(':')  
        
        # Strips and splits the keys and values.
        a, b = a.strip().split(), b.strip().split()  
        
        # Updates the result dictionary with mappings.
        result.update({m: b for m in a})  
        
    return result


def hashed(name: str, args: list[gm.Point], rename: bool = False) -> tuple[str, ...]:
    """"""
    Generates a hash-like tuple from a geometric predicate name and its arguments.

    Args:
        name (str): The geometric predicate name.
        args (list[gm.Point]): The list of points involved in the predicate.
        rename (bool, optional): If True, uses an alternative name for points.

    Returns:
        tuple[str, ...]: A tuple representing the hashed value of the predicate.

    Example Usage:
        >>> hashed('cong', [Point('A'), Point('B')], rename=False)
        ('cong', 'A', 'B')

    Note:
        This function is used to create a unique representation of geometric predicates.
    """"""
    # Handles special cases like 's_angle' and defaults to using point names for hashing.
    #   - The 'rename' flag allows for alternative point naming, useful in different contexts.
    #   - We also need to hangle the special case of 's_angle'
    if name == 's_angle':
        args = [p.name if not rename else p.new_name for p in args[:-1]] + [str(args[-1])]
    else:
        args = [p.name if not rename else p.new_name for p in args]
    return hashed_txt(name, args)


def hashed_txt(name: str, args: list[str]) -> tuple[str, ...]:
    """"""
    Creates a hash-like tuple from a geometric predicate name and its arguments. 
    This hash is designed to be unique to the predicate and its arguments, accounting for 
    the symmetry and order of the arguments where applicable.

    Args:
        name (str): The name of the geometric predicate (like 'cong' for congruent).
        args (list[str]): The list of arguments associated with the predicate. 
                          These arguments are typically point labels (like 'A', 'B', etc.).

    Returns:
        tuple[str, ...]: A tuple that uniquely represents the predicate and its arguments.

    Example Usage:
        >>> hashed_txt('cong', ['A', 'B', 'C', 'D'])
        ('cong', 'A', 'B', 'C', 'D')

    Raises:
        ValueError: If the predicate name is not recognized.

    Notes:
        - The function handles various geometric predicates and sorts their arguments 
          to ensure consistent and equivariant representation.
        - This is particularly important for predicates where the order of arguments 
          does not change the meaning (e.g., congruence, parallelism).
    """"""
    
    # Handle predicates that involve constants (like angles or ratios).
    #   - These predicates have a special last argument (usually a numeric value) 
    #   - This argument should not be sorted with the other point labels.
    if name in ['const', 'aconst', 'rconst']:
        a, b, c, d, y = args  # Unpacking the arguments
        a, b = sorted([a, b])  # Sorting the first pair of points
        c, d = sorted([c, d])  # Sorting the second pair of points
        return name, a, b, c, d, y  # Returning the formatted tuple
    
    # Handle binary predicates like 'para', 'cong', 'perp', etc.
    #   - These involve two pairs of points and require sorting each pair and then the pairs themselves.
    if name in ['npara', 'nperp', 'para', 'cong', 'perp', 'collx']:
        a, b, c, d = args  # Unpacking the arguments
        
        # Sorting each pair of points and then sorting the pairs
        a, b = sorted([a, b])
        c, d = sorted([c, d])
        (a, b), (c, d) = sorted([(a, b), (c, d)])
        
        return (name, a, b, c, d)  # Returning the formatted tuple

    # Handling predicates involving midpoints.
    #   - Here, only the second and third arguments (representing points) are sorted.
    if name in ['midp', 'midpoint']:
        a, b, c = args  # Unpacking the arguments
        b, c = sorted([b, c])  # Sorting the 2nd and 3rd points
        return (name, a, b, c)  # Returning the formatted tuple

    # Handling predicates that involve collections of points like 'coll', 'cyclic', etc.
    #   - Here, all arguments are point labels that are sorted and deduplicated.
    if name in ['coll', 'cyclic', 'ncoll', 'diff', 'triangle']:
        return (name,) + tuple(sorted(list(set(args)))) # Returning the formatted tuple

    # Handling the 'circle' predicate.
    #   - This involves one central point followed by three points on the circle, sorted.
    if name == 'circle':
        x, a, b, c = args  # Unpacking the arguments
        return (name, x) + tuple(sorted([a, b, c]))  # Returning the formatted tuple

    # Handling predicates like 'eqangle', 'eqratio' which compare two geometrical figures.
    #   - This requires sorting the points in each geometrical figure and then sorting the figures.
    if name in ['eqangle', 'eqratio', 'eqangle6', 'eqratio6']:
        a, b, c, d, e, f, g, h = args  # Unpacking the arguments
        
        # Sorting points within each geometrical figure and then sorting the figures.
        a, b = sorted([a, b])
        c, d = sorted([c, d])
        e, f = sorted([e, f])
        g, h = sorted([g, h])
        
        # Adjusting order to ensure consistent representation
        if tuple(sorted([a, b, e, f])) > tuple(sorted([c, d, g, h])):
            a, b, e, f, c, d, g, h = c, d, g, h, a, b, e, f
        if (a, b, c, d) > (e, f, g, h):
            a, b, c, d, e, f, g, h = e, f, g, h, a, b, c, d
            
        # Normalizing names for '6' variants of the predicates
        if name == 'eqangle6':
            name = 'eqangle'
        if name == 'eqratio6':
            name = 'eqratio'
            
        # Returning the formatted tuple
        return (name,) + (a, b, c, d, e, f, g, h)

    # Handling predicates that involve triangles.
    #   - This includes sorting the points in each triangle and then sorting the triangles.
    if name in ['contri', 'simtri', 'simtri2', 'contri2', 'contri*', 'simtri*']:
        a, b, c, x, y, z = args  # Unpacking the arguments
        
        # Sorting points within each triangle and then sorting the triangles.
        (a, x), (b, y), (c, z) = sorted([(a, x), (b, y), (c, z)], key=sorted)
        (a, b, c), (x, y, z) = sorted([(a, b, c), (x, y, z)], key=sorted)
        
        return (name, a, b, c, x, y, z)  # Returning the formatted tuple

    # Handling 'eqratio3' predicate.
    #   - This involves sorting pairs of points and then sorting the pairs.
    if name in ['eqratio3']:
        # Unpacking the arguments and sorting the pairs of points
        a, b, c, d, o, o = args  # pylint: disable=redeclared-assigned-name
        (a, c), (b, d) = sorted([(a, c), (b, d)], key=sorted)
        (a, b), (c, d) = sorted([(a, b), (c, d)], key=sorted)
        return (name, a, b, c, d, o, o)  # Returning the formatted tuple

    # Handling special predicates like 'sameside' or 's_angle'.
    if name in ['sameside', 's_angle']:
        return (name,) + tuple(args)  # Returning the formatted tuple

    # Raising an error if the predicate name is not recognized.
    raise ValueError(f'Not recognize {name} to hash.')
class Construction:
    """"""
    Represents a geometric construction (predicate), defined by a name and a list of arguments.

    A construction is a basic building block in geometric problems and proofs,
    representing a geometric concept such as a point, line, angle, etc., along
    with its properties and relations to other geometric entities.

    Attributes:
        name (str): The name of the geometric construction (e.g., 'line', 'angle').
        args (list[str]): The arguments or parameters of the construction, typically
                          representing points or numerical values.

    Methods:
        from_txt(cls, data: str): Class method to create a Construction object from
                                  a string representation.
        translate(self, mapping: dict[str, str]): Translates the construction's arguments
                                                  based on the provided mapping.
        txt(self): Returns a string representation of the construction.
    
    Example Usage:
        >>> construction = Construction('line', ['A', 'B'])
        >>> print(construction.name)
        'line'
        >>> print(construction.args)
        ['A', 'B']
        >>> print(construction.txt())
        'line A B'
    """"""

    @classmethod
    def from_txt(cls, data: str) -> Construction:
        """"""
        Creates a Construction object from a string representation.

        Args:
            data (str): The string representation of the construction, where
                        the first word is the name and the rest are arguments.

        Returns:
            Construction: The constructed object.

        Example Usage:
            >>> Construction.from_txt('line A B')
            <Construction object with name 'line' and args ['A', 'B']>
        """"""
        data = data.split(' ')
        return cls(data[0], data[1:])

    def __init__(self, name: str, args: list[str]):
        """"""
        Initializes the Construction object with a name and a list of arguments.

        Args:
            name (str): The name of the construction.
            args (list[str]): The arguments of the construction.
        """"""
        self.name = name
        self.args = args

    def translate(self, mapping: dict[str, str]) -> Construction:
        """"""
        Translates the construction's arguments based on the provided mapping.

        This is typically used to rename points or parameters according to a new
        naming convention.

        Args:
            mapping (dict[str, str]): A dictionary mapping from old argument names
                                      to new ones.

        Returns:
            Construction: A new Construction object with translated arguments.

        Example Usage:
            >>> construction = Construction('line', ['A', 'B'])
            >>> new_construction = construction.translate({'A': 'X', 'B': 'Y'})
            >>> print(new_construction.txt())
            'line X Y'
        """"""
        args = [a if isint(a) else mapping.get(a, a) for a in self.args]
        return Construction(self.name, args)

    def txt(self) -> str:
        """"""
        Returns a string representation of the construction.

        The string representation consists of the construction's name followed
        by its arguments separated by spaces.

        Returns:
            str: The string representation of the construction.

        Example Usage:
            >>> construction = Construction('line', ['A', 'B'])
            >>> print(construction.txt())
            'line A B'
        """"""
        return ' '.join([self.name] + list(self.args))
    
    
class Clause:
    def __init__(self, points: list[str], constructions: list[Construction]):
        """"""
        Initializes the Clause object with points and constructions.

        Args:
            points (list[str]): The list of points involved in the clause.
            constructions (list[Construction]): The constructions (predicates) in the clause.
        """"""
        self.points = []  # Initialize an empty list for storing processed points.
        self.nums = []    # Initialize an empty list for storing numerical values associated with points, if any.

        # Process each point in the provided points list.
        for p in points:
            num = None  # Default numerical value for a point is set to None.

            # Check if the point is a string and contains '@' symbol, indicating a special format.
            if isinstance(p, str) and '@' in p:
                p, num = p.split('@')  # Split the point at '@' to separate the point label and its numeric value.
                x, y = num.split('_')  # Further split the numeric part at '_' to extract two values.
                num = float(x), float(y)  # Convert these values into floats and store them as a tuple.

            self.points.append(p)  # Append the processed point label to the points list.
            self.nums.append(num)   # Append the corresponding numerical value (or None) to the nums list.

        self.constructions = constructions  # Store the provided constructions.

    def translate(self, mapping: dict[str, str]) -> 'Clause':
        """"""
        Translates the clause's points based on the provided mapping.

        This method is typically used to rename points according to a new naming convention.

        Args:
            mapping (dict[str, str]): A dictionary mapping from old point names to new ones.

        Returns:
            Clause: A new Clause object with translated points and constructions.

        Example Usage:
            >>> clause = Clause(['A', 'B'], [Construction('line', ['A', 'B'])])
            >>> new_clause = clause.translate({'A': 'X', 'B': 'Y'})
            >>> print(new_clause.points)
            ['X', 'Y']
        """"""
        points0 = []  # Initialize an empty list to store the translated points.

        # Iterate over each point in the points list.
        for p in self.points:
            
            # Generate a new name for the point if it exceeds the alphabet limit (i.e., beyond 'z').
            pcount = len(mapping) + 1  # Determine the count for the new point name.
            name = chr(96 + pcount)  # Generate a character based on the count.
            
            # If the generated name exceeds 'z', create a new name using a combination of characters.
            if name > 'z':  
                name = chr(97 + (pcount - 1) % 26) + str((pcount - 1) // 26)

            # Get the new name for the point from the mapping, defaulting to the generated name if not found.
            p0 = mapping.get(p, name)
            
            mapping[p] = p0  # Update the mapping with the new point name.
            points0.append(p0)  # Add the translated point name to the new list.

        # Return a new Clause object with translated points and updated constructions.
        return Clause(points0, [c.translate(mapping) for c in self.constructions])

    def add(self, name: str, args: list[str]) -> None:
        """"""
        Adds a new construction to the clause.

        This method allows adding an additional construction (or predicate) to the clause's list of constructions. 

        Args:
            name (str): The name of the geometric construction to be added (e.g., 'line', 'circle').
            args (list[str]): The list of arguments associated with this construction (typically point labels).

        Example Usage:
            >>> clause = Clause(['A', 'B'], [Construction('line', ['A', 'B'])])
            >>> clause.add('circle', ['C', 'A', 'B'])
            >>> print(clause.txt())
            'A B = line A B, circle C A B'
        """"""
        # Appends a new Construction object to the clause's constructions list.
        #   - The new Construction is created with the provided name and arguments.
        self.constructions.append(Construction(name, args))

    def txt(self) -> str:
        """"""
        Returns a string representation of the clause.

        The string format is: 'point1 point2 ... = construction1, construction2, ...'. 
        It represents the clause with its points and constructions in a readable format.

        Returns:
            str: The string representation of the clause.

        Example Usage:
            >>> clause = Clause(['A', 'B'], [Construction('line', ['A', 'B']), Construction('circle', ['C', 'A', 'B'])])
            >>> print(clause.txt())
            'A B = line A B, circle C A B'
        """"""
        # Joins the points into a single string, separated by spaces.
        points_str = ' '.join(self.points)

        # Generates the string representation for each construction in the clause.
        #   - Each construction is converted to its string format and joined by commas.
        constructions_str = ', '.join(c.txt() for c in self.constructions)

        # Combines the points string and the constructions string into the final format.
        return points_str + ' = ' + constructions_str

class Problem:
    """"""
    Represents a geometric problem, consisting of various clauses and a goal.

    A Problem in this context is structured as a collection of clauses (each being a set of constructions and points) 
    and a goal, which is a single construction that needs to be proved or derived.

    Attributes:
        url (str): An identifier or a reference link for the problem.
        clauses (list[Clause]): A list of clauses that constitute the problem.
        goal (Construction): The goal or objective of the problem.
        mapping (dict): Optional attribute to store a mapping of point names, used in translation.

    Methods:
        from_txt_file: Loads problems from a text file.
        from_txt: Parses a problem from a string representation.
        to_dict: Converts a list of problems into a dictionary indexed by URLs.
        copy: Creates a deep copy of the problem.
        translate: Translates point names of the problem into a standardized format.
        txt: Returns a string representation of the problem.
        setup_str_from_problem: Generates a string representation of the problem suitable for theorem proving.
    """"""
    
    @classmethod
    def from_txt_file(cls, fname: str, to_dict: bool = False, translate: bool = True):
        """"""
        Loads problem(s) from a text file, each problem will be represented as a string.

        Args:
            fname (str): The filename of the text file containing the problems.
            to_dict (bool, optional): If True, returns a dictionary of problems indexed by their URLs.
            translate (bool, optional): If True, translates the problems into a standard format.

        Returns:
            list[Problem] or dict[str, Problem]: A list or dictionary of Problem objects.

        Example Usage:
            >>> problems = Problem.from_txt_file(""problems.txt"", to_dict=True)
            >>> print(problems['http://example.com/problem1'].txt())
        """"""

        # Open the file specified by 'fname' in read mode.
        with open(fname, 'r') as f:
            # Read the entire content of the file and split it into lines.
            lines = f.read().split('\n')

        # Filter out empty lines to avoid processing unnecessary whitespace.
        lines = [l for l in lines if l]

        # The 'reshape' function is used to pair each URL with its corresponding problem.
        # It's assumed that each problem is represented in two lines: one for the URL and one for the problem itself.
        data = [
            cls.from_txt(url + '\n' + problem, translate)  # Combine URL and problem and parse it using 'from_txt'.
            for (url, problem) in reshape(lines, 2)  # Use 'reshape' to create pairs of (URL, problem).
        ]

        # If 'to_dict' is True, convert the list of problems into a dictionary with URLs as keys.
        if to_dict:
            # Convert the list of problems to a dictionary indexed by URLs.
            return cls.to_dict(data)  

        # If 'to_dict' is False, simply return the list of problems.
        return data

    @classmethod
    def from_txt(cls, data: str, translate: bool = True) -> Problem:
        """"""
        Parses a problem from its string representation.

        Args:
            data (str): The string representation of the problem.
            translate (bool): If True, translates the problem into a standard format.

        Returns:
            Problem: The parsed problem object.

        Example Usage:
            >>> problem_str = ""A B C; D E F ? goal""
            >>> problem = Problem.from_txt(problem_str)
            >>> print(problem.txt())
        """"""
        # Initialize the URL as an empty string.
        url = ''

        # If the data contains a newline character, it indicates the presence of a URL.
        if '\n' in data:
            # Split the data into URL and the actual problem data.
            url, data = data.split('\n')

        # Check if the data contains a goal (identified by ' ? ').
        if ' ? ' in data:
            # Split the data into clauses (problem's body) and goal.
            clauses, goal = data.split(' ? ')
            # Convert the goal string into a Construction object.
            goal = Construction.from_txt(goal)
        else:
            # If there is no goal, set clauses to data and goal to None.
            clauses, goal = data, None

        # Split the clauses part into individual clauses based on '; '.
        clauses = clauses.split('; ')
        # Create a Problem object with the parsed URL, clauses, and goal.
        #   - Each clause is converted from string to Clause object using Clause.from_txt.
        problem = Problem(
            url=url, 
            clauses=[Clause.from_txt(c) for c in clauses], 
            goal=goal
        )

        # If translation is requested, translate the problem to a standard format.
        if translate:
            return problem.translate()

        # Return the parsed problem as-is if no translation is needed.
        return problem

    @classmethod
    def to_dict(cls, data: list[Problem]) -> dict[str, Problem]:
        """"""
        Converts a list of Problem objects into a dictionary.

        Args:
            data (list[Problem]): A list of Problem objects.

        Returns:
            dict[str, Problem]: A dictionary mapping each Problem's URL to the Problem object.

        Example Usage:
            >>> problems = [Problem('url1', [], None), Problem('url2', [], None)]
            >>> problems_dict = Problem.to_dict(problems)
            >>> print(problems_dict.keys())
            dict_keys(['url1', 'url2'])
        """"""
        # Creates a dictionary from the list of problems,
        #   - Each problem's URL is the KEY
        #   - Each problem object itself is the VALUE.
        return {p.url: p for p in data}
    
    def __init__(self, url: str, clauses: list[Clause], goal: Construction):
        """"""
        Initializes a Problem object.

        Args:
            url (str): The URL associated with the problem.
            clauses (list[Clause]): A list of Clause objects representing the problem's clauses.
            goal (Construction): The goal construction of the problem.

        Example Usage:
            >>> problem = Problem('example_url', [], None)
            >>> print(problem.url)
            'example_url'
        """"""
        self.url = url            # Storing the URL of the problem.
        self.clauses = clauses    # Storing the list of clauses in the problem.
        self.goal = goal          # Storing the goal of the problem.
        
    def copy(self) -> Problem:
        """"""
        Creates a copy of the current Problem object.

        Returns:
            Problem: A new Problem object that is a copy of the current object.

        Example Usage:
            >>> original_problem = Problem('url', [], None)
            >>> copied_problem = original_problem.copy()
            >>> print(copied_problem.url)
            'url'
        """"""
        # Returns a new Problem object with the same URL, clauses, and goal as the current object.
        #   - Uses list(self.clauses) to create a shallow copy of the clauses list.
        return Problem(self.url, list(self.clauses), self.goal)
    
    def translate(self) -> Problem:
        """"""
        Translates the problem by standardizing the naming of points to single characters.

        Returns:
            Problem: A new Problem object with translated clause and goal names.

        Example Usage:
            >>> problem = Problem('url', [Clause(['A1', 'B1'], [])], None)
            >>> translated_problem = problem.translate()
            >>> print(translated_problem.clauses[0].points)
            ['A', 'B']
        """"""
        mapping = {}     # Initialize an empty dictionary for point name mapping.
        clauses = []     # Initialize an empty list to store translated clauses.

        # Iterate over each clause in the problem.
        for clause in self.clauses:
            # Translate each clause and append it to the translated clauses list.
            clauses.append(clause.translate(mapping))

        # Translate the goal if it exists (otherwise take it as-is)
        if self.goal:
            goal = self.goal.translate(mapping)
        else:
            goal = self.goal

        # Create a new Problem object with the translated clauses and goal.
        p = Problem(self.url, clauses, goal)
        
        # Store the mapping used for translation.
        p.mapping = mapping  

        # Return the translated Problem object.
        return p  
    
    def txt(self) -> str:
        """"""
        Generates a string representation of the problem.

        This representation includes all the clauses and the goal of the problem,
        formatted in a specific way for readability and consistency.

        Returns:
            str: The string representation of the problem.

        Example Usage:
            Suppose a problem has two clauses 'A B C' and 'D E F', and a goal 'G H'.
            >>> problem = Problem('', [Clause(['A', 'B', 'C'], []), Clause(['D', 'E', 'F'], [])], Construction('goal', ['G', 'H']))
            >>> print(problem.txt())
            'A B C ; D E F ? goal G H'
        """"""
        # If there is a goal, it's separated from the clauses by ' ? '.
        #   - If there IS A GOAL:
        #     - We join the string representations of all clauses with '; ' and append the goal representation. (and return)
        #   - If there IS NOT A GOAL:
        #     - An empty string is returned.
        return (
            '; '.join([c.txt() for c in self.clauses]) + ' ? ' + self.goal.txt() 
            if self.goal
            else ''
        )

    def setup_str_from_problem(self, definitions: list[Definition]) -> str:
        """"""
        Constructs a string representing the theorem premises from a Problem object.

        This method processes each construction in the problem's clauses against a set
        of geometric definitions. It then builds a detailed string that outlines the
        dependencies and relationships between various geometric entities.

        Args:
            definitions (list[Definition]): A list of geometric definitions.

        Returns:
            str: A detailed string representation of the theorem premises.

        Raises:
            AssertionError: If the argument length mismatch is detected between a 
                            construction and its definition.

        Example Usage:
            # Assuming 'definitions' is a pre-defined list of geometric definitions
            >>> problem = Problem(...)
            >>> theorem_premises = problem.setup_str_from_problem(definitions)
            >>> print(theorem_premises)

        Note:
            This method is complex and involves nested loops, conditional checks, and
            string manipulation to generate a comprehensive representation.
        """"""

        # Initializing a reference counter for dependencies.
        ref = 0  

        # List to accumulate strings representing each clause.
        string = []

        # Process each clause in the problem.
        for clause in self.clauses:
            group = {}  # Dictionary to group points.
            p2deps = defaultdict(list)  # Default dictionary to store point-to-dependencies mappings.

            # Iterate over each construction in the clause.
            for c in clause.constructions:
                # Retrieve the definition for the current construction.
                cdef = definitions[c.name]

                # Check if the length of the arguments in the construction matches its definition.
                # If not, assert that the total argument length (including points) matches the definition.
                if len(c.args) != len(cdef.construction.args):
                    assert len(c.args) + len(clause.points) == len(cdef.construction.args), \
                        ""Mismatch in argument length between construction and its definition.""
                    c.args = clause.points + c.args  # Combine points with arguments.

                # Create a mapping of construction arguments to actual points/arguments.
                mapping = dict(zip(cdef.construction.args, c.args))

                # Process basic constructions (basics) in the definition.
                for points, bs in cdef.basics:
                    points = tuple([mapping[x] for x in points])  # Map the basic construction points.
                    for p in points:
                        group[p] = points  # Group points together.

                    # Iterate over basic constructions in the definition.
                    for b in bs:
                        args = [mapping[a] for a in b.args]  # Map arguments of basic constructions.
                        name = b.name

                        # Special handling for 's_angle' and 'aconst' construction types.
                        if b.name in ['s_angle', 'aconst']:
                            x, y, z, v = args
                            name = 'aconst'
                            v = int(v)

                            # Adjust the values and points for negative angles.
                            if v < 0:
                                v = -v
                                x, z = z, x

                            # Simplify the angle representation.
                            m, n = simplify(int(v), 180)
                            args = [y, z, y, x, f'{m}pi/{n}']

                        # Append the hashed text representation of the construction.
                        p2deps[points].append(hashed_txt(name, args))

            # Sort the dependencies for each group of points.
            for k, v in p2deps.items():
                p2deps[k] = sort_deps(v)

            # Process each point in the clause.
            points = clause.points
            while points:
                p = points[0]
                gr = group[p]
                points = [x for x in points if x not in gr]  # Filter out processed points.
                
                # List to store dependency strings.
                deps_str = []  

                # Iterate over dependencies for the current group.
                for dep in p2deps[gr]:
                    # Format the reference number.
                    ref_str = '{:02}'.format(ref)
                    dep_str = pt.pretty(dep)  # Get the pretty-printed representation of the dependency.

                    # Special handling for dependencies of type 'aconst'.
                    if dep[0] == 'aconst':
                        m, n = map(int, dep[-1].split('pi/'))  # Extract angle ratio.
                        mn = f'{m}. pi / {n}.'  # Format the angle representation.
                        dep_str = ' '.join(dep_str.split()[:-1] + [mn])  # Update dependency string with formatted angle.

                    # Append the formatted dependency string with its reference.
                    deps_str.append(dep_str + ' ' + ref_str)
                    ref += 1  # Increment the reference counter.

                # Append the formatted string for the current group.
                string.append(' '.join(gr) + ' : ' + ' '.join(deps_str))

        # Combine all clause strings and append the goal (if present).
        string = '{S} ' + ' ; '.join([s.strip() for s in string])
        if self.goal:
            string += ' ? ' + pt.pretty([self.goal.name] + self.goal.args)
        
        return string
class Definition:
    """"""
    Represents the definitions of construction statements in geometry.

    This class encapsulates the definition of a geometric construction, including
    its dependencies, basic constructions, and numeric properties if any. It's essential
    for understanding how different geometric entities are constructed and related.

    Attributes:
        construction (Construction): The main construction this definition describes.
        rely (dict[str, str]): A mapping of dependencies for the construction.
        deps (Clause): The clause representing the dependencies of the construction.
        basics (list[tuple[list[str], list[Construction]]]): A list of basic constructions and points involved.
        numerics (list[Construction]): Numeric properties or constraints related to the construction.
        points (list[str]): Points involved in the construction (extracted from the construction args).
        args (list[str]): Arguments or parameters specific to the construction.

    Methods:
        from_txt_file: Class method to load definitions from a text file.
        from_string: Class method to create definitions from a string.
        to_dict: Class method to convert a list of definitions into a dictionary.
        from_txt: Class method to parse a single definition from a string.
    """"""

    @classmethod
    def from_txt_file(cls, fname: str, to_dict: bool = False) -> Union[List['Definition'], Dict[str, 'Definition']]:
        """"""
        Loads definitions from a text file.

        This method reads a file containing geometric definitions and constructs
        a list (or dictionary) of Definition objects.

        Args:
            fname (str): The filename of the text file containing the definitions.
            to_dict (bool, optional): If True, returns a dictionary of definitions indexed by their construction names.

        Returns:
            Union[List[Definition], Dict[str, Definition]]: Either a list or dictionary of Definition objects.

        Example Usage:
            >>> definitions = Definition.from_txt_file(""definitions.txt"", to_dict=True)
            >>> print(definitions['line'].construction.name)
            'line'
        """"""
        # Open the file and read its content
        with open(fname, 'r') as f:
            lines = f.read()
        
        # Split the content into individual definitions and process each
        return cls.from_string(lines, to_dict)

    @classmethod
    def from_string(cls, string: str, to_dict: bool = False) -> Union[List['Definition'], Dict[str, 'Definition']]:
        """"""
        Creates a list (or dictionary) of Definition objects from a multiline string.

        Each definition in the string should be separated by a specific number of line breaks
        (currently 6 lines per definition including the empty lines).

        Args:
            string (str): Multiline string containing several geometric definitions.
            to_dict (bool, optional): If True, the method returns a dictionary with construction names as keys.

        Returns:
            Union[List[Definition], Dict[str, Definition]]: A list or dictionary of Definition objects.

        Example Usage:
            Suppose 'string' contains two definitions separated by 6 lines.
            >>> definitions = Definition.from_string(string, to_dict=True)
            >>> print(definitions['line'].construction.name)
            'line'

        Note:
            This method assumes a specific format for each definition in the input string.
            An incorrect format might lead to unexpected results or errors.
        """"""
        # Split the entire string into lines
        lines = string.split('\n')

        # Group these lines into chunks, each representing a single definition
        #   - 'reshape' is used to group every 6 lines into one definition
        data = [cls.from_txt('\n'.join(group)) for group in reshape(lines, 6)]

        # Convert the list of Definition objects into a dictionary if required
        if to_dict:
            return cls.to_dict(data)
        
        # Otherwise we return as-is
        return data

    @classmethod
    def to_dict(cls, data: list[Definition]) -> dict[str, Definition]:
        """"""
        Converts a list of Definition objects into a dictionary.

        The dictionary keys are the names of the constructions from each Definition.

        Args:
            data (list[Definition]): The list of Definition objects to be converted.

        Returns:
            dict[str, Definition]: A dictionary mapping construction names to Definition objects.

        Example Usage:
            >>> definitions_list = [Definition(Construction('line', []), {}, Clause([], []), [], [])]
            >>> definitions_dict = Definition.to_dict(definitions_list)
            >>> 'line' in definitions_dict
            True

        Note:
            The method assumes that each construction name in the definitions is unique.
        """"""
        # Create a dictionary with construction names as keys and the Definition objects as values
        return {d.construction.name: d for d in data}

    @classmethod
    def from_txt(cls, data: str) -> Definition:
        """"""
        Parses a single definition from a string representation.

        This method takes a string that encapsulates a geometric construction definition and its various components,
        and parses it to create a `Definition` object. The string should be formatted with each component separated
        by a newline, following a specific sequence: construction, dependencies (rely), basics, and numerics.

        Args:
            data (str): The string representation of a single geometric definition.

        Returns:
            Definition: The Definition object created from the string.

        Example Usage:
            >>> definition_str = ""line AB\nA: B\nAB = \n\n\n""
            >>> definition = Definition.from_txt(definition_str)
            >>> print(definition.construction.name)
            'line'

        Raises:
            ValueError: If the string format is incorrect or missing required information.

        Note:
            The method assumes a strict format for 'data' and splits it into components based on line breaks.
            Each component is then processed to construct the Definition object.
        """"""
        # Split the input string into its components using newline as a delimiter.
        #   - Each part represents a different aspect of the geometric definition.
        construction, rely, deps, basics, numerics, _ = data.split('\n')

        # Process the 'basics' section of the definition.
        #   - The 'basics' are split by semicolons and further processed into tuples of points and basic constructions.
        basics = [] if not basics else [b.strip() for b in basics.split(';')]
        levels = []
        for bs in basics:
            # If a colon is present, split into points and basic constructions.
            if ':' in bs:
                points, bs = bs.split(':')
                points = points.strip().split()  # Extract the points as a list.
            else:
                points = []

            # Process each basic construction after splitting by comma and convert to Construction objects.
            bs = [Construction.from_txt(b.strip()) for b in bs.strip().split(',')] if bs.strip() else []
            levels.append((points, bs))  # Append the tuple of points and basic constructions to the levels list.

        # Process the 'numerics' section, which is expected to be a comma-separated list of numeric constructions.
        numerics = [] if not numerics else numerics.split(', ')

        # Create the Definition object using the parsed components.
        #   - This includes converting the construction, dependencies, and basics into their respective object representations.
        return Definition(
            construction=Construction.from_txt(construction),
            rely=parse_rely(rely),
            deps=Clause.from_txt(deps),
            basics=levels,
            numerics=[Construction.from_txt(c) for c in numerics],
        )


    def __init__(self, construction: Construction, rely: Dict[str, str], deps: Clause, 
                 basics: List[Tuple[List[str], List[Construction]]], numerics: List[Construction]):
        """"""
        Initializes the Definition object.

        Args:
            construction (Construction): The main construction this definition describes.
            rely (dict[str, str]): Dependencies mapping for the construction.
            deps (Clause): Clause representing the dependencies of the construction.
            basics (list[tuple[list[str], list[Construction]]]): Basic constructions and involved points.
            numerics (list[Construction]): Numeric properties or constraints of the construction.

        Example:
            >>> construction = Construction('triangle', ['A', 'B', 'C'])
            >>> definition = Definition(construction, {}, Clause([], []), [], [])
            >>> print(definition.construction.name)
            'triangle'
        """"""
        self.construction = construction  # Main construction
        self.rely = rely                  # Dependencies
        self.deps = deps                  # Clause for dependencies
        self.basics = basics              # Basic constructions
        self.numerics = numerics          # Numeric properties

        # Process and separate points and arguments from the construction's arguments
        args = set()
        
        # Add individual numerics to the 'args'
        for num in numerics:
            args.update(num.args)
            
        # Create attributes for points and args respectively
        self.points, self.args = [], []
        
        for p in self.construction.args:
            # If the arg is present in the construction then add to attribute args
            if p in args:
                self.args.append(p)
            # Otherwise, it is a point and we add it to the respective attribute
            else:
                self.points.append(p)
class Theorem:
    """"""
    Represents a geometric deduction rule or theorem.

    A Theorem in this context is a logical rule. 
    It describes how certain premises can lead to a specific conclusion
        - A premise is a given geometric construction
        - A conclusion is another geometric construction

    Attributes:
        name (str): A unique identifier for the theorem, typically derived from its premises and conclusion.
        premise (list[Construction]): A list of constructions that form the premises of the theorem.
        conclusion (list[Construction]): The conclusion construction of the theorem.
        is_arg_reduce (bool): Indicates whether the theorem reduces the number of arguments in the deduction process.

    Methods:
        from_txt_file: Loads theorems from a text file.
        from_string: Creates theorems from a string.
        from_txt: Parses a single theorem from a string.
        txt: Returns a string representation of the theorem.
        conclusion_name_args: Returns the conclusion's name and its arguments as points.
    """"""

    @classmethod
    def from_txt_file(cls, fname: str, to_dict: bool = False) -> Union[List['Theorem'], Dict[str, 'Theorem']]:
        """"""
        Loads theorems from a text file.

        Each theorem is expected to be on a separate line in the file. Lines starting with '#' are treated as comments
        and ignored. This method reads the file, processes each line to create Theorem objects, and returns them as a list
        or dictionary.

        Args:
            fname (str): The filename of the text file containing the theorems.
            to_dict (bool, optional): If True, returns a dictionary of theorems indexed by their rule names.

        Returns:
            Union[List[Theorem], Dict[str, Theorem]]: A list or dictionary of Theorem objects.

        Example Usage:
            >>> theorems = Theorem.from_txt_file(""theorems.txt"", to_dict=True)
            >>> print(theorems['r01'].txt())
            'line A B, point C => triangle A B C'
        """"""

        # Open the file and read its content
        with open(fname, 'r') as f:
            theorems = f.read()

        # Process the file content to create Theorem objects
        return cls.from_string(theorems, to_dict)

    @classmethod
    def from_string(cls, string: str, to_dict: bool = False) -> Union[List['Theorem'], Dict[str, 'Theorem']]:
        """"""
        Creates a list (or dictionary) of Theorem objects from a multiline string.

        Each line of the string should represent a theorem.
            - Lines starting with '#' are treated as comments and ignored.

        Args:
            string (str): Multiline string containing several theorems.
            to_dict (bool, optional): If True, returns a dictionary with theorems indexed by their rule names.

        Returns:
            Union[List[Theorem], Dict[str, Theorem]]: A list or dictionary of Theorem objects.

        Example Usage:
            Suppose 'string' contains multiple theorems separated by newlines.
            >>> theorems = Theorem.from_string(string, to_dict=True)
            >>> print(theorems['r01'].txt())
            'line A B, point C => triangle A B C'
        """"""

        # Split the string into lines, filtering out empty lines and comments
        theorems = [l for l in string.split('\n') if l and not l.startswith('#')]

        # Process each line to create Theorem objects
        theorems = [cls.from_txt(l) for l in theorems]

        # Assign unique rule names to each theorem
        for i, th in enumerate(theorems):
            th.rule_name = 'r{:02}'.format(i)

        # Convert to dictionary if needed (rule_name mapped to theorem itself)
        if to_dict:
            return {t.rule_name: t for t in theorems}

        return theorems

    @classmethod
    def from_txt(cls, data: str) -> 'Theorem':
        """"""
        Parses a single theorem from its string representation.

        The string format for a theorem is 'premise1, premise2, ... => conclusion'.
        Each premise and the conclusion are represented in the same way as geometric constructions.

        Args:
            data (str): The string representation of the theorem.

        Returns:
            Theorem: The parsed theorem object.

        Example Usage:
            >>> theorem_str = ""line A B, point C => triangle A B C""
            >>> theorem = Theorem.from_txt(theorem_str)
            >>> print(theorem.txt())
            'line A B, point C => triangle A B C'

        Raises:
            ValueError: If the theorem string does not contain exactly one conclusion.
        """"""

        # Split the string into premises and conclusion parts
        premises, conclusion = data.split(' => ')

        # Split the premises part into individual premises
        premises = premises.split(', ')

        # Split the conclusion part (assuming only one conclusion is allowed)
        conclusion = conclusion.split(', ')

        # Create a Theorem object from the parsed premises and conclusion
        return Theorem(
            premise=[Construction.from_txt(p) for p in premises],
            conclusion=[Construction.from_txt(c) for c in conclusion],
        )

    def __init__(self, premise: list[Construction], conclusion: list[Construction]):
        """"""
        Initializes the Theorem object.

        Args:
            premise (list[Construction]): A list of constructions forming the premises of the theorem.
            conclusion (list[Construction]): The conclusion construction of the theorem.

        Raises:
            ValueError: If more than one conclusion is provided.

        Example Usage:
            >>> theorem = Theorem([Construction('line', ['A', 'B'])], [Construction('triangle', ['A', 'B', 'C'])])
            >>> print(theorem.txt())
            'line A B => triangle A B C'
        """"""
        # Validate that there is exactly one conclusion
        if len(conclusion) != 1:
            raise ValueError('Cannot have more than one conclusion')

        # Construct the theorem name from its premises and conclusion
        self.name = '_'.join([p.name for p in premise + conclusion])
        self.premise = premise  # Store the premises
        self.conclusion = conclusion  # Store the conclusion

        # Determine if the theorem reduces argument complexity
        self.is_arg_reduce = False
        
        # Collect arguments from premises
        prem_args = set(sum([p.args for p in self.premise], []))  
        
        # Collect arguments from conclusion
        con_args = set(self.conclusion[0].args)  
        
        # Set to True if the conclusion has fewer or equal arguments compared to premises
        if len(prem_args) <= len(con_args):
            self.is_arg_reduce = True  

    def txt(self) -> str:
        """"""
        Generates a string representation of the theorem.

        This representation includes the premises and the conclusion of the theorem, formatted in a specific way.

        Returns:
            str: The string representation of the theorem.

        Example Usage:
            >>> theorem = Theorem([Construction('line', ['A', 'B'])], [Construction('triangle', ['A', 'B', 'C'])])
            >>> print(theorem.txt())
            'line A B => triangle A B C'
        """"""
        # Format the premises and conclusion into their string representations (comma delimited)
        premise_txt = ', '.join([clause.txt() for clause in self.premise])
        conclusion_txt = ', '.join([clause.txt() for clause in self.conclusion])
        
        # Combine the premise(s) and conclusion clauses into the theorem's format
        return f'{premise_txt} => {conclusion_txt}'  

    def conclusion_name_args(self, mapping: dict[str, gm.Point]) -> tuple[str, list[gm.Point]]:
        """"""
        Returns the conclusion's name and its arguments as points, based on a given mapping.

        This method is useful for translating the conclusion's abstract points to concrete geometric points,
        as per the provided mapping.

        Args:
            mapping (dict[str, gm.Point]): A mapping from point names to geometric point objects.

        Returns:
            tuple[str, list[gm.Point]]: The name of the conclusion and a list of its points.

        Example Usage:
            >>> mapping = {'A': gm.Point(0, 0), 'B': gm.Point(1, 0), 'C': gm.Point(0, 1)}
            >>> theorem = Theorem([Construction('line', ['A', 'B'])], [Construction('triangle', ['A', 'B', 'C'])])
            >>> name, args = theorem.conclusion_name_args(mapping)
            >>> print(name)
            'triangle'
            >>> for arg in args: print(arg)
            Point(0, 0)
            Point(1, 0)
            Point(0, 1)
        """"""
        # Create a new mapping with only the string keys (ignoring non-string keys)
        mapping = {arg: p for arg, p in mapping.items() if isinstance(arg, str)}

        # Retrieve the conclusion construction
        c = self.conclusion[0]

        # Map the conclusion's arguments to geometric points
        args = [mapping[a] for a in c.args]

        # Return the conclusion's name and the list of points
        return c.name, args
class Dependency(Construction):
    """"""
    Represents a dependency in geometric constructions. 

    This class is a specialized form of a Construction that includes additional attributes 
    and methods to handle dependencies in geometric reasoning. It is used to describe how 
    one geometric fact (like a line being parallel to another) can depend on or lead to other facts.

    Attributes:
        rule_name (str): Identifier for the rule associated with this dependency.
        level (int): The level of derivation or complexity of the dependency.
        why (list[Dependency]): A list of other Dependency objects that this one depends on.
        _stat: Internal status (private attribute), used for internal processing.
        trace: Trace information for debugging or detailed analysis.
    
    Inherited from Construction:
        name (str): The name of the geometric construction (e.g., 'line', 'circle').
        args (list[gm.Point]): The arguments of the construction, usually points or coordinates.
        
    Methods:
        _find: Internal method to find a specific dependency.
        remove_loop: Removes circular references in dependencies.
        copy: Creates a deep copy of the dependency.
        why_me_or_cache: Determines dependencies, utilizing caching for efficiency.
        populate: Fills the dependency with additional details.
        why_me: Main logic to determine why a particular dependency holds.
        hashed: Creates a hash-like representation for the dependency.
    """"""
    
    def __init__(self, name: str, args: list[gm.Point], rule_name: str, level: int):
        """"""
        Initializes a Dependency object.

        Args:
            name (str): The name of the dependency construction.
            args (list[gm.Point]): The points or elements involved in the dependency.
            rule_name (str): The name of the rule associated with this dependency.
            level (int): The complexity level of the dependency.

        The `super().__init__` call initializes the base Construction attributes.
        """"""
        super().__init__(name, args)  # Initialize base Construction class
        self.rule_name = rule_name or ''  # Set the rule name, defaulting to an empty string if not provided
        self.level = level  # Set the complexity level
        self.why = []  # Initialize the list of dependencies

        # Private attributes for internal use
        self._stat = None  # Status attribute, used internally
        self.trace = None  # Trace information, useful for debugging

    def _find(self, dep_hashed: tuple[str, ...]) -> Optional[Dependency]:
        """"""
        Searches recursively for a specific dependency within the current dependency's 'why' list.

        Args:
            dep_hashed (tuple[str, ...]): The hashed representation of the dependency to be found.

        Returns:
            Optional[Dependency]: The found Dependency object, or None if not found.

        Example Usage:
            >>> dep = Dependency('para', [Point('A'), Point('B'), Point('C'), Point('D')], 'rule1', 1)
            >>> dep._find(('para', 'A', 'B', 'C', 'D'))
            # Returns the Dependency object if found, else None
        """"""
        # Iterate through each 'why' dependency.
        for w in self.why:  
            
            # Recursively search in the current 'why' dependency.
            f = w._find(dep_hashed)  
            
            # If found, return the dependency.
            if f:
                return f  
            
            # If the current dependency matches, return it.
            if w.hashed() == dep_hashed:
                return w  


    def remove_loop(self) -> Dependency:
        """"""
        Removes circular references within the dependency graph to prevent infinite loops.

        Returns:
            Dependency: The current Dependency object, potentially with circular references removed.

        Example Usage:
            >>> dep = Dependency(...)
            >>> dep.remove_loop()
            # Returns Dependency object with removed circular references if any existed.
        """"""
        # Utilize _find to check for self-reference (i.e. self.hashed()).
        f = self._find(self.hashed())  
        
        # If a circular reference is found, return the found (circular) dependency.
        if f:
            return f 
        
        # Otherwise, return the current dependency (non-circular).
        return self  

    def copy(self) -> Dependency:
        """"""
        Creates a deep copy of the current Dependency object.

        Returns:
            Dependency: A new Dependency object that is a copy of the current one.

        Example Usage:
            >>> original_dep = Dependency(...)
            >>> copied_dep = original_dep.copy()
            # 'copied_dep' is a separate instance with the same data as 'original_dep'
        """"""
        # Create a new Dependency object.
        dep = Dependency(self.name, self.args, self.rule_name, self.level)  
        
        # Copy the trace attribute.
        dep.trace = self.trace  
        
        # Deep copy of the 'why' list.
        dep.why = list(self.why)
        
        # Return the deep copy of the current dependency object
        return dep

    def why_me_or_cache(self, g: Any, level: int) -> Dependency:
        """"""
        Determines the dependencies of the current object, using caching for improved efficiency.

        Args:
            g (Any): The geometry object or context in which this dependency exists.
            level (int): The level of detail or depth at which dependency resolution is performed.

        Returns:
            Dependency: The current Dependency object, potentially with updated dependencies.

        Example Usage:
            >>> geometry_context = ...
            >>> dep = Dependency(...)
            >>> dep.why_me_or_cache(geometry_context, 2)
            # This method updates 'dep' with its dependencies, using cached values if available.
        """"""
        # Check if the current dependency is in the cache and if so return the cached dep
        if self.hashed() in g.cache:  
            return g.cache[self.hashed()]
        
        # Determine dependencies and update internal state ('why')
        self.why_me(g, level)  
        
        # Return the current dependency with updated 'why'
        return self

    def populate(self, name: str, args: list[gm.Point]) -> Dependency:
        """"""
        Fills the current Dependency object with additional details.

        Args:
            name (str): The name of the dependency to be populated with.
            args (list[gm.Point]): The arguments or points associated with the dependency.

        Returns:
            Dependency: A new Dependency object populated with the given details.
        
        Raises:
            AssertionError: If the rule name does not match the expected rule
        
        Example:
            >>> dep = EmptyDependency(...)
            >>> populated_dep = dep.populate('line', [Point('A'), Point('B')])
            # 'populated_dep' is now a Dependency object with the name 'line' and points 'A', 'B'.
        """"""
        # Ensure the rule name matches the expected rule.
        assert self.rule_name == CONSTRUCTION_RULE, self.rule_name  
        
        # Create a new Dependency object with:
        #   - the basics from the current Dependency
        #   - the arguments/points associated with this dep
        dep = Dependency(self.name, self.args, self.rule_name, self.level)  
        
        # Update the created Dependency with a deepcopy of the 'why'
        dep.why = list(self.why)  # Copy the 'why' list.
        return dep

    def why_me(self, g: Any, level: int) -> None:
        """"""
        Determines the reasons (dependencies) for the current geometric fact (predicates of self).

        This method is a key part of the geometric reasoning process, where it figures out
        why a certain geometric statement (represented by this Dependency object) is true based
        on other known facts and rules.
        
        The method updates the 'why' attribute with a list of other Dependency objects
        that this one logically depends on. It uses different geometric rules and facts
        available in the context 'g' to deduce these dependencies.

        Args:
            g (Any): The geometric context or environment in which this dependency is being evaluated.
            level (int): The level of complexity or depth of reasoning being used.
        
        Raises:
            ValueError: Raises an error if the dependency name is not recognized.
        
        Note:
            This method can get quite complex, as it involves a lot of geometric reasoning
            and different cases based on the type of geometric construction. I do my
            best to explain things in as much detail as possible... but it's overwhelming... obviously.
        """"""
        name, args = self.name, self.args

        # Check if the current dependency is already cached to avoid recomputation.
        hashed_me = hashed(self.name, self.args)
        if hashed_me in g.cache:
            dep = g.cache[hashed_me]
            self.why = dep.why  # Use the cached reasons for this dependency.
            self.rule_name = dep.rule_name  # Use the cached rule name.
            return

        # Handle the 'parallel' case.
        if self.name == 'para':
            
            # Extract point arguments.
            a, b, c, d = self.args

            # If the points are identical, the dependency is trivially satisfied.
            if {a, b} == {c, d}:
                self.why = []  # No dependencies needed.
                return

            # Retrieve the lines formed by these points.
            ab = g._get_line(a, b)
            cd = g._get_line(c, d)

            # If lines are identical, handle collinearity.
            if ab == cd:
                if {a, b} == {c, d}:
                    self.why = []  # No dependencies needed if lines are same with same points.
                    self.rule_name = ''
                    return

                # If lines are same but points are different, collinearity is involved.
                dep = Dependency('coll', list({a, b, c, d}), 't??', None)
                self.why = [dep.why_me_or_cache(g, level)]
                return

            # Check for indirect dependencies through other points on the lines.
            for (x, y), xy in zip([(a, b), (c, d)], [ab, cd]):
                x_, y_ = xy.points
                if {x, y} == {x_, y_}:
                    continue
                    
                # If an indirect dependency exists, we capture it and add it to the 'why'
                d = Dependency('collx', [x, y, x_, y_], None, level)
                self.why += [d.why_me_or_cache(g, level)]

            # Find reasons why lines are parallel.
            whypara = g.why_equal(ab, cd, None)
            self.why += whypara

        # Handles the midpoint case.
        elif self.name == 'midp':
            
            # Extracts the points involved in the midpoint relationship.
            m, a, b = self.args
            
            # Retrieves segments ma and mb.
            ma = g._get_segment(m, a)
            mb = g._get_segment(m, b)
            
            # Checks if m, a, b are collinear as a part of the midpoint verification.
            dep = Dependency('coll', [m, a, b], None, None).why_me_or_cache(g, None)
            
            # The reason why m is the midpoint involves both the collinearity and the equality of segments ma and mb.
            self.why = [dep] + g.why_equal(ma, mb, level)

       # Handles the perpendicularity case.
        elif self.name == 'perp':
            
            # Extracts the points defining the perpendicular lines.
            a, b, c, d = self.args
            
            # Retrieves lines ab and cd.
            ab = g._get_line(a, b)
            cd = g._get_line(c, d)
            
            # For each pair of points, checks if they form a line segment that needs to be considered.
            for (x, y), xy in zip([(a, b), (c, d)], [ab, cd]):
                x_, y_ = xy.points
                if {x, y} != {x_, y_}:
                    d = Dependency('collx', [x, y, x_, y_], None, level)
                    self.why += [d.why_me_or_cache(g, level)]
            
            # Determines if the angles formed by these lines are equal to confirm perpendicularity.
            _, why = why_eqangle(ab._val, cd._val, cd._val, ab._val, level)
            a, b = ab.points
            c, d = cd.points

            # Checks if a renaming of points is required and updates the dependency accordingly.
            if hashed(self.name, [a, b, c, d]) != self.hashed():
                d = Dependency(self.name, [a, b, c, d], None, level)
                d.why = why
                why = [d]

            # Adds the determined reasons to the 'why' attribute.
            self.why += why

        # Handles the congruence case.
        elif self.name == 'cong':
            
            # Extracts the points defining the segments for congruence check.
            a, b, c, d = self.args
            
            # Retrieves segments ab and cd.
            ab = g._get_segment(a, b)
            cd = g._get_segment(c, d)
            
            # The reason for congruence is derived from the equality of these segments.
            self.why = g.why_equal(ab, cd, level)

        # Handles collinearity case.
        elif self.name == 'coll':
            # This method derives the reason for the collinearity of a set of points.
            _, why = gm.line_of_and_why(self.args, level)
            self.why = why

        # Handles the extended collinearity ('collx') case.
        elif self.name == 'collx':
            # Check if the points are collinear.
            if g.check_coll(self.args):
                args = list(set(self.args))
                hashed_me = hashed('coll', args)
                # Utilizes caching to avoid redundant computations.
                if hashed_me in g.cache:
                    dep = g.cache[hashed_me]
                    self.why = [dep]
                    self.rule_name = ''
                    return
                # Determines the reason for collinearity.
                _, self.why = gm.line_of_and_why(args, level)
            else:
                # If not collinear, consider the possibility of them being parallel.
                self.name = 'para'
                self.why_me(g, level)

        # Handles the cyclic case.
        elif self.name == 'cyclic':
            # This method checks if a set of points lie on a common circle.
            _, why = gm.circle_of_and_why(self.args, level)
            self.why = why

        # Handles the case for points on a circle.
        elif self.name == 'circle':
            
            # Extracts the points defining the circle and its radius.
            o, a, b, c = self.args
            
            # Retrieves segments oa, ob, and oc.
            oa = g._get_segment(o, a)
            ob = g._get_segment(o, b)
            oc = g._get_segment(o, c)
            
            # Checks for equality of these segments to confirm the circle property.
            self.why = g.why_equal(oa, ob, level) + g.why_equal(oa, oc, level)
        
        # Handles the case for equal angles
        elif self.name in ['eqangle', 'eqangle6']:
            
            # Extracts the points defining the angles (four lines, two angles)
            a, b, c, d, m, n, p, q = self.args

            # Retrieves the lines and reasons why these lines are formed through each pair of points.
            ab, why1 = g.get_line_thru_pair_why(a, b)
            cd, why2 = g.get_line_thru_pair_why(c, d)
            mn, why3 = g.get_line_thru_pair_why(m, n)
            pq, why4 = g.get_line_thru_pair_why(p, q)
            
            # Check if any of the segments (lines) are undefined, which might occur in special cases.
            #   - i.e. When the points coincide or are not properly defined.
            if ab is None or cd is None or mn is None or pq is None:
                # Check various conditions to handle the undefined segments.

                # If points a, b are the same as points m, n, then lines cd and pq are considered parallel.
                if {a, b} == {m, n}:
                    d = Dependency('para', [c, d, p, q], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # If points a, b are the same as points c, d, then lines pq and mn are considered parallel.
                if {a, b} == {c, d}:
                    d = Dependency('para', [p, q, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # If points c, d are the same as points p, q, then lines ab and mn are considered parallel.
                if {c, d} == {p, q}:
                    d = Dependency('para', [a, b, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # If points p, q are the same as points m, n, then lines ab and cd are considered parallel.
                if {p, q} == {m, n}:
                    d = Dependency('para', [a, b, c, d], None, level)
                    self.why = [d.why_me_or_cache(g, level)]

                # Return early from the function as the dependencies have been resolved.
                return

            # If the segments are defined, iterate over each pair of points and the corresponding lines.
            for (x, y), xy, whyxy in zip(
                    [(a, b), (c, d), (m, n), (p, q)],
                    [ab, cd, mn, pq],
                    [why1, why2, why3, why4],
            ):
                x_, y_ = xy.points  # Extract the actual points that define the line xy.

                # If the given pair of points (x, y) doesn't match the points (x_, y_) defining the line.
                #   - This indicates an indirect or extended collinearity ('collx').
                if {x, y} != {x_, y_}:
                    # Create a Dependency object for this collinearity case.
                    d = Dependency('collx', [x, y, x_, y_], None, level)
                    d.why = whyxy  # Assign the reasons for this dependency.
                    self.why += [d]  # Add this dependency to the 'why' list.

            # After handling all pairs, extract the actual points for each line.
            a, b = ab.points
            c, d = cd.points
            m, n = mn.points
            p, q = pq.points

            # Check if the hashed representation of the current dependency differs from the hashed representation of the points. 
            #   - This check is necessary to ensure consistency in the representation and naming of points.
            diff = hashed(self.name, [a, b, c, d, m, n, p, q]) != self.hashed()

            # Initialize variable to hold reasons for equal angles.
            whyeqangle = None

            # Check if all the line segments have valid values.
            if ab._val and cd._val and mn._val and pq._val:
                # If so, determine the reasons for equal angles between these segments.
                whyeqangle = why_eqangle(ab._val, cd._val, mn._val, pq._val, level)

            # If reasons for equal angles exist:
            if whyeqangle:
                # Unpack the reasons and the dependencies they are associated with.
                (dab, dcd, dmn, dpq), whyeqangle = whyeqangle

                # Check if there's a discrepancy in the hashed representation.
                if diff:
                    # If so, create a new dependency that accurately reflects the current points.
                    d = Dependency('eqangle', [a, b, c, d, m, n, p, q], None, level)
                    d.why = whyeqangle  # Assign the reasons to this new dependency.
                    whyeqangle = [d]    # Update the list of reasons to include this new dependency.

                # Add the reasons for equal angles to the 'why' list.
                self.why += whyeqangle

            # If there are no reasons for equal angles:
            else:
                # Check if any two pairs of lines are identical.
                if (ab == cd and mn == pq) or (ab == mn and cd == pq):
                    # If so, no additional reasons are needed.
                    self.why += []

                # Check various combinations of lines to determine potential reasons for equal angles.
                elif ab == mn:
                    # If lines ab and mn are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        a, b, c, d, m, n, p, q, ab, mn, g, level
                    )
                elif cd == pq:
                    # If lines cd and pq are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        c, d, a, b, p, q, m, n, cd, pq, g, level
                    )
                elif ab == cd:
                    # If lines ab and cd are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        a, b, m, n, c, d, p, q, ab, cd, g, level
                    )
                elif mn == pq:
                    # If lines mn and pq are equal, generate reasons for equal pairs of points.
                    self.why += maybe_make_equal_pairs(
                        m, n, a, b, p, q, c, d, mn, pq, g, level
                    )

                # Check if the lines (ab w/ mn and cd w/ pq) are parallel based on equal angle conditions.
                elif g.is_equal(ab, mn) or g.is_equal(cd, pq):
                    # Create a new Dependency object for parallelism between lines ab and mn.
                    dep1 = Dependency('para', [a, b, m, n], None, level)
                    # Determine the reasons why lines ab and mn are parallel.
                    dep1.why_me(g, level)
                    # Create another Dependency object for parallelism between lines cd and pq.
                    dep2 = Dependency('para', [c, d, p, q], None, level)
                    # Determine the reasons why lines cd and pq are parallel.
                    dep2.why_me(g, level)
                    # Add these dependencies to the 'why' list of the current dependency.
                    self.why += [dep1, dep2]

                # Similar check for parallelism between ab & cd and mn & pq.
                elif g.is_equal(ab, cd) or g.is_equal(mn, pq):
                    # Create a new Dependency object for parallelism between lines ab and cd.
                    dep1 = Dependency('para', [a, b, c, d], None, level)
                    # Determine the reasons why lines ab and cd are parallel.
                    dep1.why_me(g, level)
                    # Create another Dependency object for parallelism between lines mn and pq.
                    dep2 = Dependency('para', [m, n, p, q], None, level)
                    # Determine the reasons why lines mn and pq are parallel.
                    dep2.why_me(g, level)
                    # Add these dependencies to the 'why' list of the current dependency.
                    self.why += [dep1, dep2]

                # If all line segments have valid values
                elif ab._val and cd._val and mn._val and pq._val:
                    # Check for reasons of equal angles.
                    self.why = why_eqangle(ab._val, cd._val, mn._val, pq._val, level)
        
        # We now handle cases where the geometric construction involves checking equality of ratios (eqratio or eqratio6). 
        #   - This is a part of geometric reasoning that looks into the relationships between different segments.
        elif self.name in ['eqratio', 'eqratio6']:
            # Extracting the points that define the segments for ratio comparison.
            a, b, c, d, m, n, p, q = self.args

            # Getting the segments ab, cd, mn, pq from the geometry context 'g'.
            ab = g._get_segment(a, b)
            cd = g._get_segment(c, d)
            mn = g._get_segment(m, n)
            pq = g._get_segment(p, q)

            # Check if any of these segments are undefined, possibly due to overlapping points.
            if ab is None or cd is None or mn is None or pq is None:
                # If any pair of points defining a segment are the same, then we are looking at congruence, not ratio.
                if {a, b} == {m, n}:
                    # Create a congruence dependency and find its reasoning.
                    d = Dependency('cong', [c, d, p, q], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                # Similar checks for other combinations of points.
                if {a, b} == {c, d}:
                    d = Dependency('cong', [p, q, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                if {c, d} == {p, q}:
                    d = Dependency('cong', [a, b, m, n], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                if {p, q} == {m, n}:
                    d = Dependency('cong', [a, b, c, d], None, level)
                    self.why = [d.why_me_or_cache(g, level)]
                return  # Exit if any segments are undefined.

            # If all segments are well-defined, check if their ratios are equal.
            if ab._val and cd._val and mn._val and pq._val:
                self.why = why_eqratio(ab._val, cd._val, mn._val, pq._val, level)

            # If no specific reason for equal ratios is found, explore other possibilities.
            if self.why is None:
                self.why = []  # Initialize an empty list for reasons.

                # Check for direct equality of segments which would imply equal ratios.
                if (ab == cd and mn == pq) or (ab == mn and cd == pq):
                    self.why += []  # No additional dependencies are needed in this case.
                elif ab == mn:
                    # If segments ab and mn are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(a, b, c, d, m, n, p, q, ab, mn, g, level)
                elif cd == pq:
                    # If segments cd and pq are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(c, d, a, b, p, q, m, n, cd, pq, g, level)
                elif ab == cd:
                    # If segments ab and cd are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(a, b, m, n, c, d, p, q, ab, cd, g, level)
                elif mn == pq:
                    # If segments mn and pq are equal, explore reasons for their equality and add to 'why'.
                    self.why += maybe_make_equal_pairs(m, n, a, b, p, q, c, d, mn, pq, g, level)

                # Check if segments are parallel as a possible reason for equal ratios.
                if g.is_equal(ab, mn) or g.is_equal(cd, pq):
                    # Create and resolve dependencies for parallel lines (ab//mn or cd//pq).
                    dep1 = Dependency('para', [a, b, m, n], None, level)
                    dep1.why_me(g, level)
                    dep2 = Dependency('para', [c, d, p, q], None, level)
                    dep2.why_me(g, level)
                    self.why += [dep1, dep2]
                if g.is_equal(ab, cd) or g.is_equal(mn, pq):
                    # Create and resolve dependencies for parallel lines (ab//cd or mn//pq).
                    dep1 = Dependency('para', [a, b, c, d], None, level)
                    dep1.why_me(g, level)
                    dep2 = Dependency('para', [m, n, p, q], None, level)
                    dep2.why_me(g, level)
                    self.why += [dep1, dep2]

                # Finally, if all else fails, re-check for equal angles as a last resort.
                if ab._val and cd._val and mn._val and pq._val:
                    self.why = why_eqangle(ab._val, cd._val, mn._val, pq._val, level)

        # These are different types of geometric dependencies.
        elif self.name in ['diff', 'npara', 'nperp', 'ncoll', 'sameside']:
            # For these types, currently, no additional dependencies are determined.
            #   - This might represent cases where the dependency is either direct or not yet implemented.
            self.why = []

        # Handling the case of similar triangles.
        elif self.name == 'simtri':
            # Extracts the points defining the two triangles.
            a, b, c, x, y, z = self.args

            # Creates a dependency for equal angles between the two triangles.
            #   - i.e. angle at 'a' in the first triangle should be equal to the angle at 'x' in the second triangle.
            dep1 = Dependency('eqangle', [a, b, a, c, x, y, x, z], '', level)
            dep1.why_me(g, level)  # Determines why these angles are equal.

            # Similarly, this checks for equality of another pair of angles.
            dep2 = Dependency('eqangle', [b, a, b, c, y, x, y, z], '', level)
            dep2.why_me(g, level)

            # Assigns a rule name for this type of dependency.
            self.rule_name = 'r34'

            # Records these dependencies.
            self.why = [dep1, dep2]

        # Handling the case of congruent triangles.
        elif self.name == 'contri':
            # Extracts the points defining the two triangles.
            a, b, c, x, y, z = self.args

            # Checks for congruence (equality of length) between corresponding sides (ab w/ xy) of the triangles.
            dep1 = Dependency('cong', [a, b, x, y], '', level)
            # Determines why these segments (ab w/ xy) are congruent.
            dep1.why_me(g, level)  
            
            # Checks for congruence (equality of length) between corresponding sides (bc w/ yz) of the triangles.
            dep2 = Dependency('cong', [b, c, y, z], '', level)
            # Determines why these segments (bc w/ yz) are congruent.
            dep2.why_me(g, level)
            
            # Checks for congruence (equality of length) between corresponding sides (ca w/ zx) of the triangles.
            dep3 = Dependency('cong', [c, a, z, x], '', level)
            # Determines why these segments (ca w/ zx) are congruent.
            dep3.why_me(g, level)

            # Assigns a rule name for this type of dependency.
            self.rule_name = 'r32'

            # Records these dependencies.
            self.why = [dep1, dep2, dep3]

        # This case represents 'independence'. 
        #   - This appears to be a placeholder for dependencies that don't need further explanation or are considered axiomatic.
        elif self.name == 'ind':
            # No action is taken for 'independent' dependencies.
            pass  

        # Handling the case for a constant angle.
        elif self.name == 'aconst':
            # Extracts points and the angle of interest.
            a, b, c, d, ang0 = self.args

            # Gets the value of the angle.
            measure = ang0._val

            # Iterates over angles neighboring the given angle in the geometric context.
            for ang in measure.neighbors(gm.Angle):
                
                # Skips this angle if it's the same angle as the original.
                if ang == ang0:
                    continue  

                # Extracts line objects from the neighboring angle.
                d1, d2 = ang._d
                l1, l2 = d1._obj, d2._obj
                (a1, b1), (c1, d1) = l1.points, l2.points

                # Checks if lines are parallel or collinear.
                #   - If not than we skip this angle
                if not g.check_para_or_coll([a, b, a1, b1]) or not g.check_para_or_coll([c, d, c1, d1]):
                    continue

                # Clears previous reasons, preparing to record new ones.
                self.why = []

                # For each set of arguments, checks if they are collinear.
                for args in [(a, b, a1, b1), (c, d, c1, d1)]:
                    if g.check_coll(args):
                        # If they are collinear and involve more than two unique points
                        if len(set(args)) > 2:
                            dep = Dependency('coll', args, None, None)
                            # A collinearity dependency is added.
                            self.why.append(dep.why_me_or_cache(g, level))
                    else:
                        # If they are not collinear
                        dep = Dependency('para', args, None, None)
                        # a parallel dependency is added.
                        self.why.append(dep.why_me_or_cache(g, level))

                # Adds reasons explaining the equality of the given angle with its neighboring angles.
                self.why += gm.why_equal(ang, ang0)
                
                # Exits after processing the first relevant angle.
                break  

        # Handling the case for a constant ratio.
        elif self.name == 'rconst':
            # Extracts points and the ratio of interest.
            a, b, c, d, rat0 = self.args

            # Gets the value of the ratio.
            val = rat0._val

            # Iterates over ratios neighboring the given ratio in the geometric context.
            for rat in val.neighbors(gm.Ratio):
                
                # If this ratio is the same ratio as the original we skip it
                if rat == rat0:
                    continue  

                # Extracts line objects from the neighboring ratio.
                l1, l2 = rat._l
                s1, s2 = l1._obj, l2._obj
                (a1, b1), (c1, d1) = list(s1.points), list(s2.points)

                # Checks if corresponding segments are congruent
                #   - If not, then we skip this ratio
                if not g.check_cong([a, b, a1, b1]) or not g.check_cong([c, d, c1, d1]):
                    continue  

                # Clears previous reasons, preparing to record new ones.
                self.why = []

                # For each set of arguments
                for args in [(a, b, a1, b1), (c, d, c1, d1)]:
                    if len(set(args)) > 2:
                        dep = Dependency('cong', args, None, None)
                        # Add a congruency dependency
                        self.why.append(dep.why_me_or_cache(g, level))

                # Adds reasons explaining the equality of the given ratio with its neighboring ratios.
                self.why += gm.why_equal(rat, rat0)
                
                # Exits after processing the first relevant ratio.
                break  

        # This case handles unrecognized dependency names.
        else:
            # Raises an error if the dependency name is not recognized.
            raise ValueError('Not recognized', self.name)


    def hashed(self, rename: bool = False) -> tuple[str, ...]:
        """"""
        Creates a hash-like tuple representation for the Dependency object.

        Args:
            rename (bool, optional): If True, use alternative names for the points.

        Returns:
            tuple[str, ...]: A tuple representing the hashed value of the dependency.

        Example Usage:
            >>> dep = Dependency('line', [Point('A'), Point('B')], 'rule1', 1)
            >>> dep.hashed()
            ('line', 'A', 'B')

        Note:
            This method is used for caching and identifying unique dependencies.
        """"""
        
        # Utilize the hashed function to create the tuple.
        return hashed(self.name, self.args, rename=rename)  
    

class EmptyDependency:
    """"""
    Represents an initially empty geometric dependency that can be filled and extended.

    This class is used as a starting point for constructing more complex dependencies in geometric reasoning.
    It allows for incremental building up of a dependency from simpler components.

    Attributes:
        level (int): The level of complexity or derivation for the dependency.
        rule_name (str): Name of the rule associated with the dependency, if any.
        empty (bool): A flag indicating whether the dependency is empty.
        why (list[Dependency]): A list of Dependency objects that this one depends on.
        trace (Any): Optional attribute for debugging or tracing the dependency.

    Methods:
        populate: Fills the empty dependency with details.
        copy: Creates a deep copy of the empty dependency.
        extend: Adds a new dependency to the list.
        extend_many: Adds multiple new dependencies to the list.
    """"""

    def __init__(self, level: int, rule_name: str):
        """"""
        Initializes an EmptyDependency object.

        Args:
            level (int): The complexity level for the dependency.
            rule_name (str): The rule name associated with this dependency, if applicable.

        The object starts with no dependencies (empty list) and is marked as empty.
        """"""
        # Complexity level of the dependency.
        self.level = level  
        
        # Rule name, defaulting to an empty string if not provided.
        self.rule_name = rule_name or ''  
        
        # Initially marked as empty.
        self.empty = True  
        
        # Initializes with no dependencies.
        self.why = []  
        
        # Optional tracing information, initially None.
        self.trace = None  

    def populate(self, name: str, args: list[gm.Point]) -> Dependency:
        """"""
        Populates the current empty dependency with a specific dependency.

        Args:
            name (str): The name of the dependency to be populated with.
            args (list[gm.Point]): The points or elements involved in the dependency.

        Returns:
            Dependency: A Dependency object populated with the given details.

        Example Usage:
            >>> empty_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> populated_dep = empty_dep.populate('line', [Point('A'), Point('B')])
            # populated_dep is now a Dependency object representing a line with points 'A', 'B'.
        """"""
        
        # Create the dependency from the provided information
        dep = Dependency(name, args, self.rule_name, self.level)
        
        # Inherit trace information from the empty dependency.
        dep.trace2 = self.trace  
        
        # Copies the 'why' list to the new dependency.
        dep.why = list(self.why)  
    
        return dep

    def copy(self) -> EmptyDependency:
        """"""
        Creates a deep copy of the current EmptyDependency object.

        Returns:
            EmptyDependency: A new EmptyDependency object that is a copy of the current one.

        Example Usage:
            >>> original_empty_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> copied_empty_dep = original_empty_dep.copy()
            # copied_empty_dep is a separate instance with the same data as original_empty_dep.
        """"""
        
        # Initialize a new EmptyDependency
        other = EmptyDependency(self.level, self.rule_name)
        
        # Maps the 'why' over to the new EmptyDependency
        other.why = list(self.why)  
        
        return other

    def extend(
            self,
            g: Any,
            name0: str,
            args0: list[gm.Point],
            name: str,
            args: list[gm.Point],
    ) -> EmptyDependency:
        """"""
        Extends the current dependency with a new one.

        This method adds a new dependency to the existing list of dependencies.

        Args:
            g (Any): The geometric context or environment.
            name0 (str): The name of the initial dependency.
            args0 (list[gm.Point]): The points involved in the initial dependency.
            name (str): The name of the new dependency to be added.
            args (list[gm.Point]): The points involved in the new dependency.

        Returns:
            EmptyDependency: An updated EmptyDependency object with the new dependency added.

        Example Usage:
            >>> current_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> extended_dep = current_dep.extend(geometry_context, 'line', [Point('A'), Point('B')], 'para', [Point('C'), Point('D')])
            # extended_dep now includes dependencies for a line (AB) and parallelism (CD).
        """"""
        # Populates the current dependency with the initial dependency details.
        dep0 = self.populate(name0, args0)
        
        # Creates a new EmptyDependency object.
        deps = EmptyDependency(level=self.level, rule_name=None)
        
        # Adds the new dependency to the list.
        dep = Dependency(name, args, None, deps.level)
        deps.why = [dep0, dep.why_me_or_cache(g, None)]
        
        return deps

    def extend_many(
            self,
            g: Any,
            name0: str,
            args0: list[gm.Point],
            name_args: list[tuple[str, list[gm.Point]]],
    ) -> EmptyDependency:
        """"""
        Extends the current dependency with multiple new dependencies.

        This method allows adding several new dependencies at once.

        Args:
            g (Any): The geometric context or environment.
            name0 (str): The name of the initial dependency.
            args0 (list[gm.Point]): The points involved in the initial dependency.
            name_args (list[tuple[str, list[gm.Point]]]): A list of tuples, each containing a dependency name and its associated points.

        Returns:
            EmptyDependency: An updated EmptyDependency object with the new dependencies added.

        Example Usage:
            >>> current_dep = EmptyDependency(level=1, rule_name='some_rule')
            >>> name_args = [('para', [Point('C'), Point('D')]), ('coll', [Point('E'), Point('F')])]
            >>> extended_dep = current_dep.extend_many(geometry_context, 'line', [Point('A'), Point('B')], name_args)
            # extended_dep now includes dependencies for a line (AB), parallelism (CD), and collinearity (EF).
        """"""
        # Return the current dependency if no new dependencies are provided.
        if not name_args:
            return self

        # Populates the current dependency with the initial dependency details.
        dep0 = self.populate(name0, args0)
        
        # Creates a new EmptyDependency object.
        deps = EmptyDependency(level=self.level, rule_name=None)
        
        # Adds the initial dependency to the list.
        deps.why = [dep0]

        # Iterates over each new dependency and adds them to the list along with the 'why'
        for name, args in name_args:
            dep = Dependency(name, args, None, deps.level)
            deps.why += [dep.why_me_or_cache(g, None)]
        
        return deps
def why_eqratio(
        d1: gm.Direction,
        d2: gm.Direction,
        d3: gm.Direction,
        d4: gm.Direction,
        level: int,
) -> list[Dependency]:
    """"""Determines the reasons for equality of two geometric ratios.

    This function is used in the context of geometric reasoning to explain why two ratios, 
    formed by pairs of directions, are equal. It explores all combinations of equivalent ratios 
    and finds the minimal explanation for their equality.

    Args:
        d1 (gm.Direction): The first direction in the first ratio.
        d2 (gm.Direction): The second direction in the first ratio.
        d3 (gm.Direction): The first direction in the second ratio.
        d4 (gm.Direction): The second direction in the second ratio.
        level (int): The level of abstraction for the reasoning.

    Returns:
        list[Dependency]: A list of Dependency objects representing the reasons for the equality of the two ratios.

    Example Usage:
        # Assuming d1, d2, d3, d4 are gm.Direction instances and 'level' is set.
        >>> reasons = why_eqratio(d1, d2, d3, d4, level)
    """"""
    
    # Generate all possible equivalent ratios for the first and second pairs of directions.
    all12 = list(gm.all_ratios(d1, d2, level))
    all34 = list(gm.all_ratios(d3, d4, level))

    # Initialize a variable to keep track of the minimal explanation for ratio equality.
    min_why = None

    # Iterate through each combination of equivalent ratios from the first and second pairs.
    for ang12, d1s, d2s in all12:
        for ang34, d3s, d4s in all34:
            
            # Check if these two ratios are equal and if so why
            why0 = gm.why_equal(ang12, ang34, level)
            
            # Skip to the next combination if these two are not equal.
            if why0 is None:
                continue
            
            # Get the directions involved in the ratios
            d1_, d2_ = ang12._l
            d3_, d4_ = ang34._l
            
            # Backtrack to find the path of dependencies for each direction involved in the ratios.
            why1 = gm.bfs_backtrack(d1, [d1_], d1s)
            why2 = gm.bfs_backtrack(d2, [d2_], d2s)
            why3 = gm.bfs_backtrack(d3, [d3_], d3s)
            why4 = gm.bfs_backtrack(d4, [d4_], d4s)

            # Compile all reasons (dependencies) for the equality of these ratios.
            why = why0 + why1 + why2 + why3 + why4

            # Update the minimal explanation if the current explanation is more concise.
            if min_why is None or len(why) < len(min_why[0]):
                min_why = why, ang12, ang34, why0, why1, why2, why3, why4

    # If no explanation is found, return None.
    if min_why is None:
        return None

    # Extract from the minimal explanation the involved dependancies (whys), angles and directions.
    _, ang12, ang34, why0, why1, why2, why3, why4 = min_why

    # If the original and compared directions are the same, return the reasons for their equality.
    d1_, d2_ = ang12._l
    d3_, d4_ = ang34._l
    if d1 == d1_ and d2 == d2_ and d3 == d3_ and d4 == d4_:
        return why0

    # Extract the points for each direction to create dependencies.
    (a_, b_), (c_, d_) = d1_._obj.points, d2_._obj.points
    (e_, f_), (g_, h_) = d3_._obj.points, d4_._obj.points
    
    # Initialize the list of dependencies
    deps = []

    # If reasons for equality exist, create and append a Dependency object.
    if why0:
        dep = Dependency('eqratio', [a_, b_, c_, d_, e_, f_, g_, h_], '', level)
        dep.why = why0
        deps.append(dep)

    # Iterate through each set of points and append necessary dependencies (congruent).
    (a, b), (c, d) = d1._obj.points, d2._obj.points
    (e, f), (g, h) = d3._obj.points, d4._obj.points
    for why, (x, y), (x_, y_) in zip(
            [why1, why2, why3, why4],                 # reason (or None)
            [(a, b), (c, d), (e, f), (g, h)],         # pair of points (1)
            [(a_, b_), (c_, d_), (e_, f_), (g_, h_)], # pair of points (2)
    ):
        if why:
            dep = Dependency('cong', [x, y, x_, y_], '', level)
            dep.why = why
            deps.append(dep)

    # Return the list of dependencies explaining the equality of the ratios.
    return deps


def why_eqangle(
        d1: gm.Direction,
        d2: gm.Direction,
        d3: gm.Direction,
        d4: gm.Direction,
        level: int,
        verbose: bool = False,
) -> list[Dependency]:
    """"""Determines the reasons for equality of two geometric angles.

    This function explains why two angles, formed by pairs of directions, are equal.
    It compares all combinations of equivalent angles and determines the minimal
    explanation for their equality.

    Args:
        d1, d2 (gm.Direction): Directions forming the first angle.
        d3, d4 (gm.Direction): Directions forming the second angle.
        level (int): The level of abstraction for the reasoning.
        verbose (bool, optional): If true, provides more detailed explanation. Defaults to False.

    Returns:
        list[Dependency]: A list of Dependency objects representing the reasons for the equality of the two angles.

    Example Usage:
        # Assuming d1, d2, d3, d4 are gm.Direction instances and 'level' is set.
        >>> reasons = why_eqangle(d1, d2, d3, d4, level)
    """"""
    # Generate all possible equivalent angles for the first and second pairs of directions.
    all12 = list(gm.all_angles(d1, d2, level))
    all34 = list(gm.all_angles(d3, d4, level))

    # Initialize a variable to keep track of the minimal explanation for angle equality.
    min_why = None

    # Iterate through each combination of equivalent angles from the first and second pairs.
    for ang12, d1s, d2s in all12:
        for ang34, d3s, d4s in all34:
            # Check if these two angles are equal.
            why0 = gm.why_equal(ang12, ang34, level)
            # Skip to the next combination if these two are not equal.
            if why0 is None:
                continue

            # Backtrack to find the path of dependencies for each direction involved in the angles.
            d1_, d2_ = ang12._d
            d3_, d4_ = ang34._d
            why1 = gm.bfs_backtrack(d1, [d1_], d1s)
            why2 = gm.bfs_backtrack(d2, [d2_], d2s)
            why3 = gm.bfs_backtrack(d3, [d3_], d3s)
            why4 = gm.bfs_backtrack(d4, [d4_], d4s)

            # Compile all reasons (dependencies) for the equality of these angles.
            why = why0 + why1 + why2 + why3 + why4

            # Update the minimal explanation if the current explanation is more concise.
            if min_why is None or len(why) < len(min_why[0]):
                min_why = why, ang12, ang34, why0, why1, why2, why3, why4

    # If no explanation is found, return None.
    if min_why is None:
        return None

    # Extract from the minimal explanation the involved dependancies (whys), angles and directions.
    _, ang12, ang34, why0, why1, why2, why3, why4 = min_why
    why0 = gm.why_equal(ang12, ang34, level)
    d1_, d2_ = ang12._d
    d3_, d4_ = ang34._d

    # If the original and compared directions are the same, return the reasons for their equality.
    if d1 == d1_ and d2 == d2_ and d3 == d3_ and d4 == d4_:
        return (d1_, d2_, d3_, d4_), why0

    # Extract the points for each direction to create dependencies.
    (a_, b_), (c_, d_) = d1_._obj.points, d2_._obj.points
    (e_, f_), (g_, h_) = d3_._obj.points, d4_._obj.points
    deps = []

    # If reasons for equality exist, create and append a Dependency object.
    if why0:
        dep = Dependency('eqangle', [a_, b_, c_, d_, e_, f_, g_, h_], '', None)
        dep.why = why0
        deps.append(dep)

    # Iterate through each set of points and append necessary dependencies.
    # We are iterating over a combined sequence of various elements:
    #   1. 'why1' to 'why4' are the reasons for the equality of the directions.
    #   2. 'd1' to 'd4' are the original direction objects.
    #   3. '(a, b)' to '(g, h)' are point pairs defining the original directions.
    #   4. 'd1_' to 'd4_' are the resultant direction objects after backtracking.
    #   5. '(a_, b_)' to '(g_, h_)' are point pairs defining the resultant directions.

    (a, b), (c, d) = d1._obj.points, d2._obj.points
    (e, f), (g, h) = d3._obj.points, d4._obj.points
    for why, d_xy, (x, y), d_xy_, (x_, y_) in zip(
            [why1, why2, why3, why4],
            [d1, d2, d3, d4],
            [(a, b), (c, d), (e, f), (g, h)],
            [d1_, d2_, d3_, d4_],
            [(a_, b_), (c_, d_), (e_, f_), (g_, h_)],
    ):
        # Extract the actual line (or segment) objects associated with the directions.
        xy, xy_ = d_xy._obj, d_xy_._obj

        # Check if there are valid reasons ('why') for the equality of directions.
        if why:
            # Determine the type of geometric relationship:
            #   - If the original and resultant lines (segments) are the same, we use 'collx'.
            #     - 'collx' implies an extended collinearity
            #   - Otherwise, we infer that they are parallel, using 'para'.
            #     - 'para' implies parallelism.
            if xy == xy_:
                name = 'collx'
            else:
                name = 'para'

            # Create a Dependency object to encapsulate this geometric relationship.
            #   - The Dependency object takes:
            #     - the name ('collx' or 'para')
            #     - the points involved,
            #     - an empty string for the rule name
            #     - and the level of abstraction.
            dep = Dependency(name, [x_, y_, x, y], '', None)

            # Assign the reasons ('why') to this Dependency object.
            dep.why = why

            # Append the Dependency object to the list of dependencies ('deps').
            deps.append(dep)

    # Return the list of dependencies explaining the equality of the angles.
    return (d1_, d2_, d3_, d4_), deps

# This constant represents a default rule name used in the context of geometric dependencies. 
#   - It's a placeholder/identifier for a basic rule in the geometric reasoning system.
CONSTRUCTION_RULE = 'c0'


def maybe_make_equal_pairs(
        a: gm.Point,
        b: gm.Point,
        c: gm.Point,
        d: gm.Point,
        m: gm.Point,
        n: gm.Point,
        p: gm.Point,
        q: gm.Point,
        ab: gm.Line,
        mn: gm.Line,
        g: Any,
        level: int,
) -> list[Dependency]:
    """"""Generates dependencies if certain line pairs are equal.

    This function creates dependencies based on the equality of geometric lines.
    It's used in geometric reasoning to infer dependencies from equal line segments or directions.

    Args:
        a, b, c, d, m, n, p, q (gm.Point): Points involved in the line segments.
        ab, mn (gm.Line): Line segments or directions to compare for equality.
        g (Any): Geometric context or environment.
        level (int): The level of abstraction for reasoning.

    Returns:
        list[Dependency]: A list of dependencies if the line pairs are equal, otherwise an empty list.

    Example Usage:
        # Assuming the points and lines are defined and 'level' is set.
        >>> dependencies = maybe_make_equal_pairs(a, b, c, d, m, n, p, q, ab, mn, g, level)
        
    Notes:
        Make a-b:c-d==m-n:p-q in case a-b==m-n or c-d==p-q.
    """"""
    if ab != mn:
        return
    why = []
    eqname = 'para' if isinstance(ab, gm.Line) else 'cong'
    colls = [a, b, m, n]
    if len(set(colls)) > 2 and eqname == 'para':
        dep = Dependency('collx', colls, None, level)
        dep.why_me(g, level)
        why += [dep]

    dep = Dependency(eqname, [c, d, p, q], None, level)
    dep.why_me(g, level)
    why += [dep]
    return why

def compare_fn(dep: Dependency) -> tuple[Dependency, str]:
    """"""A helper function for sorting dependencies.

    This function is used as a key function in sorting dependencies. It creates a tuple
    from a dependency and its string representation, used for comparison.

    Args:
        dep (Dependency): A dependency object.

    Returns:
        tuple[Dependency, str]: A tuple with the dependency and its string representation.

    Example Usage:
        # Assuming 'deps' is a list of Dependency objects.
        >>> sorted_deps = sorted(deps, key=compare_fn)
    """"""
    return (dep, pt.pretty(dep))


def sort_deps(deps: list[Dependency]) -> list[Dependency]:
    """"""Sorts a list of Dependency objects.

    This function sorts dependencies based on a custom sorting function, `compare_fn`.
    It's useful for organizing or prioritizing dependencies in geometric reasoning.

    Args:
        deps (list[Dependency]): A list of Dependency objects.

    Returns:
        list[Dependency]: A sorted list of Dependency objects.

    Example Usage:
        # Assuming 'deps' is a list of Dependency objects.
        >>> sorted_deps = sort_deps(deps)
    """"""
    return sorted(deps, key=compare_fn)
# Copyright 2023 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

""""""Numerical representation of geometry.""""""
from __future__ import annotations

import math
from typing import Any, Optional, Union

import matplotlib
import matplotlib.colors as mcolors
import numpy as np
from matplotlib import pyplot as plt
from numpy.random import uniform as unif  # pylint: disable=g-importing-member

# import geometry as gm

# WE USE Agg instead of TkAgg due to Kaggle limitations
matplotlib.use('Agg')

HCOLORS = None
THEME = 'dark'
class InvalidLineIntersectError(Exception):
    """"""Exception raised for errors in the intersection of lines.""""""
    pass


class InvalidQuadSolveError(Exception):
    """"""Exception raised for errors in solving quadratic equations.""""""
    pass

ATOM = 1e-12
class Point:
    """"""
    Represents a point in 2D space with x and y coordinates.
    
    Methods are defined to allow for common geometric operations such as addition,
    subtraction, and comparison of points, as well as calculating distance, midpoint, etc.
    
    Attributes:
        x (float): The x-coordinate of the point.
        y (float): The y-coordinate of the point.

    Methods:
        __lt__: Check if this point is 'less than' another point based on their coordinates.
        __gt__: Check if this point is 'greater than' another point based on their coordinates.
        __add__: Add two points by adding their respective coordinates.
        __sub__: Subtract the coordinates of another point from this point.
        __mul__: Multiply the coordinates of this point by a scalar.
        __rmul__: Right multiplication of the point by a scalar. Enables scalar-point multiplication.
        __truediv__: Divide the coordinates of this point by a scalar.
        __floordiv__: Floor division of the point's coordinates by a scalar.
        __str__: String representation of the point in the format ""P(x,y)"".
        close: Check if this point is close to another point within a specified tolerance.
        distance: Calculate the distance from this point to another point, line, or circle.
        midpoint: Calculate the midpoint between this point and another point.
        distance2: Calculate the squared Euclidean distance from this point to another point.
        rotatea: Rotate this point around the origin by a given angle.
        rotate: Rotate this point around the origin using precomputed sine and cosine values.
        flip: Flip the point across the y-axis (mirror in the x-direction).
        perpendicular_line: Create a line perpendicular to a given line that passes through this point.
        foot: Find the foot of the perpendicular from this point to a line or circle.
        parallel_line: Create a line parallel to a given line that passes through this point.
        norm: Calculate the Euclidean norm (magnitude) of the point.
        cos: Calculate the cosine of the angle between this point and another point when both are treated as vectors from the origin.
        dot: Calculate the dot product of this point with another point.
        sign: Determine the sign of this point relative to a line.
        is_same: Check if this point is the same as another point, within a small tolerance.
    """"""

    def __init__(self, x, y):
        """"""
        Initialize a point with x and y coordinates.

        Args:
            x (float): The x-coordinate of the point.
            y (float): The y-coordinate of the point.
        """"""
        self.x = x
        self.y = y
    
    def __lt__(self, other: 'Point') -> bool:
        """"""
        Check if this point is 'less than' another point. 
        
        Comparison is first done on the x-coordinate
        Only if the x-coords are the same will the comparison continue to the y-coord

        Args:
            other (Point): The point to compare against.

        Returns:
            bool: True if this point is less than the other point, False otherwise.

        Example:
            >>> Point(1, 2) < Point(2, 1)
            True
        """"""
        return (self.x, self.y) < (other.x, other.y)
    
    
    def __gt__(self, other: 'Point') -> bool:
        """"""
        Check if this point is 'greater than' another point. 
        
        Comparison is first done on the x-coordinate, then the y-coordinate.
        Only if the x-coords are the same will the comparison continue to the y-coord

        Args:
            other (Point): The point to compare against.

        Returns:
            bool: True if this point is greater than the other point, False otherwise.

        Example:
            >>> Point(3, 4) > Point(2, 5)
            True
        """"""
        return (self.x, self.y) > (other.x, other.y)

    def __add__(self, p: Point) -> Point:
        """"""
        Add two points by adding their respective coordinates.

        Args:
            p (Point): Another point to add.

        Returns:
            Point: A new point resulting from the coordinate-wise addition.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(3, 4)
            >>> print(p1 + p2)
            P(4,6)
        """"""
        return Point(self.x + p.x, self.y + p.y)
    
    def __sub__(self, p: 'Point') -> 'Point':
        """"""
        Subtract the coordinates of another point from this point.

        Args:
            p (Point): The point to subtract.

        Returns:
            Point: A new point resulting from the coordinate-wise subtraction.

        Example:
            >>> p1 = Point(5, 4)
            >>> p2 = Point(2, 2)
            >>> print(p1 - p2)
            P(3,2)
        """"""
        return Point(self.x - p.x, self.y - p.y)
    
    def __mul__(self, f: float) -> 'Point':
        """"""
        Multiply the coordinates of this point by a scalar.

        Args:
            f (float): The scalar to multiply by.

        Returns:
            Point: A new point with coordinates scaled by the scalar.

        Example:
            >>> p = Point(1, 2)
            >>> print(p * 3)
            P(3,6)
        """"""
        return Point(self.x * f, self.y * f)
    
    def __rmul__(self, f: float) -> 'Point':
        """"""
        Right multiplication of the point by a scalar. Enables scalar-point multiplication.

        Args:
            f (float): The scalar to multiply by.

        Returns:
            Point: A new point with coordinates scaled by the scalar.

        Example:
            >>> p = Point(1, 2)
            >>> print(3 * p)
            P(3,6)
        """"""
        return self * f

    def __truediv__(self, f: float) -> 'Point':
        """"""
        Divide the coordinates of this point by a scalar.

        Args:
            f (float): The scalar to divide by.

        Returns:
            Point: A new point with coordinates divided by the scalar.

        Example:
            >>> p = Point(10, 20)
            >>> print(p / 2)
            P(5.0,10.0)
        """"""
        return Point(self.x / f, self.y / f)
    
    def __floordiv__(self, f: float) -> 'Point':
        """"""
        Floor division of the point's coordinates by a scalar.

        Args:
            f (float): The scalar to divide by.

        Returns:
            Point: A new point with coordinates floor-divided by the scalar.

        Example:
            >>> p = Point(10, 20)
            >>> print(p // 3)
            P(3,6)
        """"""
        div = self / f  # true division
        return Point(int(div.x), int(div.y))
    
    def __str__(self) -> str:
        """"""
        String representation of the point in the format ""P(x,y)"".

        Returns:
            str: The string representation.

        Example:
            >>> p = Point(1, 2)
            >>> str(p)
            'P(1,2)'
        """"""
        return 'P({},{})'.format(self.x, self.y)

    def close(self, point: 'Point', tol: float = ATOM) -> bool:
        """"""
        Check if this point is close to another point within a specified tolerance.

        Args:
            point (Point): The point to compare with.
            tol (float): The tolerance for comparison.

        Returns:
            bool: True if the points are within the specified tolerance, False otherwise.

        Example:
            >>> p1 = Point(1.0000001, 2.0000001)
            >>> p2 = Point(1, 2)
            >>> p1.close(p2)
            True
        """"""
        return abs(self.x - point.x) < tol and abs(self.y - point.y) < tol
    
    def midpoint(self, p: 'Point') -> 'Point':
        """"""
        Calculate the midpoint between this point and another point.

        Args:
            p (Point): The other point.

        Returns:
            Point: The midpoint between the two points.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(3, 4)
            >>> print(p1.midpoint(p2))
            P(2.0,3.0)
        """"""
        return Point(0.5 * (self.x + p.x), 0.5 * (self.y + p.y))
    
    def distance(self, p: Union[Point, Line, Circle]) -> float:
        """"""
        Calculate the Euclidean distance from this point to another geometric object
        (Point, Line, or Circle).

        The method dynamically adjusts its calculation based on the type of the argument:
        - If the argument is a Point, it calculates the direct Euclidean distance.
        - If the argument is a Line, it delegates to the Line's distance method to get
          the shortest distance from the point to the line.
        - If the argument is a Circle, it calculates the distance from the point to the
          Circle's center and adjusts it by the Circle's radius to give the shortest
          distance to the Circle.

        Args:
            p (Union[Point, Line, Circle]): The geometric object to measure distance to.

        Returns:
            float: The Euclidean distance to the object.

        Raises:
            TypeError: If 'p' is not a Point, Line, or Circle.

        Example:
            >>> point = Point(1, 1)
            >>> other_point = Point(4, 5)
            >>> line = Line(Point(0, 0), Point(1, 1))
            >>> circle = Circle(Point(5, 5), 2)
            >>> point.distance(other_point)  # Distance to another point
            5.0
            >>> point.distance(line)  # Perpendicular distance to a line
            0.0
            >>> point.distance(circle)  # Distance to a circle's boundary
            2.8284271247461903
        """"""
        if isinstance(p, Line):
            # Delegates the distance calculation to the Line's method.
            return p.distance(self)
        elif isinstance(p, Circle):
            # Computes the distance to the circle's center and adjusts by the radius.
            return abs(p.radius - self.distance(p.center))
        elif isinstance(p, Point):
            # Standard Euclidean distance formula.
            dx = self.x - p.x
            dy = self.y - p.y
            return np.sqrt(dx * dx + dy * dy)
        else:
            # Raises an error if 'p' is not a recognized geometric object.
            raise TypeError(f""Cannot compute distance to object of type {type(p)}"")

    def distance2(self, p: 'Point') -> float:
        """"""
        Calculate the squared Euclidean distance from this point to another point.
        This is more efficient than `distance` for comparison purposes as it avoids a square root calculation.

        Args:
            p (Point): The other point to measure distance to.

        Returns:
            float: The squared Euclidean distance to the other point.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(4, 6)
            >>> p1.distance2(p2)
            25.0
        """"""
        dx = self.x - p.x
        dy = self.y - p.y
        return dx * dx + dy * dy

    def rotatea(self, ang: float) -> 'Point':
        """"""
        Rotate this point around the origin (0, 0) by a given angle.

        Args:
            ang (float): The angle in radians to rotate.

        Returns:
            Point: A new point rotated around the origin.

        Example:
            >>> p = Point(1, 0)
            >>> print(p.rotatea(np.pi / 2))
            P(0.0,1.0)
        """"""
        sinb, cosb = np.sin(ang), np.cos(ang)
        return self.rotate(sinb, cosb)

    def rotate(self, sinb: float, cosb: float) -> 'Point':
        """"""
        Rotate this point around the origin using precomputed sine and cosine values.

        Args:
            sinb (float): The sine of the angle.
            cosb (float): The cosine of the angle.

        Returns:
            Point: A new point rotated around the origin.

        Example:
            >>> p = Point(1, 0)
            >>> sinb, cosb = np.sin(np.pi / 2), np.cos(np.pi / 2)
            >>> print(p.rotate(sinb, cosb))
            P(0.0,1.0)
        """"""
        x, y = self.x, self.y
        return Point(x * cosb - y * sinb, x * sinb + y * cosb)

    def flip(self) -> 'Point':
        """"""
        Flip the point across the y-axis (mirror in the x-direction).

        Returns:
            Point: A new point mirrored across the y-axis.

        Example:
            >>> p = Point(1, 2)
            >>> print(p.flip())
            P(-1,2)
        """"""
        return Point(-self.x, self.y)

    def perpendicular_line(self, line: 'Line') -> 'Line':
        """"""
        Create a line perpendicular to a given line that passes through this point.

        Args:
            line (Line): The line to which the new line will be perpendicular.

        Returns:
            Line: A new line perpendicular to the given line.

        Note:
            This relies on the `perpendicular_line` method of the `Line` class.
        """"""
        return line.perpendicular_line(self)

    def foot(self, line: Union['Line', 'Circle']) -> 'Point':
        """"""
        Find the foot of the perpendicular from this point to a line or circle.

        Args:
            line (Union[Line, Circle]): The line or circle to drop a perpendicular to.

        Returns:
            Point: The foot of the perpendicular.

        Raises:
            ValueError: If an unsupported type is passed.

        Example:
            >>> p = Point(3, 4)
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> print(p.foot(l))
            P(3.5,3.5)
        """"""
        if isinstance(line, Line):
            l = line.perpendicular_line(self)
            return line_line_intersection(l, line)
        elif isinstance(line, Circle):
            c, r = line.center, line.radius
            return c + (self - c) * r / self.distance(c)
        raise ValueError('Dropping foot to weird type {}'.format(type(line)))

    def parallel_line(self, line: 'Line') -> 'Line':
        """"""
        Create a line parallel to a given line that passes through this point.

        Args:
            line (Line): The line to which the new line will be parallel.

        Returns:
            Line: A new line parallel to the given line.

        Note:
            This relies on the `parallel_line` method of the `Line` class.
        """"""
        return line.parallel_line(self)

    def norm(self) -> float:
        """"""
        Calculate the Euclidean norm (magnitude) of the point.

        Returns:
            float: The Euclidean norm of the point.

        Example:
            >>> p = Point(3, 4)
            >>> p.norm()
            5.0
        """"""
        return np.sqrt(self.x ** 2 + self.y ** 2)

    def cos(self, other: 'Point') -> float:
        """"""
        Calculate the cosine of the angle between this point and another point when
        both are treated as vectors from the origin.

        Args:
            other (Point): The other point.

        Returns:
            float: The cosine of the angle between the two points.

        Example:
            >>> p1 = Point(1, 0)
            >>> p2 = Point(0, 1)
            >>> p1.cos(p2)
            0.0
        """"""
        return (self.x * other.x + self.y * other.y) / self.norm() / other.norm()

    def dot(self, other: 'Point') -> float:
        """"""
        Calculate the dot product of this point with another point.

        Args:
            other (Point): The other point.

        Returns:
            float: The dot product of the two points.

        Example:
            >>> p1 = Point(1, 2)
            >>> p2 = Point(3, 4)
            >>> p1.dot(p2)
            11
        """"""
        return self.x * other.x + self.y * other.y

    def sign(self, line: 'Line') -> int:
        """"""
        Determine the sign of this point relative to a line. Returns 1 if the point is
        on one side of the line, -1 if on the other side, and 0 if on the line.

        Args:
            line (Line): The line to compare against.

        Returns:
            int: The sign (-1, 0, 1) indicating the side of the line this point is on.

        Example:
            >>> p = Point(1, 2)
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p.sign(l)
            1
        """"""
        return line.sign(self)

    def is_same(self, other: 'Point') -> bool:
        """"""
        Check if this point is the same as another point, within a small tolerance.

        Args:
            other (Point): The other point to compare against.

        Returns:
            bool: True if the points are the same within a small tolerance, False otherwise.

        Example:
            >>> p1 = Point(1.0000001, 2.0000001)
            >>> p2 = Point(1, 2)
            >>> p1.is_same(p2)
            True
        """"""
        return self.distance(other) <= ATOM
class Line:
    """"""
    Represents a numerical line in 2D space, defined either by two points or by its
    coefficients in the standard line equation (ax + by + c = 0).

    Methods are defined to enable geometric operations like checking parallelism,
    perpendicularity, intersection, and calculating distance to points.

    Attributes:
        coefficients (tuple[float, float, float]): The coefficients a, b, c of the line equation.

    Methods:
        __init__: Initialize the line (self) object
        parallel_line: Create a line parallel to this line that passes through a given point.
        perpendicular_line: Create a line perpendicular to this line that passes through a given point.
        greater_than: Check if this line is 'greater than' another line based on the slope.
        __gt__: Overloads the '>' operator to compare two lines based on their slopes. (uses `greater_than`)
        __lt__: Overloads the '<' operator to compare two lines based on their slopes. (uses `greater_than`)
        intersect: Find the intersection points between this line and another line or a circle.
        distance: Calculate the shortest distance from a point to this line.
        __call__: Evaluate the line equation with a given point or x and y coordinates.
        is_parallel: Check if this line is parallel to another line.
        is_perp: Check if this line is perpendicular to another line.
        cross: Calculate the cross product of this line with another line.
        dot: Calculate the dot product of this line with another line.
        point_at: Get a point on this line closest to a given x or y coordinate.
        diff_side: Check if two points are on different sides of this line.
        same_side: Check if two points are on the same side of this line.
        sign: Determine the sign (positive, negative, or zero) of a point relative to this line.
        is_same: Checks whether the current line is the same as another line. 
        sample_within: This method samples a point within the boundary defined by a list of points. 
        same: Check if two lines are equivalent in the geometric sense, regardless of their coefficient representation.
        equal: Check if the slopes of two lines are equal, indicating they are parallel.
    """"""

    def __init__(self, p1: Point = None, p2: Point = None, coefficients: tuple[int, int, int] = None):
        """"""
        Initialize a Line object. 
        
        A line can be initialized with either two points (p1 and p2) 
            ... OR ...
        A line an be initialized directly with its coefficients (a, b, c) 
            - As in the equation ax + by + c = 0.

        Args:
            p1 (Point, optional): The first point through which the line passes.
            p2 (Point, optional): The second point through which the line passes.
            coefficients (tuple[int, int, int], optional): The coefficients of the line equation.

        Raises:
            ValueError: If insufficient data is provided to define a line.
        """"""
        if p1 is None and p2 is None and coefficients is None:
            raise ValueError(""Insufficient data to define a line."")

        # Calculate coefficients based on two points
        if coefficients is None:
            a = p1.y - p2.y
            b = p2.x - p1.x
            c = p1.x * p2.y - p2.x * p1.y
        else:
            a, b, c = coefficients

        # Normalize coefficients so that 'a' is non-negative (ensures standard form)
        if a < 0.0 or (a == 0.0 and b > 0.0):
            a, b, c = -a, -b, -c
        
        # Set the coefficients for the line equation that defines THIS line (self)
        self.coefficients = a, b, c

    def parallel_line(self, p: Point) -> 'Line':
        """"""
        Create a line parallel to this line that passes through a given point.

        Args:
            p (Point): The point through which the parallel line should pass.

        Returns:
            Line: A new line parallel to the original line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> parallel = l.parallel_line(Point(0, 1))
            >>> print(parallel.coefficients)
            (1, -1, 1)
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # The parallel line will have the same 'a' and 'b' coefficients
        return Line(coefficients=(a, b, -a * p.x - b * p.y))

    def perpendicular_line(self, p: Point) -> 'Line':
        """"""
        Create a line perpendicular to this line that passes through a given point.

        Args:
            p (Point): The point through which the perpendicular line should pass.

        Returns:
            Line: A new line perpendicular to the original line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> perp = l.perpendicular_line(Point(1, 0))
            >>> print(perp.coefficients)
            (1, 1, -1)
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # The perpendicular line will swap 'a' and 'b' and change one of their signs
        return Line(p, p + Point(a, b))

    def greater_than(self, other: 'Line') -> bool:
        """"""
        Check if this line is 'greater than' another line based on the slope.

        This is a utility method used for comparing lines. It compares the slopes of the lines.

        Args:
            other (Line): The line to compare against.

        Returns:
            bool: True if this line's slope is greater than the other line's slope, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 0), Point(1, 2))
            >>> l1.greater_than(l2)
            False
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # # Get the coefficients from the line equation that defines the OTHER line
        x, y, _ = other.coefficients
        
        # Compare the slopes
        return b * x > a * y

    def __gt__(self, other: 'Line') -> bool:
        """"""
        Overloads the '>' operator to compare two lines based on their slopes.

        Args:
            other (Line): The line to compare against.

        Returns:
            bool: True if this line is 'greater than' the other line, False otherwise.
        """"""
        return self.greater_than(other)

    def __lt__(self, other: 'Line') -> bool:
        """"""
        Overloads the '<' operator to compare two lines based on their slopes.

        Args:
            other (Line): The line to compare against.

        Returns:
            bool: True if this line is 'less than' the other line, False otherwise.
        """"""
        return other.greater_than(self)

    
    def intersect(self, obj: Union['Line', 'Circle']) -> tuple[Point, ...]:
        """"""
        Find the intersection points between this line and another line or a circle.

        Args:
            obj (Union[Line, Circle]): The line or circle to find intersections with.

        Returns:
            tuple[Point, ...]: A tuple of intersection points. Can be empty if no intersection.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 1), Point(1, 0))
            >>> intersections = l1.intersect(l2)
            >>> print(intersections[0])
            P(0.5,0.5)
        """"""
        
        # Determine the intersection points between this Line and another Line
        if isinstance(obj, Line):
            return line_line_intersection(self, obj)
        
        # Determine the intersection points between this Line and a Circle
        if isinstance(obj, Circle):
            return line_circle_intersection(self, obj)

    def distance(self, p: 'Point') -> float:
        """"""
        Calculate the shortest distance from a point to this line.

        Args:
            p (Point): The point from which to measure the distance.

        Returns:
            float: The shortest distance from the point to the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p = Point(1, 0)
            >>> l.distance(p)
            0.7071067811865476
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # 
        return abs(self(p.x, p.y)) / math.sqrt(a * a + b * b)

    def __call__(self, x: Union[Point, float], y: float = None) -> float:
        """"""
        Evaluate the line equation with a given point or x and y coordinates.
        
        The primary purpose of this method is to check where a point lies in relation to the line.
            - When the result of the line equation is zero, it indicates that the point lies exactly on the line.
            - A positive or negative result indicates that the point lies on one side or the other of the line.
        This method is versatile as it allows the line equation to be evaluated both for Point objects and for raw coordinate values.
        
        Args:
            x (Union[Point, float]): A Point object or the x-coordinate.
            y (float, optional): The y-coordinate. Not needed if 'x' is a Point.

        Returns:
            float: The result of the line equation ax + by + c.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> l(1, 1)  # Should be close to 0 as (1,1) is on the line
            0.0
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # Retrieve the actual x,y coordinates from the point if passed
        if isinstance(x, Point):
            return a * x.x + b * x.y + c
        
        # Otherwise we use the directly passed x,y coordinates
        return a * x + b * y + c

    
    def is_parallel(self, other: 'Line') -> bool:
        """"""
        Check if this line is parallel to another line.

        Parallel lines have the same slope, which translates to A1/B1 = A2/B2 in line coefficients. 
        This method compares the slopes for equality.

        Args:
            other (Line): The line to check parallelism with.

        Returns:
            bool: True if the lines are parallel, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 1), Point(2, 2))
            >>> l1.is_parallel(l2)
            True
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Check if the slopes are the same (within tolerance 1e-12)
        return abs(a * y - b * x) < ATOM

    def is_perp(self, other: 'Line') -> bool:
        """"""
        Check if this line is perpendicular to another line.

        Perpendicular lines have slopes that are negative reciprocals of each other,
        which translates to A1*A2 + B1*B2 = 0 in line coefficients.

        Args:
            other (Line): The line to check perpendicularity with.

        Returns:
            bool: True if the lines are perpendicular, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 0), Point(-1, 1))
            >>> l1.is_perp(l2)
            True
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Checking if slopes are negative reciprocals (within tolerance 1e-12)
        return abs(a * x + b * y) < ATOM  

    def cross(self, other: 'Line') -> float:
        """"""
        Calculate the cross product of this line with another line.

        The cross product, in this context, refers to the determinant of the matrix formed
        by the coefficients of the two lines. It's useful for understanding the relationship
        between the two lines (like finding area of parallelogram formed by them).

        Args:
            other (Line): The other line.

        Returns:
            float: The cross product of the two lines.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 1), Point(2, 2))
            >>> l1.cross(l2)
            0.0  # Zero indicates parallel lines
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Determinant of a 2x2 matrix formed by line coefficients
        return a * y - b * x  

    def dot(self, other: 'Line') -> float:
        """"""
        Calculate the dot product of this line with another line.

        The dot product here is a scalar value representing the sum of the products of
        their corresponding coefficients. It's useful in various geometric calculations.

        Args:
            other (Line): The other line.

        Returns:
            float: The dot product of the two lines.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 1), Point(2, 2))
            >>> l1.dot(l2)
            2.0
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # Sum of the products of corresponding coefficients
        return a * x + b * y  

    def point_at(self, x: float = None, y: float = None) -> Optional[Point]:
        """"""
        Get a point on this line closest to a given x or y coordinate.

        If only x is given, finds the y on the line such that (x, y) is on the line.
        If only y is given, finds the x on the line such that (x, y) is on the line.
        If both are given, returns the point if it lies on the line, else None.

        Args:
            x (float, optional): The x-coordinate.
            y (float, optional): The y-coordinate.

        Returns:
            Optional[Point]: The point on the line closest to the given coordinates, or None.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> print(l.point_at(x=2))
            P(2,2)
            >>> print(l.point_at(y=2))
            P(2,2)
        """"""
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # If only x is given, finds the y on the line such that (x, y) is on the line.
        if x is not None and y is None:
            # Find y for given x
            return Point(x, (-c - a * x) / b) if b != 0 else None
        
        # If only y is given, finds the x on the line such that (x, y) is on the line.
        elif x is None and y is not None:
            # Find x for given y
            return Point((-c - b * y) / a, y) if a != 0 else None
        
        # If both are given, returns the point if it lies on the line, else None.
        elif x is not None and y is not None:
            # Check if the point (x, y) is on the line
            return Point(x, y) if a * x + b * y + c == 0 else None
        
        # If neither are given we return None
        return None

    def diff_side(self, p1: Point, p2: Point) -> Optional[bool]:
        """"""
        Check if two points are on different sides of this line.

        Args:
            p1 (Point): The first point.
            p2 (Point): The second point.

        Returns:
            Optional[bool]: True if the points are on different sides
                            False if on the same side
                            None if either point lies on the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p1 = Point(1, 2)
            >>> p2 = Point(2, 1)
            >>> l.diff_side(p1, p2)
            True
        """"""
        # Evaluate the line equation for both points
        #   - Evaluates 'ax + by + c' (self.__call__) for point 'p1' and 'p2' respectively
        d1 = self(p1.x, p1.y)  
        d2 = self(p2.x, p2.y)

        # One of the points is on the line, so can't determine different sides
        if d1 == 0 or d2 == 0:
            return None  

        # If the signs of the evaluations are different, the points are on different sides
        return d1 * d2 < 0

    # Seems like this could be inverse of `diff_side`
    def same_side(self, p1: Point, p2: Point) -> Optional[bool]:
        """"""
        Check if two points are on the same side of this line.

        Args:
            p1 (Point): The first point.
            p2 (Point): The second point.

        Returns:
            Optional[bool]: True if the points are on the same side
                            False if on different sides
                            None if either point lies on the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p1 = Point(1, 1)
            >>> p2 = Point(2, 2)
            >>> l.same_side(p1, p2)
            True
        """"""
        # Evaluate the line equation for both points
        #   - Evaluates 'ax + by + c' (self.__call__) for point 'p1' and 'p2' respectively
        d1 = self(p1.x, p1.y)
        d2 = self(p2.x, p2.y)

        # One of the points is on the line, so can't determine same sides
        if d1 == 0 or d2 == 0:
            return None  

        # If the signs of the evaluations are the same, the points are on the same side
        return d1 * d2 > 0
    
    def sign(self, point: Point) -> int:
        """"""
        Determine the sign (positive, negative, or zero) of a point relative to this line.

        The sign indicates which side of the line the point lies on. 
        It's calculated by plugging the point's coordinates into the line's equation.

        Args:
            point (Point): The point to check.

        Returns:
            int: 1 if the point is on one side of the line, -1 if on the other side, 0 if on the line.

        Example:
            >>> l = Line(Point(0, 0), Point(1, 1))
            >>> p = Point(1, 2)
            >>> l.sign(p)
            1  # Point is above the line
        """"""
        # Evaluate (self.__call__) the line equation (ax + by + c) for the respective point
        s = self(point.x, point.y)

        # Determine the sign based on the evaluation
        if s > 0:
            return 1  # Point is on one side of the line
        elif s < 0:
            return -1  # Point is on the other side of the line
        return 0  # Point is on the line

    def is_same(self, other: Line) -> bool:
        """"""
        Checks whether the current line is the same as another line. 
        
        This comparison is based on comparison of the coefficients of the two lines.
        This comparison measures EXACT EQUALITY (as opposed to `self.same`)

        Args:
            other (Line): The other line.

        Returns:
            bool: True if the lines evaluate to be the same within tolerance

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(0, 0), Point(1, 1))
            >>> l1.is_same(other=l2)
            True
        """"""
        # Extract the coefficients of THIS line (a,b,c) and the OTHER line (x,y,z)
        a, b, c = self.coefficients
        x, y, z = other.coefficients

        # Check if the lines have the same slope and intercept (within tolerance of 1e-12)
        #   - 'abs(a * y - b * x)' checks if the slopes (b/a and y/x) are equal
        #   - 'abs(b * z - c * y)' checks if the intercepts (c/b and z/y) are the same
        return abs(a * y - b * x) <= ATOM and abs(b * z - c * y) <= ATOM

    def sample_within(self, points: list[Point], n: int = 5) -> list[Point]:
        """"""
        This method samples a point within the boundary defined by a list of points. 
        
        Sampling Procedure:
            - A circle is created with a radius equal to the maximum distance from the center to any of the boundary points. 
            - Then find points where the line intersects this circle
            - Then sample points along the line segment within the circle
            - Finally, choose the point farthest from the boundary points (best point).

        Args:
            points (List[Point]): The points that define the boundary of the circle
            n (int, optional): The number of points to randomly sample
            
        Returns:
            List: The sampled point that is the farthest from the boundary points (best point)
        """"""
        # Find the center of the given points
        center = sum(points, Point(0.0, 0.0)) * (1.0 / len(points))

        # Find the maximum distance from the center to any point to define a boundary
        radius = max([p.distance(center) for p in points])

        # Adjust the center to the nearest point on the line if it's outside the radius
        if close_enough(center.distance(self), radius):
            center = center.foot(self)

        # Find two points where the line intersects the circle around the center
        a, b = line_circle_intersection(self, Circle(center.foot(self), radius))

        # Initialize placeholder/values
        result = None
        best = -1.0
        
        # Randomly sample points on the line segment defined by the intersection points
        for _ in range(n):
            
            # Generate a random number between 0 and 1
            rand = unif(0.0, 1.0)  
            
            # Linear interpolation between points a and b
            x = a + (b - a) * rand  
            
            # Minimum distance to the boundary points
            mind = min([x.distance(p) for p in points])  
            
            # Update the best (farthest) point found
            if mind > best:
                best = mind    
                result = x  
        
        # Return the list containing the best point found
        return [result]  

    def same(self, other: Line) -> bool:
        """""" 
        Check if two lines are equivalent in the geometric sense, regardless of their coefficient representation.

        This method determines if two lines represent the same geometric line, even if their coefficients differ.
        It compares the proportional relationship of the coefficients of the two lines. For example, the lines
        y = x and 2y = 2x are different in representation but are geometrically the same line.

        Args:
            other (Line): The other line to compare with.

        Returns:
            bool: True if the lines are geometrically equivalent, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(coefficients=(2, -2, 0))
            >>> l1.same(l2)
            True
        """"""
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, c = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, z = other.coefficients
    
        # Check for equivalence of lines
        #   - The first condition compares the proportional relationship of a and b to x and y
        #   - The second condition does a similar check for the offsets (c to y and z to y)
        # This allows for lines that are the same but represented with different coefficients
        return close_enough(a * y, b * x) and close_enough(b * z, c * y)

    def equal(self, other: Line) -> bool:
        """""" 
        Check if the slopes of two lines are equal, indicating they are parallel.

        This method compares the slopes of two lines to determine if they are parallel. It does not consider
        the intercepts, so parallel lines with different intercepts will still be considered 'equal' in terms of slope.

        Args:
            other (Line): The other line to compare with.

        Returns:
            bool: True if the slopes of the two lines are equal, False otherwise.

        Example:
            >>> l1 = Line(Point(0, 0), Point(1, 1))
            >>> l2 = Line(Point(1, 0), Point(2, 1))
            >>> l1.equal(l2)
            True
        """"""        
        
        # Get the coefficients from the line equation that defines THIS line (self)
        a, b, _ = self.coefficients
        
        # Get the coefficients from the line equation that defines THE OTHER line
        x, y, _ = other.coefficients
        
        # The line 'b * x == a * y' may require a bit of explanation
        #   Slope Comparison: 
        #     - The comment # b/a == y/x --> b*x == a*y is explaining the logic behind the comparison. 
        #     - In the context of line equations:
        #       - The slope of a line given by ax + by + c = 0 is -a/b.
        #       - So, for two lines to be parallel, their slopes must be equal. 
        #       - This means -a/b for the first line should be equal to -x/y for the second line.
        #       - This is equivalent to saying b/a == y/x.
        #   Cross-Multiplying for Comparison: 
        #     - The expression b*x == a*y is a result of cross-multiplying b/a == y/x. 
        #     - This is done to avoid division (either b or y may be zero) and to simplify the comparison.
        #     - If b/a equals y/x, then b*x should equal a*y.
        return b * x == a * y
class HalfLine(Line):
    """"""
    Represents a numerical half-line or ray in 2D space.

    A HalfLine is a part of a line that starts at a point (the 'tail') and extends infinitely
    in one direction (towards the 'head').

    Inherits from Line class to utilize common line functionalities.

    Attributes:
        tail (Point): The starting point of the half-line.
        head (Point): A point that the half-line passes through, determining its direction.
        line (Line): The underlying Line object that represents the full line.

    Methods:
        __init__: Initialize the HalfLine object with a tail and head.
        intersect: Find the intersection point of the HalfLine with another geometric object.
        sample_within: Samples a point within a boundary defined by a list of points.
    """"""

    def __init__(self, tail: Point, head: Point):
        """"""
        Initialize a HalfLine object with a tail and head point.

        The tail is the starting point of the half-line, and the head is another point
        which the half-line passes through, defining its direction.

        Args:
            tail (Point): The starting point of the half-line.
            head (Point): A point through which the half-line passes.

        Example Usage:
            >>> tail = Point(0, 0)
            >>> head = Point(1, 1)
            >>> half_line = HalfLine(tail, head)
        """"""
        # Initialize the underlying Line object from the tail to the head
        self.line = Line(tail, head)

        # Store the coefficients of the underlying Line
        self.coefficients = self.line.coefficients

        # Store the tail and head points
        self.tail = tail
        self.head = head

    def intersect(self, obj: Union[Line, HalfLine, Circle, HoleCircle]) -> Point:
        """"""
        Find the intersection point of the HalfLine with another geometric object.

        This method extends the intersection functionality to consider the nature of a half-line,
        which extends infinitely from the tail through the head.

        Args:
            obj (Union[Line, HalfLine, Circle, HoleCircle]): The geometric object to find
            intersections with. It can be a Line, HalfLine, Circle, or HoleCircle.

        Returns:
            Point: The intersection point if one exists.

        Raises:
            InvalidLineIntersectError: If the intersection cannot be determined or does not exist.

        Example Usage:
            >>> line = Line(Point(0, 0), Point(1, 1))
            >>> half_line = HalfLine(Point(0, 0), Point(1, 1))
            >>> intersection = half_line.intersect(line)
            >>> print(intersection)
            P(0,0)
        """"""
        
        # Handling intersection with a Line or HalfLine
        if isinstance(obj, (HalfLine, Line)):
            return line_line_intersection(self.line, obj)

        # Create a list of exclusions (for intersection calculation) 
        #   - We initialize it with the 'tail' point
        exclude = [self.tail]

        # Special handling for HoleCircle, which has a 'hole' that should not be considered for intersection
        if isinstance(obj, HoleCircle):
            exclude += [obj.hole]

        # Find potential intersection points with a Circle or HoleCircle
        a, b = line_circle_intersection(self.line, obj)

        # Exclude intersection points that are close to the exclusion points
        if any([a.close(x) for x in exclude]):
            return b
        if any([b.close(x) for x in exclude]):
            return a

        # Determine which of the potential intersection points lies on the HalfLine
        v = self.head - self.tail  # Vector along the half-line
        va = a - self.tail  # Vector from the tail to point a
        vb = b - self.tail  # Vector from the tail to point b

        # Check if either of the intersection points extends in the same direction as the half-line
        if v.dot(va) > 0:
            return a
        if v.dot(vb) > 0:
            return b

        # If neither intersection point is valid, raise an error
        raise InvalidLineIntersectError()

    def sample_within(self, points: list[Point], n: int = 5) -> list[Point]:
        """"""
        Samples a point within a boundary defined by a list of points.

        This method finds a point on the HalfLine that is maximally distant from the boundary
        points, within a certain radius. It is useful for applications like diagram generation or
        optimization within a bounded area.

        Args:
            points (list[Point]): The points that define the boundary of the area.
            n (int, optional): The number of points to randomly sample.

        Returns:
            list[Point]: A list containing the best sampled point.

        Example:
            >>> boundary_points = [Point(0, 0), Point(1, 1), Point(0, 1)]
            >>> half_line = HalfLine(Point(0, 0), Point(1, 1))
            >>> best_point = half_line.sample_within(boundary_points)
            >>> print(best_point)
            [P(0.5,0.5)]
        """"""
        # Calculate the center of the given boundary points
        center = sum(points, Point(0.0, 0.0)) * (1.0 / len(points))

        # Find the radius as the maximum distance from the center to any of the boundary points
        radius = max([p.distance(center) for p in points])

        # Adjust the center to the nearest point on the half-line if it's outside the radius
        if close_enough(center.distance(self.line), radius):
            center = center.foot(self)
        
        # Find intersection points of the HalfLine with a circle defined by the center and radius
        a, b = line_circle_intersection(self, Circle(center.foot(self), radius))

        # Decide which of the intersection points to use based on the direction of the half-line
        if (a - self.tail).dot(self.head - self.tail) > 0:
            a, b = self.tail, a
        else:
            a, b = self.tail, b

        # Initialize variables to store the best point and its score
        result = None
        best = -1.0

        # Randomly sample points on the segment of the half-line inside the circle
        for _ in range(n):
            x = a + (b - a) * unif(0.0, 1.0)  # Random point between a and b
            mind = min([x.distance(p) for p in points])  # Minimum distance to the boundary points
            
            # Update the best point if a better one is found
            if mind > best:
                best = mind
                result = x

        # Return the list containing the best point found
        return [result]
class Circle:
    """"""
    Represents a circle in 2D space.

    A circle can be defined by providing a center point and a radius, or by three points
    on its circumference (from which the center and radius are calculated).

    Attributes:
        center (Point): The center point of the circle.
        radius (float): The radius of the circle.
        a, b (float): The x and y coordinates of the center, respectively.
        r2 (float): The square of the radius of the circle.

    Methods:
        __init__: Initialize the circle object.
        intersect: Find the intersection points with another geometric object.
        sample_within: Sample a random point within a defined boundary.

    Raises:
        ValueError: If insufficient data is provided to define a circle.
    """"""

    def __init__(
            self,
            center: Optional[Point] = None,
            radius: Optional[float] = None,
            p1: Optional[Point] = None,
            p2: Optional[Point] = None,
            p3: Optional[Point] = None,
    ):
        """"""
        Initialize a Circle object. The circle can be defined either by a center and radius, 
        or by three points on its circumference.

        Args:
            center (Point, optional): The center of the circle.
            radius (float, optional): The radius of the circle.
            p1, p2, p3 (Point, optional): Three points on the circumference of the circle.

        Raises:
            ValueError: If insufficient data is provided to define a circle.
        """"""

        # If the center is not provided, calculate it using three points on the circle.
        if not center:
            # Ensure all three points are provided to calculate the center.
            if not (p1 and p2 and p3):
                self.center = self.radius = self.r2 = None
                return  # Could raise ValueError('Circle without center need p1 p2 p3')
            
            # Calculate the perpendicular bisectors of lines between the points.
            l12 = _perpendicular_bisector(p1, p2)
            l23 = _perpendicular_bisector(p2, p3)

            # Find the intersection of these bisectors to determine the center.
            center = line_line_intersection(l12, l23)

        # Set the center of the circle.
        self.center = center
        
        # Extract x and y coordinates of the center.
        self.a, self.b = center.x, center.y  

        # If the radius is not provided, calculate it using one of the points.
        if not radius:
            # Ensure at least one point is provided if radius is not given.
            if not (p1 or p2 or p3):
                raise ValueError('Circle needs radius or p1 or p2 or p3')

            # Choose any one of the provided points to calculate the radius.
            p = p1 or p2 or p3

            # Calculate the squared radius based on the distance from the center to the point.
            self.r2 = (self.a - p.x) ** 2 + (self.b - p.y) ** 2
            
            # Calculate the radius.
            self.radius = math.sqrt(self.r2)  
        else:
            # If the radius is provided, set it directly.
            self.radius = radius
            
            # Calculate the squared radius.
            self.r2 = radius * radius  

    def intersect(self, obj: Union[Line, Circle]) -> tuple[Point, ...]:
        """"""
        Find the intersection points between the circle and another geometric object (line or circle).

        Args:
            obj (Union[Line, Circle]): The geometric object to intersect with.

        Returns:
            tuple[Point, ...]: A tuple of Points where the objects intersect. Can be empty if no intersection.
        """"""
        # Delegate the intersection calculation based on the type of 'obj'.
        if isinstance(obj, Line):
            return obj.intersect(self)
        if isinstance(obj, Circle):
            return circle_circle_intersection(self, obj)

    def sample_within(self, points: list[Point], n: int = 5) -> list[Point]:
        """"""
        Sample a point within the boundary defined by a list of points.

        This method randomly samples points on the circle's circumference and selects
        the one farthest from the boundary points.

        Args:
            points (list[Point]): The points defining the boundary.
            n (int, optional): The number of points to sample. Default is 5.

        Returns:
            list[Point]: A list containing the best sampled point.

        Example:
            >>> circle = Circle(center=Point(0, 0), radius=1)
            >>> boundary_points = [Point(1, 1), Point(-1, -1), Point(1, -1)]
            >>> best_point = circle.sample_within(boundary_points)
            >>> print(best_point)
            [Point(0.707, 0.707)]
        """"""
        
        # Initialize
        result = None
        best = -1.0
        
        # Iterate up to n random sampled points to find the 'best' point
        for _ in range(n):
            # Randomly generate an angle to find a point on the circle's circumference.
            ang = unif(0.0, 2.0) * np.pi
            x = self.center + Point(np.cos(ang), np.sin(ang)) * self.radius

            # Find the minimum distance of this point from the boundary points.
            mind = min([x.distance(p) for p in points])

            # Update the best point if this one is farther from the boundary.
            if mind > best:
                best = mind
                result = x

        # Return the best point found.
        return [result]

class HoleCircle(Circle):
    """"""Numerical circle with a missing point.""""""
    
    def __init__(self, center: Point, radius: float, hole: Point):
        """"""
        Initializes a HoleCircle object.

        This constructor creates a HoleCircle, which is essentially a Circle with an additional
        attribute 'hole' representing a point that is conceptually not part of the circle.

        Args:
            center (Point): The center point of the circle.
            radius (float): The radius of the circle.
            hole (Point): The point on the circle that is considered as the hole.

        Example Usage:
            >>> center_point = Point(0, 0)
            >>> hole_point = Point(1, 0)
            >>> hole_circle = HoleCircle(center=center_point, radius=1, hole=hole_point)
        """"""
        super().__init__(center, radius)  # Initialize the base Circle class
        self.hole = hole  # Define the hole point

    def intersect(self, obj: Union[Line, HalfLine, Circle, HoleCircle]) -> Point:
        """"""
        Find the intersection point between the HoleCircle and another geometric object.

        This method overrides the 'intersect' method in the Circle class to account for the 'hole' point.
        When calculating intersections, if one of the intersection points coincides with the 'hole', 
        that point is disregarded, and the other point is returned.

        Args:
            obj (Union[Line, HalfLine, Circle, HoleCircle]): The geometric object to intersect with.

        Returns:
            Point: The intersection point, excluding the hole if it coincides with one of the intersection points.

        Example:
            >>> line = Line(Point(0, 5), Point(5, 5))
            >>> hole_circle = HoleCircle(Point(0, 0), 5, Point(5, 0))
            >>> intersect_point = hole_circle.intersect(line)
            >>> print(intersect_point)
            Point(0, 5)
        """"""
        if isinstance(obj, Line):
            # Calculate intersections with a line.
            a, b = line_circle_intersection(obj, self)
            
            # If one of the points is the 'hole', return the other.
            if a.close(self.hole):
                return b
            return a
        
        # Delegate to HalfLine's intersect method.
        if isinstance(obj, HalfLine):
            return obj.intersect(self)
        
        # Delegate to Circle's intersect method.
        if isinstance(obj, Circle):
            # Calculate intersections with another circle.
            a, b = circle_circle_intersection(obj, self)
            # If one of the points is the 'hole', return the other.
            if a.close(self.hole):
                return b
            return a
        
        # Delegate to HoleCircle's intersect method.
        if isinstance(obj, HoleCircle):
            # Calculate intersections with another HoleCircle.
            a, b = circle_circle_intersection(obj, self)
            # Check if either of the intersection points is the 'hole' in either circle.
            if a.close(self.hole) or a.close(obj.hole):
                return b
            return a
def _perpendicular_bisector(p1: Point, p2: Point) -> Line:
    midpoint = (p1 + p2) * 0.5
    return Line(midpoint, midpoint + Point(p2.y - p1.y, p1.x - p2.x))


def same_sign(
        a: Point, b: Point, c: Point, d: Point, e: Point, f: Point
) -> bool:
    a, b, c, d, e, f = map(lambda p: p.sym, [a, b, c, d, e, f])
    ab, cb = a - b, c - b
    de, fe = d - e, f - e
    return (ab.x * cb.y - ab.y * cb.x) * (de.x * fe.y - de.y * fe.x) > 0


def solve_quad(a: float, b: float, c: float) -> tuple[float, float]:
    """"""Solve a x^2 + bx + c = 0.""""""
    a = 2 * a
    d = b * b - 2 * a * c
    if d < 0:
        return None  # the caller should expect this result.

    y = math.sqrt(d)
    return (-b - y) / a, (-b + y) / a


def circle_circle_intersection(c1: Circle, c2: Circle) -> tuple[Point, Point]:
    """"""Returns a pair of Points as intersections of c1 and c2.""""""
    # circle 1: (x0, y0), radius r0
    # circle 2: (x1, y1), radius r1
    x0, y0, r0 = c1.a, c1.b, c1.radius
    x1, y1, r1 = c2.a, c2.b, c2.radius

    d = math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2)
    if d == 0:
        raise InvalidQuadSolveError()

    a = (r0 ** 2 - r1 ** 2 + d ** 2) / (2 * d)
    h = r0 ** 2 - a ** 2
    if h < 0:
        raise InvalidQuadSolveError()
    h = np.sqrt(h)
    x2 = x0 + a * (x1 - x0) / d
    y2 = y0 + a * (y1 - y0) / d
    x3 = x2 + h * (y1 - y0) / d
    y3 = y2 - h * (x1 - x0) / d
    x4 = x2 - h * (y1 - y0) / d
    y4 = y2 + h * (x1 - x0) / d

    return Point(x3, y3), Point(x4, y4)


def line_circle_intersection(line: Line, circle: Circle) -> tuple[Point, Point]:
    """"""Returns a pair of points as intersections of line and circle.""""""
    a, b, c = line.coefficients
    r = float(circle.radius)
    center = circle.center
    p, q = center.x, center.y

    if b == 0:
        x = -c / a
        x_p = x - p
        x_p2 = x_p * x_p
        y = solve_quad(1, -2 * q, q * q + x_p2 - r * r)
        if y is None:
            raise InvalidQuadSolveError()
        y1, y2 = y
        return (Point(x, y1), Point(x, y2))

    if a == 0:
        y = -c / b
        y_q = y - q
        y_q2 = y_q * y_q
        x = solve_quad(1, -2 * p, p * p + y_q2 - r * r)
        if x is None:
            raise InvalidQuadSolveError()
        x1, x2 = x
        return (Point(x1, y), Point(x2, y))

    c_ap = c + a * p
    a2 = a * a
    y = solve_quad(
        a2 + b * b, 2 * (b * c_ap - a2 * q), c_ap * c_ap + a2 * (q * q - r * r)
    )
    if y is None:
        raise InvalidQuadSolveError()
    y1, y2 = y

    return Point(-(b * y1 + c) / a, y1), Point(-(b * y2 + c) / a, y2)


def _check_between(a: Point, b: Point, c: Point) -> bool:
    """"""Whether a is between b & c.""""""
    return (a - b).dot(c - b) > 0 and (a - c).dot(b - c) > 0


def circle_segment_intersect(
        circle: Circle, p1: Point, p2: Point
) -> list[Point]:
    l = Line(p1, p2)
    px, py = line_circle_intersection(l, circle)

    result = []
    if _check_between(px, p1, p2):
        result.append(px)
    if _check_between(py, p1, p2):
        result.append(py)
    return result


def line_segment_intersection(l: Line, A: Point, B: Point) -> Point:  # pylint: disable=invalid-name
    a, b, c = l.coefficients
    x1, y1, x2, y2 = A.x, A.y, B.x, B.y
    dx, dy = x2 - x1, y2 - y1
    alpha = (-c - a * x1 - b * y1) / (a * dx + b * dy)
    return Point(x1 + alpha * dx, y1 + alpha * dy)


def line_line_intersection(l1: Line, l2: Line) -> Point:
    a1, b1, c1 = l1.coefficients
    a2, b2, c2 = l2.coefficients
    # a1x + b1y + c1 = 0
    # a2x + b2y + c2 = 0
    d = a1 * b2 - a2 * b1
    if d == 0:
        raise InvalidLineIntersectError
    return Point((c2 * b1 - c1 * b2) / d, (c1 * a2 - c2 * a1) / d)


def check_too_close(
        newpoints: list[Point], points: list[Point], tol: int = 0.1
) -> bool:
    if not points:
        return False
    avg = sum(points, Point(0.0, 0.0)) * 1.0 / len(points)
    mindist = min([p.distance(avg) for p in points])
    for p0 in newpoints:
        for p1 in points:
            if p0.distance(p1) < tol * mindist:
                return True
    return False


def check_too_far(
        newpoints: list[Point], points: list[Point], tol: int = 4
) -> bool:
    if len(points) < 2:
        return False
    avg = sum(points, Point(0.0, 0.0)) * 1.0 / len(points)
    maxdist = max([p.distance(avg) for p in points])
    for p in newpoints:
        if p.distance(avg) > maxdist * tol:
            return True
    return False


def check_aconst(args: list[Point]) -> bool:
    a, b, c, d, num, den = args
    d = d + a - c
    ang = ang_between(a, b, d)
    if ang < 0:
        ang += np.pi
    return close_enough(ang, num * np.pi / den)


def check(name: str, args: list[Union[gm.Point, Point]]) -> bool:
    """"""Numerical check.""""""
    if name == 'eqangle6':
        name = 'eqangle'
    elif name == 'eqratio6':
        name = 'eqratio'
    elif name in ['simtri2', 'simtri*']:
        name = 'simtri'
    elif name in ['contri2', 'contri*']:
        name = 'contri'
    elif name == 'para':
        name = 'para_or_coll'
    elif name == 'on_line':
        name = 'coll'
    elif name in ['rcompute', 'acompute']:
        return True
    elif name in ['fixl', 'fixc', 'fixb', 'fixt', 'fixp']:
        return True

    fn_name = 'check_' + name
    if fn_name not in globals():
        return None

    fun = globals()['check_' + name]
    args = [p.num if isinstance(p, gm.Point) else p for p in args]
    return fun(args)


def check_circle(points: list[Point]) -> bool:
    if len(points) != 4:
        return False
    o, a, b, c = points
    oa, ob, oc = o.distance(a), o.distance(b), o.distance(c)
    return close_enough(oa, ob) and close_enough(ob, oc)


def check_coll(points: list[Point]) -> bool:
    a, b = points[:2]
    l = Line(a, b)
    for p in points[2:]:
        if abs(l(p.x, p.y)) > ATOM:
            return False
    return True


def check_ncoll(points: list[Point]) -> bool:
    return not check_coll(points)


def check_sameside(points: list[Point]) -> bool:
    b, a, c, y, x, z = points
    # whether b is to the same side of a & c as y is to x & z
    ba = b - a
    bc = b - c
    yx = y - x
    yz = y - z
    return ba.dot(bc) * yx.dot(yz) > 0


def check_para_or_coll(points: list[Point]) -> bool:
    return check_para(points) or check_coll(points)


def check_para(points: list[Point]) -> bool:
    a, b, c, d = points
    ab = Line(a, b)
    cd = Line(c, d)
    if ab.same(cd):
        return False
    return ab.is_parallel(cd)


def check_perp(points: list[Point]) -> bool:
    a, b, c, d = points
    ab = Line(a, b)
    cd = Line(c, d)
    return ab.is_perp(cd)


def check_cyclic(points: list[Point]) -> bool:
    points = list(set(points))
    (a, b, c), *ps = points
    circle = Circle(p1=a, p2=b, p3=c)
    for d in ps:
        if not close_enough(d.distance(circle.center), circle.radius):
            return False
    return True


def bring_together(
        a: Point, b: Point, c: Point, d: Point
) -> tuple[Point, Point, Point, Point]:
    ab = Line(a, b)
    cd = Line(c, d)
    x = line_line_intersection(ab, cd)
    unit = Circle(center=x, radius=1.0)
    y, _ = line_circle_intersection(ab, unit)
    z, _ = line_circle_intersection(cd, unit)
    return x, y, x, z


def same_clock(
        a: Point, b: Point, c: Point, d: Point, e: Point, f: Point
) -> bool:
    ba = b - a
    cb = c - b
    ed = e - d
    fe = f - e
    return (ba.x * cb.y - ba.y * cb.x) * (ed.x * fe.y - ed.y * fe.x) > 0


def check_const_angle(points: list[Point]) -> bool:
    """"""Check if the angle is equal to the given constant.""""""
    a, b, c, d, m, n = points
    a, b, c, d = bring_together(a, b, c, d)
    ba = b - a
    dc = d - c

    a3 = np.arctan2(ba.y, ba.x)
    a4 = np.arctan2(dc.y, dc.x)
    y = a3 - a4

    return close_enough(m / n % 1, y / np.pi % 1)


def check_eqangle(points: list[Point]) -> bool:
    """"""Check if 8 points make 2 equal angles.""""""
    a, b, c, d, e, f, g, h = points

    ab = Line(a, b)
    cd = Line(c, d)
    ef = Line(e, f)
    gh = Line(g, h)

    if ab.is_parallel(cd):
        return ef.is_parallel(gh)
    if ef.is_parallel(gh):
        return ab.is_parallel(cd)

    a, b, c, d = bring_together(a, b, c, d)
    e, f, g, h = bring_together(e, f, g, h)

    ba = b - a
    dc = d - c
    fe = f - e
    hg = h - g

    sameclock = (ba.x * dc.y - ba.y * dc.x) * (fe.x * hg.y - fe.y * hg.x) > 0
    if not sameclock:
        ba = ba * -1.0

    a1 = np.arctan2(fe.y, fe.x)
    a2 = np.arctan2(hg.y, hg.x)
    x = a1 - a2

    a3 = np.arctan2(ba.y, ba.x)
    a4 = np.arctan2(dc.y, dc.x)
    y = a3 - a4

    xy = (x - y) % (2 * np.pi)
    return close_enough(xy, 0, tol=1e-11) or close_enough(
        xy, 2 * np.pi, tol=1e-11
    )


def check_eqratio(points: list[Point]) -> bool:
    a, b, c, d, e, f, g, h = points
    ab = a.distance(b)
    cd = c.distance(d)
    ef = e.distance(f)
    gh = g.distance(h)
    return close_enough(ab * gh, cd * ef)


def check_cong(points: list[Point]) -> bool:
    a, b, c, d = points
    return close_enough(a.distance(b), c.distance(d))


def check_midp(points: list[Point]) -> bool:
    a, b, c = points
    return check_coll(points) and close_enough(a.distance(b), a.distance(c))


def check_simtri(points: list[Point]) -> bool:
    """"""Check if 6 points make a pair of similar triangles.""""""
    a, b, c, x, y, z = points
    ab = a.distance(b)
    bc = b.distance(c)
    ca = c.distance(a)
    xy = x.distance(y)
    yz = y.distance(z)
    zx = z.distance(x)
    tol = 1e-9
    return close_enough(ab * yz, bc * xy, tol) and close_enough(
        bc * zx, ca * yz, tol
    )


def check_contri(points: list[Point]) -> bool:
    a, b, c, x, y, z = points
    ab = a.distance(b)
    bc = b.distance(c)
    ca = c.distance(a)
    xy = x.distance(y)
    yz = y.distance(z)
    zx = z.distance(x)
    tol = 1e-9
    return (
            close_enough(ab, xy, tol)
            and close_enough(bc, yz, tol)
            and close_enough(ca, zx, tol)
    )


def check_ratio(points: list[Point]) -> bool:
    a, b, c, d, m, n = points
    ab = a.distance(b)
    cd = c.distance(d)
    return close_enough(ab * n, cd * m)


def draw_angle(
        ax: matplotlib.axes.Axes,
        head: Point,
        p1: Point,
        p2: Point,
        color: Any = 'red',
        alpha: float = 0.5,
        frac: float = 1.0,
) -> None:
    """"""Draw an angle on plt ax.""""""
    d1 = p1 - head
    d2 = p2 - head

    a1 = np.arctan2(float(d1.y), float(d1.x))
    a2 = np.arctan2(float(d2.y), float(d2.x))
    a1, a2 = a1 * 180 / np.pi, a2 * 180 / np.pi
    a1, a2 = a1 % 360, a2 % 360

    if a1 > a2:
        a1, a2 = a2, a1

    if a2 - a1 > 180:
        a1, a2 = a2, a1

    b1, b2 = a1, a2
    if b1 > b2:
        b2 += 360
    d = b2 - b1
    # if d >= 90:
    #   return

    scale = min(2.0, 90 / d)
    scale = max(scale, 0.4)
    fov = matplotlib.patches.Wedge(
        (float(head.x), float(head.y)),
        unif(0.075, 0.125) * scale * frac,
        a1,
        a2,
        color=color,
        alpha=alpha,
    )
    ax.add_artist(fov)


def naming_position(
        ax: matplotlib.axes.Axes, p: Point, lines: list[Line], circles: list[Circle]
) -> tuple[float, float]:
    """"""Figure out a good naming position on the drawing.""""""
    _ = ax
    r = 0.08
    c = Circle(center=p, radius=r)
    avoid = []
    for p1, p2 in lines:
        try:
            avoid.extend(circle_segment_intersect(c, p1, p2))
        except InvalidQuadSolveError:
            continue
    for x in circles:
        try:
            avoid.extend(circle_circle_intersection(c, x))
        except InvalidQuadSolveError:
            continue

    if not avoid:
        return [p.x + 0.01, p.y + 0.01]

    angs = sorted([ang_of(p, a) for a in avoid])
    angs += [angs[0] + 2 * np.pi]
    angs = [(angs[i + 1] - a, a) for i, a in enumerate(angs[:-1])]

    d, a = max(angs)
    ang = a + d / 2

    name_pos = p + Point(np.cos(ang), np.sin(ang)) * r

    x, y = (name_pos.x - r / 1.5, name_pos.y - r / 1.5)
    return x, y


def draw_point(
        ax: matplotlib.axes.Axes,
        p: Point,
        name: str,
        lines: list[Line],
        circles: list[Circle],
        color: Any = 'white',
        size: float = 15,
) -> None:
    """"""draw a point.""""""
    ax.scatter(p.x, p.y, color=color, s=size)

    if color == 'white':
        color = 'lightgreen'
    else:
        color = 'grey'

    name = name.upper()
    if len(name) > 1:
        name = name[0] + '_' + name[1:]

    ax.annotate(
        name, naming_position(ax, p, lines, circles), color=color, fontsize=15
    )


def _draw_line(
        ax: matplotlib.axes.Axes,
        p1: Point,
        p2: Point,
        color: Any = 'white',
        lw: float = 1.2,
        alpha: float = 0.8,
) -> None:
    """"""Draw a line in matplotlib.""""""
    ls = '-'
    if color == '--':
        color = 'black'
        ls = '--'

    lx, ly = (p1.x, p2.x), (p1.y, p2.y)
    ax.plot(lx, ly, color=color, lw=lw, alpha=alpha, ls=ls)


def draw_line(
        ax: matplotlib.axes.Axes, line: Line, color: Any = 'white'
) -> tuple[Point, Point]:
    """"""Draw a line.""""""
    points = line.neighbors(gm.Point)
    if len(points) <= 1:
        return

    points = [p.num for p in points]
    p1, p2 = points[:2]

    pmin, pmax = (p1, 0.0), (p2, (p2 - p1).dot(p2 - p1))

    for p in points[2:]:
        v = (p - p1).dot(p2 - p1)
        if v < pmin[1]:
            pmin = p, v
        if v > pmax[1]:
            pmax = p, v

    p1, p2 = pmin[0], pmax[0]
    _draw_line(ax, p1, p2, color=color)
    return p1, p2


def _draw_circle(
        ax: matplotlib.axes.Axes, c: Circle, color: Any = 'cyan', lw: float = 1.2
) -> None:
    ls = '-'
    if color == '--':
        color = 'black'
        ls = '--'

    ax.add_patch(
        plt.Circle(
            (c.center.x, c.center.y),
            c.radius,
            color=color,
            alpha=0.8,
            fill=False,
            lw=lw,
            ls=ls,
        )
    )


def draw_circle(
        ax: matplotlib.axes.Axes, circle: Circle, color: Any = 'cyan'
) -> Circle:
    """"""Draw a circle.""""""
    if circle.num is not None:
        circle = circle.num
    else:
        points = circle.neighbors(gm.Point)
        if len(points) <= 2:
            return
        points = [p.num for p in points]
        p1, p2, p3 = points[:3]
        circle = Circle(p1=p1, p2=p2, p3=p3)

    _draw_circle(ax, circle, color)
    return circle


def mark_segment(
        ax: matplotlib.axes.Axes, p1: Point, p2: Point, color: Any, alpha: float
) -> None:
    _ = alpha
    x, y = (p1.x + p2.x) / 2, (p1.y + p2.y) / 2
    ax.scatter(x, y, color=color, alpha=1.0, marker='o', s=50)


def highlight_angle(
        ax: matplotlib.axes.Axes,
        a: Point,
        b: Point,
        c: Point,
        d: Point,
        color: Any,
        alpha: float,
) -> None:
    """"""Highlight an angle between ab and cd with (color, alpha).""""""
    try:
        a, b, c, d = bring_together(a, b, c, d)
    except:  # pylint: disable=bare-except
        return
    draw_angle(ax, a, b, d, color=color, alpha=alpha, frac=1.0)


def highlight(
        ax: matplotlib.axes.Axes,
        name: str,
        args: list[gm.Point],
        lcolor: Any,
        color1: Any,
        color2: Any,
) -> None:
    """"""Draw highlights.""""""
    args = list(map(lambda x: x.num if isinstance(x, gm.Point) else x, args))

    if name == 'cyclic':
        a, b, c, d = args
        _draw_circle(ax, Circle(p1=a, p2=b, p3=c), color=color1, lw=2.0)
    if name == 'coll':
        a, b, c = args
        a, b = max(a, b, c), min(a, b, c)
        _draw_line(ax, a, b, color=color1, lw=2.0)
    if name == 'para':
        a, b, c, d = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color2, lw=2.0)
    if name == 'eqangle':
        a, b, c, d, e, f, g, h = args

        x = line_line_intersection(Line(a, b), Line(c, d))
        if b.distance(x) > a.distance(x):
            a, b = b, a
        if d.distance(x) > c.distance(x):
            c, d = d, c
        a, b, d = x, a, c

        y = line_line_intersection(Line(e, f), Line(g, h))
        if f.distance(y) > e.distance(y):
            e, f = f, e
        if h.distance(y) > g.distance(y):
            g, h = h, g
        e, f, h = y, e, g

        _draw_line(ax, a, b, color=lcolor, lw=2.0)
        _draw_line(ax, a, d, color=lcolor, lw=2.0)
        _draw_line(ax, e, f, color=lcolor, lw=2.0)
        _draw_line(ax, e, h, color=lcolor, lw=2.0)
        if color1 == '--':
            color1 = 'red'
        draw_angle(ax, a, b, d, color=color1, alpha=0.5)
        if color2 == '--':
            color2 = 'red'
        draw_angle(ax, e, f, h, color=color2, alpha=0.5)
    if name == 'perp':
        a, b, c, d = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color1, lw=2.0)
    if name == 'ratio':
        a, b, c, d, m, n = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color2, lw=2.0)
    if name == 'cong':
        a, b, c, d = args
        _draw_line(ax, a, b, color=color1, lw=2.0)
        _draw_line(ax, c, d, color=color2, lw=2.0)
    if name == 'midp':
        m, a, b = args
        _draw_line(ax, a, m, color=color1, lw=2.0, alpha=0.5)
        _draw_line(ax, b, m, color=color2, lw=2.0, alpha=0.5)
    if name == 'eqratio':
        a, b, c, d, m, n, p, q = args
        _draw_line(ax, a, b, color=color1, lw=2.0, alpha=0.5)
        _draw_line(ax, c, d, color=color2, lw=2.0, alpha=0.5)
        _draw_line(ax, m, n, color=color1, lw=2.0, alpha=0.5)
        _draw_line(ax, p, q, color=color2, lw=2.0, alpha=0.5)

        
def _draw(
        ax: matplotlib.axes.Axes,
        points: list[gm.Point],
        lines: list[gm.Line],
        circles: list[gm.Circle],
        goal: Any,
        equals: list[tuple[Any, Any]],
        highlights: list[tuple[str, list[gm.Point]]],
):
    """"""Draw everything.""""""
    colors = ['red', 'green', 'blue', 'orange', 'magenta', 'purple']
    pcolor = 'black'
    lcolor = 'black'
    ccolor = 'grey'
    if get_theme() == 'dark':
        pcolor, lcolor, ccolor = 'white', 'white', 'cyan'
    elif get_theme() == 'light':
        pcolor, lcolor, ccolor = 'black', 'black', 'blue'
    elif get_theme() == 'grey':
        pcolor, lcolor, ccolor = 'black', 'black', 'grey'
        colors = ['grey']

    line_boundaries = []
    for l in lines:
        p1, p2 = draw_line(ax, l, color=lcolor)
        line_boundaries.append((p1, p2))
    circles = [draw_circle(ax, c, color=ccolor) for c in circles]

    for p in points:
        draw_point(ax, p.num, p.name, line_boundaries, circles, color=pcolor)

    if equals:
        for i, segs in enumerate(equals['segments']):
            color = colors[i % len(colors)]
            for a, b in segs:
                mark_segment(ax, a, b, color, 0.5)

        for i, angs in enumerate(equals['angles']):
            color = colors[i % len(colors)]
            for a, b, c, d in angs:
                highlight_angle(ax, a, b, c, d, color, 0.5)

    if highlights:
        global HCOLORS
        if HCOLORS is None:
            HCOLORS = [k for k in mcolors.TABLEAU_COLORS.keys() if 'red' not in k]

        for i, (name, args) in enumerate(highlights):
            color_i = HCOLORS[i % len(HCOLORS)]
            highlight(ax, name, args, 'black', color_i, color_i)

    if goal:
        name, args = goal
        lcolor = color1 = color2 = 'red'
        highlight(ax, name, args, lcolor, color1, color2)


def set_theme(theme) -> None:
    global THEME
    THEME = theme


def get_theme() -> str:
    return THEME


def draw(
        points: list[gm.Point],
        lines: list[gm.Line],
        circles: list[gm.Circle],
        segments: list[gm.Segment],
        goal: Any = None,
        highlights: list[tuple[str, list[gm.Point]]] = None,
        equals: list[tuple[Any, Any]] = None,
        block: bool = True,
        save_to: str = None,
        theme: str = 'dark',
) -> None:
    """"""Draw everything on the same canvas.""""""
    plt.close()
    imsize = 512 / 100
    fig, ax = plt.subplots(figsize=(imsize, imsize), dpi=100)

    set_theme(theme)

    if get_theme() == 'dark':
        ax.set_facecolor((0.0, 0.0, 0.0))
    else:
        ax.set_facecolor((1.0, 1.0, 1.0))

    _draw(ax, points, lines, circles, goal, equals, highlights)

    plt.axis('equal')
    fig.subplots_adjust(left=0, right=1, top=1, bottom=0, wspace=0, hspace=0)
    if points:
        xmin = min([p.num.x for p in points])
        xmax = max([p.num.x for p in points])
        ymin = min([p.num.y for p in points])
        ymax = max([p.num.y for p in points])
        plt.margins((xmax - xmin) * 0.1, (ymax - ymin) * 0.1)

    plt.show(block=block)


def close_enough(a: float, b: float, tol: float = 1e-12) -> bool:
    return abs(a - b) < tol


def assert_close_enough(a: float, b: float, tol: float = 1e-12) -> None:
    assert close_enough(a, b, tol), f'|{a}-{b}| = {abs(a - b)} >= {tol}'


def ang_of(tail: Point, head: Point) -> float:
    vector = head - tail
    arctan = np.arctan2(vector.y, vector.x) % (2 * np.pi)
    return arctan


def ang_between(tail: Point, head1: Point, head2: Point) -> float:
    ang1 = ang_of(tail, head1)
    ang2 = ang_of(tail, head2)
    diff = ang1 - ang2
    # return diff % (2*np.pi)
    if diff > np.pi:
        return diff - 2 * np.pi
    if diff < -np.pi:
        return 2 * np.pi + diff
    return diff


def head_from(tail: Point, ang: float, length: float = 1) -> Point:
    vector = Point(np.cos(ang) * length, np.sin(ang) * length)
    return tail + vector


def random_points(n: int = 3) -> list[Point]:
    return [Point(unif(-1, 1), unif(-1, 1)) for _ in range(n)]


def random_rfss(*points: list[Point]) -> list[Point]:
    """"""Random rotate-flip-scale-shift a point cloud.""""""
    # center point cloud.
    average = sum(points, Point(0.0, 0.0)) * (1.0 / len(points))
    points = [p - average for p in points]

    # rotate
    ang = unif(0.0, 2 * np.pi)
    sin, cos = np.sin(ang), np.cos(ang)
    # scale and shift
    scale = unif(0.5, 2.0)
    shift = Point(unif(-1, 1), unif(-1, 1))
    points = [p.rotate(sin, cos) * scale + shift for p in points]

    # randomly flip
    if np.random.rand() < 0.5:
        points = [p.flip() for p in points]

    return points


def reduce(
        objs: list[Union[Point, Line, Circle, HalfLine, HoleCircle]],
        existing_points: list[Point],
) -> list[Point]:
    """"""Reduce intersecting objects into one point of intersections.""""""
    if all(isinstance(o, Point) for o in objs):
        return objs

    elif len(objs) == 1:
        return objs[0].sample_within(existing_points)

    elif len(objs) == 2:
        a, b = objs
        result = a.intersect(b)
        if isinstance(result, Point):
            return [result]
        a, b = result
        a_close = any([a.close(x) for x in existing_points])
        if a_close:
            return [b]
        b_close = any([b.close(x) for x in existing_points])
        if b_close:
            return [a]
        return [np.random.choice([a, b])]

    else:
        raise ValueError(f'Cannot reduce {objs}')


def sketch(
        name: str, args: list[Union[Point, gm.Point]]
) -> list[Union[Point, Line, Circle, HalfLine, HoleCircle]]:
    fun = globals()['sketch_' + name]
    args = [p.num if isinstance(p, gm.Point) else p for p in args]
    out = fun(args)

    # out can be one or multiple {Point/Line/HalfLine}
    if isinstance(out, (tuple, list)):
        return list(out)
    return [out]


def sketch_on_opline(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b = args
    return HalfLine(a, a + a - b)


def sketch_on_hline(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b = args
    return HalfLine(a, b)


def sketch_ieq_triangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)

    c, _ = Circle(a, p1=b).intersect(Circle(b, p1=a))
    return a, b, c


def sketch_incenter2(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    l1 = sketch_bisect([b, a, c])
    l2 = sketch_bisect([a, b, c])
    i = line_line_intersection(l1, l2)
    x = i.foot(Line(b, c))
    y = i.foot(Line(c, a))
    z = i.foot(Line(a, b))
    return x, y, z, i


def sketch_excenter2(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    l1 = sketch_bisect([b, a, c])
    l2 = sketch_exbisect([a, b, c])
    i = line_line_intersection(l1, l2)
    x = i.foot(Line(b, c))
    y = i.foot(Line(c, a))
    z = i.foot(Line(a, b))
    return x, y, z, i


def sketch_centroid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    x = (b + c) * 0.5
    y = (c + a) * 0.5
    z = (a + b) * 0.5
    i = line_line_intersection(Line(a, x), Line(b, y))
    return x, y, z, i


def sketch_ninepoints(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    x = (b + c) * 0.5
    y = (c + a) * 0.5
    z = (a + b) * 0.5
    c = Circle(p1=x, p2=y, p3=z)
    return x, y, z, c.center


def sketch_2l1c(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch a circle touching two lines and another circle.""""""
    a, b, c, p = args
    bc, ac = Line(b, c), Line(a, c)
    circle = Circle(p, p1=a)

    d, d_ = line_circle_intersection(p.perpendicular_line(bc), circle)
    if bc.diff_side(d_, a):
        d = d_

    e, e_ = line_circle_intersection(p.perpendicular_line(ac), circle)
    if ac.diff_side(e_, b):
        e = e_

    df = d.perpendicular_line(Line(p, d))
    ef = e.perpendicular_line(Line(p, e))
    f = line_line_intersection(df, ef)

    g, g_ = line_circle_intersection(Line(c, f), circle)
    if bc.same_side(g_, a):
        g = g_

    b_ = c + (b - c) / b.distance(c)
    a_ = c + (a - c) / a.distance(c)
    m = (a_ + b_) * 0.5
    x = line_line_intersection(Line(c, m), Line(p, g))
    return x.foot(ac), x.foot(bc), g, x


def sketch_3peq(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a, b, c = args
    ab, bc, ca = Line(a, b), Line(b, c), Line(c, a)

    z = b + (c - b) * np.random.uniform(-0.5, 1.5)

    z_ = z * 2 - c
    l = z_.parallel_line(ca)
    x = line_line_intersection(l, ab)
    y = z * 2 - x
    return x, y, z


def try_to_sketch_intersect(
        name1: str,
        args1: list[Union[gm.Point, Point]],
        name2: str,
        args2: list[Union[gm.Point, Point]],
        existing_points: list[Point],
) -> Optional[Point]:
    """"""Try to sketch an intersection between two objects.""""""
    obj1 = sketch(name1, args1)[0]
    obj2 = sketch(name2, args2)[0]

    if isinstance(obj1, Line) and isinstance(obj2, Line):
        fn = line_line_intersection
    elif isinstance(obj1, Circle) and isinstance(obj2, Circle):
        fn = circle_circle_intersection
    else:
        fn = line_circle_intersection
        if isinstance(obj2, Line) and isinstance(obj1, Circle):
            obj1, obj2 = obj2, obj1

    try:
        x = fn(obj1, obj2)
    except:  # pylint: disable=bare-except
        return None

    if isinstance(x, Point):
        return x

    x1, x2 = x

    close1 = check_too_close([x1], existing_points)
    far1 = check_too_far([x1], existing_points)
    if not close1 and not far1:
        return x1
    close2 = check_too_close([x2], existing_points)
    far2 = check_too_far([x2], existing_points)
    if not close2 and not far2:
        return x2

    return None


def sketch_acircle(args: tuple[gm.Point, ...]) -> Circle:
    a, b, c, d, f = args
    de = sketch_aline([c, a, b, f, d])
    fe = sketch_aline([a, c, b, d, f])
    e = line_line_intersection(de, fe)
    return Circle(p1=d, p2=e, p3=f)


def sketch_aline(args: tuple[gm.Point, ...]) -> HalfLine:
    """"""Sketch the construction aline.""""""
    A, B, C, D, E = args
    ab = A - B
    cb = C - B
    de = D - E

    dab = A.distance(B)
    ang_ab = np.arctan2(ab.y / dab, ab.x / dab)

    dcb = C.distance(B)
    ang_bc = np.arctan2(cb.y / dcb, cb.x / dcb)

    dde = D.distance(E)
    ang_de = np.arctan2(de.y / dde, de.x / dde)

    ang_ex = ang_de + ang_bc - ang_ab
    X = E + Point(np.cos(ang_ex), np.sin(ang_ex))
    return HalfLine(E, X)


def sketch_amirror(args: tuple[gm.Point, ...]) -> HalfLine:
    """"""Sketch the angle mirror.""""""
    A, B, C = args  # pylint: disable=invalid-name
    ab = A - B
    cb = C - B

    dab = A.distance(B)
    ang_ab = np.arctan2(ab.y / dab, ab.x / dab)
    dcb = C.distance(B)
    ang_bc = np.arctan2(cb.y / dcb, cb.x / dcb)

    ang_bx = 2 * ang_bc - ang_ab
    X = B + Point(np.cos(ang_bx), np.sin(ang_bx))  # pylint: disable=invalid-name
    return HalfLine(B, X)


def sketch_bisect(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    ab = a.distance(b)
    bc = b.distance(c)
    x = b + (c - b) * (ab / bc)
    m = (a + x) * 0.5
    return Line(b, m)


def sketch_exbisect(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    return sketch_bisect(args).perpendicular_line(b)


def sketch_bline(args: tuple[gm.Point, ...]) -> Line:
    a, b = args
    m = (a + b) * 0.5
    return m.perpendicular_line(Line(a, b))


def sketch_dia(args: tuple[gm.Point, ...]) -> Circle:
    a, b = args
    return Circle((a + b) * 0.5, p1=a)


def sketch_tangent(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, o, b = args
    dia = sketch_dia([a, o])
    return circle_circle_intersection(Circle(o, p1=b), dia)


def sketch_circle(args: tuple[gm.Point, ...]) -> Circle:
    a, b, c = args
    return Circle(center=a, radius=b.distance(c))


def sketch_cc_tangent(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch tangents to two circles.""""""
    o, a, w, b = args
    ra, rb = o.distance(a), w.distance(b)

    ow = Line(o, w)
    if close_enough(ra, rb):
        oo = ow.perpendicular_line(o)
        oa = Circle(o, ra)
        x, z = line_circle_intersection(oo, oa)
        y = x + w - o
        t = z + w - o
        return x, y, z, t

    swap = rb > ra
    if swap:
        o, a, w, b = w, b, o, a
        ra, rb = rb, ra

    oa = Circle(o, ra)
    q = o + (w - o) * ra / (ra - rb)

    x, z = circle_circle_intersection(sketch_dia([o, q]), oa)
    y = w.foot(Line(x, q))
    t = w.foot(Line(z, q))

    if swap:
        x, y, z, t = y, x, t, z

    return x, y, z, t


def sketch_hcircle(args: tuple[gm.Point, ...]) -> HoleCircle:
    a, b = args
    return HoleCircle(center=a, radius=a.distance(b), hole=b)


def sketch_e5128(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b, c, d = args
    ad = Line(a, d)

    g = (a + b) * 0.5
    de = Line(d, g)

    e, f = line_circle_intersection(de, Circle(c, p1=b))

    if e.distance(d) < f.distance(d):
        e = f
    return e, g


def sketch_eq_quadrangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch quadrangle with two equal opposite sides.""""""
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)

    length = np.random.uniform(0.5, 2.0)
    ang = np.random.uniform(np.pi / 3, np.pi * 2 / 3)
    d = head_from(a, ang, length)

    ang = ang_of(b, d)
    ang = np.random.uniform(ang / 10, ang / 9)
    c = head_from(b, ang, length)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_eq_trapezoid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)
    l = unif(0.5, 2.0)

    height = unif(0.5, 2.0)
    c = Point(0.5 + l / 2.0, height)
    d = Point(0.5 - l / 2.0, height)

    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_eqangle2(args: tuple[gm.Point, ...]) -> Point:
    """"""Sketch the def eqangle2.""""""
    a, b, c = args

    d = c * 2 - b

    ba = b.distance(a)
    bc = b.distance(c)
    l = ba * ba / bc

    if unif(0.0, 1.0) < 0.5:
        be = min(l, bc)
        be = unif(be * 0.1, be * 0.9)
    else:
        be = max(l, bc)
        be = unif(be * 1.1, be * 1.5)

    e = b + (c - b) * (be / bc)
    y = b + (a - b) * (be / l)
    return line_line_intersection(Line(c, y), Line(a, e))


def sketch_eqangle3(args: tuple[gm.Point, ...]) -> Circle:
    a, b, d, e, f = args
    de = d.distance(e)
    ef = e.distance(f)
    ab = b.distance(a)
    ang_ax = ang_of(a, b) + ang_between(e, d, f)
    x = head_from(a, ang_ax, length=de / ef * ab)
    return Circle(p1=a, p2=b, p3=x)


def sketch_eqdia_quadrangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch quadrangle with two equal diagonals.""""""
    m = unif(0.3, 0.7)
    n = unif(0.3, 0.7)
    a = Point(-m, 0.0)
    c = Point(1 - m, 0.0)
    b = Point(0.0, -n)
    d = Point(0.0, 1 - n)

    ang = unif(-0.25 * np.pi, 0.25 * np.pi)
    sin, cos = np.sin(ang), np.cos(ang)
    b = b.rotate(sin, cos)
    d = d.rotate(sin, cos)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_free(args: tuple[gm.Point, ...]) -> Point:
    return random_points(1)[0]


def sketch_isos(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    base = unif(0.5, 1.5)
    height = unif(0.5, 1.5)

    b = Point(-base / 2, 0.0)
    c = Point(base / 2, 0.0)
    a = Point(0.0, height)
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_line(args: tuple[gm.Point, ...]) -> Line:
    a, b = args
    return Line(a, b)


def sketch_cyclic(args: tuple[gm.Point, ...]) -> Circle:
    a, b, c = args
    return Circle(p1=a, p2=b, p3=c)


def sketch_hline(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b = args
    return HalfLine(a, b)


def sketch_midp(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    return (a + b) * 0.5


def sketch_pentagon(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    points = [Point(1.0, 0.0)]
    ang = 0.0

    for i in range(4):
        ang += (2 * np.pi - ang) / (5 - i) * unif(0.5, 1.5)
        point = Point(np.cos(ang), np.sin(ang))
        points.append(point)

    a, b, c, d, e = points  # pylint: disable=unbalanced-tuple-unpacking
    a, b, c, d, e = random_rfss(a, b, c, d, e)
    return a, b, c, d, e


def sketch_pline(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    return a.parallel_line(Line(b, c))


def sketch_pmirror(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    return b * 2 - a


def sketch_quadrangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    """"""Sketch a random quadrangle.""""""
    m = unif(0.3, 0.7)
    n = unif(0.3, 0.7)

    a = Point(-m, 0.0)
    c = Point(1 - m, 0.0)
    b = Point(0.0, -unif(0.25, 0.75))
    d = Point(0.0, unif(0.25, 0.75))

    ang = unif(-0.25 * np.pi, 0.25 * np.pi)
    sin, cos = np.sin(ang), np.cos(ang)
    b = b.rotate(sin, cos)
    d = d.rotate(sin, cos)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_r_trapezoid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 1.0)
    d = Point(0.0, 0.0)
    b = Point(unif(0.5, 1.5), 1.0)
    c = Point(unif(0.5, 1.5), 0.0)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_r_triangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(0.0, unif(0.5, 2.0))
    c = Point(unif(0.5, 2.0), 0.0)
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_rectangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(0.0, 1.0)
    l = unif(0.5, 2.0)
    c = Point(l, 1.0)
    d = Point(l, 0.0)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_reflect(args: tuple[gm.Point, ...]) -> Point:
    a, b, c = args
    m = a.foot(Line(b, c))
    return m * 2 - a


def sketch_risos(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(0.0, 1.0)
    c = Point(1.0, 0.0)
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_rotaten90(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    ang = -np.pi / 2
    return a + (b - a).rotate(np.sin(ang), np.cos(ang))


def sketch_rotatep90(args: tuple[gm.Point, ...]) -> Point:
    a, b = args
    ang = np.pi / 2
    return a + (b - a).rotate(np.sin(ang), np.cos(ang))


def sketch_s_angle(args: tuple[gm.Point, ...]) -> HalfLine:
    a, b, y = args
    ang = y / 180 * np.pi
    x = b + (a - b).rotatea(ang)
    return HalfLine(b, x)


def sketch_segment(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b = random_points(2)
    return a, b


def sketch_shift(args: tuple[gm.Point, ...]) -> Point:
    a, b, c = args
    return c + (b - a)


def sketch_square(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b = args
    c = b + (a - b).rotatea(-np.pi / 2)
    d = a + (b - a).rotatea(np.pi / 2)
    return c, d


def sketch_isquare(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)
    c = Point(1.0, 1.0)
    d = Point(0.0, 1.0)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_tline(args: tuple[gm.Point, ...]) -> Line:
    a, b, c = args
    return a.perpendicular_line(Line(b, c))


def sketch_trapezoid(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    d = Point(0.0, 0.0)
    c = Point(1.0, 0.0)

    base = unif(0.5, 2.0)
    height = unif(0.5, 2.0)
    a = Point(unif(0.2, 0.5), height)
    b = Point(a.x + base, height)
    a, b, c, d = random_rfss(a, b, c, d)
    return a, b, c, d


def sketch_triangle(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    a = Point(0.0, 0.0)
    b = Point(1.0, 0.0)
    ac = unif(0.5, 2.0)
    ang = unif(0.2, 0.8) * np.pi
    c = head_from(a, ang, ac)
    return a, b, c


def sketch_triangle12(args: tuple[gm.Point, ...]) -> tuple[Point, ...]:
    b = Point(0.0, 0.0)
    c = Point(unif(1.5, 2.5), 0.0)
    a, _ = circle_circle_intersection(Circle(b, 1.0), Circle(c, 2.0))
    a, b, c = random_rfss(a, b, c)
    return a, b, c


def sketch_trisect(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    """"""Sketch two trisectors of an angle.""""""
    a, b, c = args
    ang1 = ang_of(b, a)
    ang2 = ang_of(b, c)

    swap = 0
    if ang1 > ang2:
        ang1, ang2 = ang2, ang1
        swap += 1

    if ang2 - ang1 > np.pi:
        ang1, ang2 = ang2, ang1 + 2 * np.pi
        swap += 1

    angx = ang1 + (ang2 - ang1) / 3
    angy = ang2 - (ang2 - ang1) / 3

    x = b + Point(np.cos(angx), np.sin(angx))
    y = b + Point(np.cos(angy), np.sin(angy))

    ac = Line(a, c)
    x = line_line_intersection(Line(b, x), ac)
    y = line_line_intersection(Line(b, y), ac)

    if swap == 1:
        return y, x
    return x, y


def sketch_trisegment(args: tuple[gm.Point, ...]) -> tuple[Point, Point]:
    a, b = args
    x, y = a + (b - a) * (1.0 / 3), a + (b - a) * (2.0 / 3)
    return x, y
import types

# Create the module Numericals as nm
nm = types.ModuleType('nm')

# Add classes to nm
nm.Point = Point
nm.Line = Line
nm.HalfLine = HalfLine
nm.Circle = Circle
nm.HoleCircle = HoleCircle
nm.InvalidLineIntersectError = InvalidLineIntersectError
nm.InvalidQuadSolveError = InvalidQuadSolveError

# Add functions to nm
nm._perpendicular_bisector = _perpendicular_bisector
nm.same_sign = same_sign
nm.solve_quad = solve_quad
nm.circle_circle_intersection = circle_circle_intersection
nm.line_circle_intersection = line_circle_intersection
nm._check_between = _check_between
nm.circle_segment_intersect = circle_segment_intersect
nm.line_segment_intersection = line_segment_intersection
nm.line_line_intersection = line_line_intersection
nm.check_too_close = check_too_close
nm.check_too_far = check_too_far
nm.check_aconst = check_aconst
nm.check = check
nm.check_circle = check_circle
nm.check_coll = check_coll
nm.check_ncoll = check_ncoll
nm.check_sameside = check_sameside
nm.check_para_or_coll = check_para_or_coll
nm.check_para = check_para
nm.check_perp = check_perp
nm.check_cyclic = check_cyclic
nm.bring_together = bring_together
nm.same_clock = same_clock
nm.check_const_angle = check_const_angle
nm.check_eqangle = check_eqangle
nm.check_eqratio = check_eqratio
nm.check_cong = check_cong
nm.check_midp = check_midp
nm.check_simtri = check_simtri
nm.check_contri = check_contri
nm.check_ratio = check_ratio
nm.draw_angle = draw_angle
nm.naming_position = naming_position
nm.draw_point = draw_point
nm._draw_line = _draw_line
nm.draw_line = draw_line
nm._draw_circle = _draw_circle
nm.draw_circle = draw_circle
nm.mark_segment = mark_segment
nm.highlight_angle = highlight_angle
nm.highlight = highlight
nm._draw = _draw
nm.set_theme = set_theme
nm.get_theme = get_theme
nm.draw = draw
nm.close_enough = close_enough
nm.assert_close_enough = assert_close_enough
nm.ang_of = ang_of
nm.ang_between = ang_between
nm.head_from = head_from
nm.random_points = random_points
nm.random_rfss = random_rfss
nm.reduce = reduce
nm.sketch = sketch
nm.sketch_on_opline = sketch_on_opline
nm.sketch_on_hline = sketch_on_hline
nm.sketch_ieq_triangle = sketch_ieq_triangle
nm.sketch_incenter2 = sketch_incenter2
nm.sketch_excenter2 = sketch_excenter2
nm.sketch_centroid = sketch_centroid
nm.sketch_ninepoints = sketch_ninepoints
nm.sketch_2l1c = sketch_2l1c
nm.sketch_3peq = sketch_3peq
nm.try_to_sketch_intersect = try_to_sketch_intersect
nm.sketch_acircle = sketch_acircle
nm.sketch_aline = sketch_aline
nm.sketch_amirror = sketch_amirror
nm.sketch_bisect = sketch_bisect
nm.sketch_exbisect = sketch_exbisect
nm.sketch_bline = sketch_bline
nm.sketch_dia = sketch_dia
nm.sketch_tangent = sketch_tangent
nm.sketch_circle = sketch_circle
nm.sketch_cc_tangent = sketch_cc_tangent
nm.sketch_hcircle = sketch_hcircle
nm.sketch_e5128 = sketch_e5128
nm.sketch_eq_quadrangle = sketch_eq_quadrangle
nm.sketch_eq_trapezoid = sketch_eq_trapezoid
nm.sketch_eqangle2 = sketch_eqangle2
nm.sketch_eqangle3 = sketch_eqangle3
nm.sketch_eqdia_quadrangle = sketch_eqdia_quadrangle
nm.sketch_free = sketch_free
nm.sketch_isos = sketch_isos
nm.sketch_line = sketch_line
nm.sketch_cyclic = sketch_cyclic
nm.sketch_hline = sketch_hline
nm.sketch_midp = sketch_midp
nm.sketch_pentagon = sketch_pentagon
nm.sketch_pline = sketch_pline
nm.sketch_pmirror = sketch_pmirror
nm.sketch_quadrangle = sketch_quadrangle
nm.sketch_r_trapezoid = sketch_r_trapezoid
nm.sketch_r_triangle = sketch_r_triangle
nm.sketch_rectangle = sketch_rectangle
nm.sketch_reflect = sketch_reflect
nm.sketch_risos = sketch_risos
nm.sketch_rotaten90 = sketch_rotaten90
nm.sketch_rotatep90 = sketch_rotatep90
nm.sketch_s_angle = sketch_s_angle
nm.sketch_segment = sketch_segment
nm.sketch_shift = sketch_shift
nm.sketch_square = sketch_square
nm.sketch_isquare = sketch_isquare
nm.sketch_tline = sketch_tline
nm.sketch_trapezoid = sketch_trapezoid
nm.sketch_triangle = sketch_triangle
nm.sketch_triangle12 = sketch_triangle12
nm.sketch_trisect = sketch_trisect
nm.sketch_trisegment = sketch_trisegment
""""""Utilizations for graph representation.

In these functions, we're dealing with permutations and combinations.
These are fundamental concepts in combinatorics. 

A permutation of a set is an arrangement of its members into a sequence or linear order. 
In contrast, a combination is a way of selecting items from a collection, such that the order of selection does not matter. 

The functions 'perm3' and 'perm4' extend these ideas to 3 and 4 elements, respectively.
""""""



def _cross(elems1, elems2):
    """"""Generator function for producing all pairs of elements from two lists.

    Args:
        elems1 (list): The first list of elements.
        elems2 (list): The second list of elements.

    Yields:
        tuple: A pair of elements, one from each list.

    Example:
        >>> list(_cross([1, 2], ['a', 'b']))
        [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
    """"""
    for e1 in elems1:
        for e2 in elems2:
            yield e1, e2


def cross(elems1, elems2):
    """"""Function to get all pairs of elements from two lists.

    Args:
        elems1 (list): The first list of elements.
        elems2 (list): The second list of elements.

    Returns:
        list of tuples: A list containing all pairs of elements.

    Example:
        >>> cross([1, 2], ['a', 'b'])
        [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
    """"""
    return list(_cross(elems1, elems2))


def _comb2(elems):
    """"""Generator function for producing all 2-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 2-element combination of the list.

    Example:
        >>> list(_comb2([1, 2, 3]))
        [(1, 2), (1, 3), (2, 3)]
    """"""
    if len(elems) < 2:
        return
    for i, e1 in enumerate(elems[:-1]):
        for e2 in elems[i + 1:]:
            yield e1, e2


def comb2(elems):
    """"""Function to get all 2-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 2-element combinations.

    Example:
        >>> comb2([1, 2, 3])
        [(1, 2), (1, 3), (2, 3)]
    """"""
    return list(_comb2(elems))


def _comb3(elems):
    """"""Generator function for producing all 3-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 3-element combination of the list.

    Example:
        >>> list(_comb3([1, 2, 3, 4]))
        [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]
    """"""
    if len(elems) < 3:
        return
    for i, e1 in enumerate(elems[:-2]):
        for j, e2 in enumerate(elems[i + 1: -1]):
            for e3 in elems[i + j + 2:]:
                yield e1, e2, e3


def comb3(elems):
    """"""Function to get all 3-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 3-element combinations.

    Example:
        >>> comb3([1, 2, 3, 4])
        [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]
    """"""
    return list(_comb3(elems))


def _comb4(elems):
    """"""Generator function for producing all 4-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 4-element combination of the list.

    Example:
        >>> list(_comb4([1, 2, 3, 4, 5]))
        [(1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 4, 5), (1, 3, 4, 5), (2, 3, 4, 5)]
    """"""
    if len(elems) < 4:
        return
    for i, e1 in enumerate(elems[:-3]):
        for j, e2 in enumerate(elems[i + 1: -2]):
            for e3, e4 in _comb2(elems[i + j + 2:]):
                yield e1, e2, e3, e4


def comb4(elems):
    """"""Function to get all 4-element combinations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 4-element combinations.

    Example:
        >>> comb4([1, 2, 3, 4, 5])
        [(1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 4, 5), (1, 3, 4, 5), (2, 3, 4, 5)]
    """"""
    return list(_comb4(elems))


def _perm2(elems):
    """"""Generator function for producing all 2-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 2-element permutation of the list.

    Example:
        >>> list(_perm2([1, 2]))
        [(1, 2), (2, 1)]
    """"""
    for e1, e2 in comb2(elems):
        yield e1, e2
        yield e2, e1


def perm2(elems):
    """"""Function to get all 2-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 2-element permutations.

    Example:
        >>> perm2([1, 2])
        [(1, 2), (2, 1)]
    """"""
    return list(_perm2(elems))


def _all_4points(l1, l2):
    """"""Generator function for producing all 4-point permutations from two lines.

    Args:
        l1 (Line): The first line.
        l2 (Line): The second line.

    Yields:
        tuple: A 4-point permutation, two from each line.

    Example:
        >>> line1 = Line(Point(0, 0), Point(1, 1))
        >>> line2 = Line(Point(0, 1), Point(1, 0))
        >>> list(_all_4points(line1, line2))
        # Yields all permutations of points on line1 and line2
    """"""
    p1s = l1.neighbors(gm.Point)
    p2s = l2.neighbors(gm.Point)
    for a, b in perm2(p1s):
        for c, d in perm2(p2s):
            yield a, b, c, d


def all_4points(l1, l2):
    """"""Function to get all 4-point permutations from two lines.

    Args:
        l1 (Line): The first line.
        l2 (Line): The second line.

    Returns:
        list of tuples: A list of all 4-point permutations, two from each line.

    Example:
        >>> line1 = Line(Point(0, 0), Point(1, 1))
        >>> line2 = Line(Point(0, 1), Point(1, 0))
        >>> all_4points(line1, line2)
        # Returns all permutations of points on line1 and line2
    """"""
    return list(_all_4points(l1, l2))


def _all_8points(l1, l2, l3, l4):
    """"""Generator function for producing all 8-point permutations from four lines.

    Args:
        l1, l2, l3, l4 (Line): The four lines.

    Yields:
        tuple: An 8-point permutation, two from each line.

    Example:
        >>> line1, line2, line3, line4 = [Line(Point(0, 0), Point(1, 1))] * 4
        >>> list(_all_8points(line1, line2, line3, line4))
        # Yields all permutations of points on the four lines
    """"""
    for a, b, c, d in all_4points(l1, l2):
        for e, f, g, h in all_4points(l3, l4):
            yield (a, b, c, d, e, f, g, h)


def all_8points(l1, l2, l3, l4):
    """"""Function to get all 8-point permutations from four lines.

    Each line contributes two points, resulting in permutations of 8 points total.

    Args:
        l1, l2, l3, l4 (Line): The four lines.

    Returns:
        list of tuples: A list of all 8-point permutations, two from each line.

    Example:
        >>> line1, line2, line3, line4 = [Line(Point(0, 0), Point(1, 1))] * 4
        >>> all_8points(line1, line2, line3, line4)
        # Returns all permutations of points on the four lines
    """"""
    return list(_all_8points(l1, l2, l3, l4))


def _perm3(elems):
    """"""Generator function for producing all 3-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 3-element permutation of the list.

    Example:
        >>> list(_perm3([1, 2, 3]))
        [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
    """"""
    for x in elems:
        for y in elems:
            if y == x:
                continue
            for z in elems:
                if z not in (x, y):
                    yield x, y, z


def perm3(elems):
    """"""Function to get all 3-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 3-element permutations.

    Example:
        >>> perm3([1, 2, 3])
        [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
    """"""
    return list(_perm3(elems))


def _perm4(elems):
    """"""Generator function for producing all 4-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Yields:
        tuple: A 4-element permutation of the list.

    Example:
        >>> list(_perm4([1, 2, 3, 4]))
        # Yields all 4-element permutations of [1, 2, 3, 4]
    """"""
    for x in elems:
        for y in elems:
            if y == x:
                continue
            for z in elems:
                if z in (x, y):
                    continue
                for t in elems:
                    if t not in (x, y, z):
                        yield x, y, z, t


def perm4(elems):
    """"""Function to get all 4-element permutations of a list.

    Args:
        elems (list): The list of elements.

    Returns:
        list of tuples: A list of all 4-element permutations.

    Example:
        >>> perm4([1, 2, 3, 4])
        # Returns all 4-element permutations of [1, 2, 3, 4]
    """"""
    return list(_perm4(elems))

# Defining lists of sketch types

# List of sketch types that don't depend on existing elements.
#   - These are 'freely' created without prerequisites.
FREE = [
    'free', 'segment', 'r_triangle', 'risos', 'triangle', 'triangle12',
    'ieq_triangle', 'eq_quadrangle', 'eq_trapezoid', 'eqdia_quadrangle',
    'quadrangle', 'r_trapezoid', 'rectangle', 'isquare', 'trapezoid',
    'pentagon', 'iso_triangle',
]

# List of sketch types that depend on the intersection of elements.
#   - These are created at the intersection of existing elements like lines and circles.
INTERSECT = [
    'angle_bisector', 'angle_mirror', 'eqdistance', 'lc_tangent',
    'on_aline', 'on_bline', 'on_circle', 'on_line', 'on_pline', 'on_tline',
    'on_dia', 's_angle', 'on_opline', 'eqangle3',
]


class DepCheckFailError(Exception):
    """"""Exception raised when a dependency check fails.

    This exception is used to indicate a failure in checking dependencies 
    for geometric constructions.

    Attributes:
        message (str): Explanation of the error.
    """"""
    pass


class PointTooCloseError(Exception):
    """"""Exception raised when a newly generated point is too close to existing points.

    This exception is used to avoid clustering of points in geometric constructions.

    Attributes:
        message (str): Explanation of the error.
    """"""
    pass


class PointTooFarError(Exception):
    """"""Exception raised when a newly generated point is too far from existing points.

    This exception is used to maintain a reasonable proximity of points in geometric constructions.

    Attributes:
        message (str): Explanation of the error.
    """"""
    pass


def create_consts_str(g: Graph, s: str) -> Union[Ratio, Angle]:
    """"""Create constants in string format and add them to the graph.

    This function takes a string representation of a constant (either a ratio or an angle)
    and adds the corresponding constant node to the graph.

    Args:
        g (Graph): The graph to which the constant is added.
        s (str): The string representation of the constant.

    Returns:
        Union[Ratio, Angle]: The created constant node.

    Raises:
        ValueError: If the string format is incorrect.

    Example:
        >>> g = Graph()
        >>> create_consts_str(g, '180/pi')
        # This will create an Angle constant in the graph
    """"""
        # If the string contains 'pi/', it is treated as an angle. 
        #   - The format is expected to be ""npi/d"" where n and d are integers.
        if 'pi/' in s:
            # Splitting the string into numerator (n) and denominator (d) parts.
            n, d = s.split('pi/')  
            
            # Converting both parts to integers.
            n, d = int(n), int(d)  
            
            # Creating or retrieving an angle constant from the graph.
            p0, _ = g.get_or_create_const_ang(n, d)  
            
        # If the string does not contain 'pi/', it is treated as a ratio. 
        #   - The format is expected to be ""n/d"".
        else:
            # Splitting the string into numerator (n) and denominator (d) parts.
            n, d = s.split('/')  
            
            # Converting both parts to integers.
            n, d = int(n), int(d)  
            
            # Creating or retrieving a ratio constant from the graph.
            p0, _ = g.get_or_create_const_rat(n, d)  
        
        # Return the constant node
        return p0 


def create_consts(g: Graph, p: gm.Node) -> Union[Ratio, Angle]:
    """"""Create constants based on a geometric node and add them to the graph.

    This function extracts the ratio or angle information from a geometric node
    and adds the corresponding constant node to the graph.

    Args:
        g (Graph): The graph to which the constant is added.
        p (gm.Node): The geometric node containing constant information.

    Returns:
        Union[Ratio, Angle]: The created constant node.

    Raises:
        ValueError: If the node type is unsupported.

    Example:
        >>> g = Graph()
        >>> angle_node = Angle('90/pi')
        >>> create_consts(g, angle_node)
        # This will create an Angle constant in the graph
    """"""
    # If the node is an Angle, extract the angle ratio from its name.
    if isinstance(p, Angle):
        
        # The format is expected to be ""npi/d"" where n and d are integers.
        n, d = p.name.split('pi/')
        
        # Converting both parts to integers.
        n, d = int(n), int(d)
        
        # Creating or retrieving an angle constant from the graph.
        p0, _ = g.get_or_create_const_ang(n, d)
    
    # If the node is a Ratio, extract the ratio values from its name.
    elif isinstance(p, Ratio):
        
        # The format is expected to be ""n/d"".
        n, d = p.name.split('/')  
        
        # Converting both parts to integers.
        n, d = int(n), int(d)  
        
        # Creating or retrieving a ratio constant from the graph.
        p0, _ = g.get_or_create_const_rat(n, d)  
    
    # If the node is neither an Angle nor a Ratio, raise an error.
    else:
        raise ValueError(f""Unsupported node type: {type(p)}"")
        
    # Returning the constant node.
    return p0  
class InfQuotientError(Exception):
    pass


def _gcd(x: int, y: int) -> int:
    while y:
        x, y = y, x % y
    return x


def simplify(n: int, d: int) -> tuple[int, int]:
    g = _gcd(n, d)
    return (n // g, d // g)


# maximum denominator for a fraction.
MAX_DENOMINATOR = 1000000

# tolerance for fraction approximation
TOL = 1e-15


def get_quotient(v: float) -> tuple[int, int]:
    n = v
    d = 1
    while abs(n - round(n)) > TOL:
        d += 1
        n += v
        if d > MAX_DENOMINATOR:
            e = InfQuotientError(v)
            raise e

    n = int(round(n))
    return simplify(n, d)


def fix_v(v: float) -> float:
    n, d = get_quotient(v)
    return n / d


def fix(e: dict[str, float]) -> dict[str, float]:
    return {k: fix_v(v) for k, v in e.items()}


def frac_string(f: frac) -> str:
    n, d = get_quotient(f)
    return f'{n}/{d}'


def hashed(e: dict[str, float]) -> tuple[tuple[str, float], ...]:
    return tuple(sorted(list(e.items())))


def is_zero(e: dict[str, float]) -> bool:
    return len(strip(e)) == 0  # pylint: disable=g-explicit-length-test


def strip(e: dict[str, float]) -> dict[str, float]:
    return {v: c for v, c in e.items() if c != 0}


def plus(e1: dict[str, float], e2: dict[str, float]) -> dict[str, float]:
    e = dict(e1)
    for v, c in e2.items():
        if v in e:
            e[v] += c
        else:
            e[v] = c
    return strip(e)


def plus_all(*es: list[dict[str, float]]) -> dict[str, float]:
    result = {}
    for e in es:
        result = plus(result, e)
    return result


def mult(e: dict[str, float], m: float) -> dict[str, float]:
    return {v: m * c for v, c in e.items()}


def minus(e1: dict[str, float], e2: dict[str, float]) -> dict[str, float]:
    return plus(e1, mult(e2, -1))


def div(e1: dict[str, float], e2: dict[str, float]) -> float:
    """"""Divide e1 by e2.""""""
    e1 = strip(e1)
    e2 = strip(e2)
    if set(e1.keys()) != set(e2.keys()):
        return None

    n, d = None, None

    for v, c1 in e1.items():
        c2 = e2[v]  # we want c1/c2 = n/d => c1*d=c2*n
        if n is not None and c1 * d != c2 * n:
            return None
        n, d = c1, c2
    return frac(n) / frac(d)


def recon(e: dict[str, float], const: str) -> tuple[str, dict[str, float]]:
    """"""Reconcile one variable in the expression e=0, given const.""""""
    e = strip(e)
    if len(e) == 0:  # pylint: disable=g-explicit-length-test
        return None

    v0 = None
    for v in e:
        if v != const:
            v0 = v
            break
    if v0 is None:
        return v0

    c0 = e.pop(v0)
    return v0, {v: -c / c0 for v, c in e.items()}


def replace(
        e: dict[str, float], v0: str, e0: dict[str, float]
) -> dict[str, float]:
    if v0 not in e:
        return e
    e = dict(e)
    m = e.pop(v0)
    return plus(e, mult(e0, m))


def comb2(elems: list[Any]) -> Generator[tuple[Any, Any], None, None]:
    if len(elems) < 1:
        return
    for i, e1 in enumerate(elems[:-1]):
        for e2 in elems[i + 1:]:
            yield e1, e2


def perm2(elems: list[Any]) -> Generator[tuple[Any, Any], None, None]:
    for e1, e2 in comb2(elems):
        yield e1, e2
        yield e2, e1


def chain2(elems: list[Any]) -> Generator[tuple[Any, Any], None, None]:
    if len(elems) < 2:
        return
    for i, e1 in enumerate(elems[:-1]):
        yield e1, elems[i + 1]


def update_groups(
        groups1: list[Any], groups2: list[Any]
) -> tuple[list[Any], list[tuple[Any, Any]], list[list[Any]]]:
    """"""Update groups of equivalent elements.
  
    Given groups1 = [set1, set2, set3, ..]
    where all elems within each set_i is defined to be ""equivalent"" to each other.
    (but not across the sets)
  
    Incoming groups2 = [set1, set2, ...] similar to set1 - it is the
    additional equivalent information on elements in groups1.
  
    Return the new updated groups1 and the set of links
    that make it that way.
  
    Example:
      groups1 = [{1, 2}, {3, 4, 5}, {6, 7}]
      groups2 = [{2, 3, 8}, {9, 10, 11}]
  
    => new groups1 and links:
      groups1 = [{1, 2, 3, 4, 5, 8}, {6, 7}, {9, 10, 11}]
      links = (2, 3), (3, 8), (9, 10), (10, 11)
  
    Explain: since groups2 says 2 and 3 are equivalent (with {2, 3, 8}),
    then {1, 2} and {3, 4, 5} in groups1 will be merged,
    because 2 and 3 each belong to those 2 groups.
    Additionally 8 also belong to this same group.
    {3, 4, 5} is left alone, while {9, 10, 11} is a completely new set.
  
    The links to make this all happens is:
    (2, 3): to merge {1, 2} and {3, 4, 5}
    (3, 8): to link 8 into the merged({1, 2, 3, 4, 5})
    (9, 10) and (10, 11): to make the new group {9, 10, 11}
  
    Args:
      groups1: a list of sets.
      groups2: a list of sets.
  
    Returns:
      groups1, links, history: result of the update.
    """"""
    history = []
    links = []
    for g2 in groups2:
        joins = [None] * len(groups1)  # mark which one in groups1 is merged
        merged_g1 = set()  # merge them into this.
        old = None  # any elem in g2 that belong to any set in groups1 (old)
        new = []  # all elem in g2 that is new

        for e in g2:
            found = False
            for i, g1 in enumerate(groups1):
                if e not in g1:
                    continue

                found = True
                if joins[i]:
                    continue

                joins[i] = True
                merged_g1.update(g1)

                if old is not None:
                    links.append((old, e))  # link to make merging happen.
                old = e

            if not found:  # e is new!
                new.append(e)

        # now chain elems in new together.
        if old is not None and new:
            links.append((old, new[0]))
            merged_g1.update(new)

        links += chain2(new)

        new_groups1 = []
        if merged_g1:  # put the merged_g1 in first
            new_groups1.append(merged_g1)

        # put the remaining (unjoined) groups in
        new_groups1 += [g1 for j, g1 in zip(joins, groups1) if not j]

        if old is None and new:
            new_groups1 += [set(new)]

        groups1 = new_groups1
        history.append(groups1)

    return groups1, links, history


class Table:
    """"""The coefficient matrix.""""""

    def __init__(self, const: str = '1'):
        self.const = const
        self.v2e = {}
        self.add_free(const)  # the table {var: expression}

        # to cache what is already derived/inputted
        self.eqs = set()
        self.groups = []  # groups of equal pairs.

        # for why (linprog)
        self.c = []
        self.v2i = {}  # v -> index of row in A.
        self.deps = []  # equal number of columns.
        self.A = np.zeros([0, 0])  # pylint: disable=invalid-name
        self.do_why = True

    def add_free(self, v: str) -> None:
        self.v2e[v] = {v: frac(1)}

    def replace(self, v0: str, e0: dict[str, float]) -> None:
        for v, e in list(self.v2e.items()):
            self.v2e[v] = replace(e, v0, e0)

    def add_expr(self, vc: list[tuple[str, float]]) -> bool:
        """"""Add a new equality, represented by the list of tuples vc=[(v, c), ..].""""""
        result = {}
        free = []

        for v, c in vc:
            c = frac(c)
            if v in self.v2e:
                result = plus(result, mult(self.v2e[v], c))
            else:
                free += [(v, c)]

        if free == []:  # pylint: disable=g-explicit-bool-comparison
            if is_zero(self.modulo(result)):
                return False
            result = recon(result, self.const)
            if result is None:
                return False
            v, e = result
            self.replace(v, e)

        elif len(free) == 1:
            v, m = free[0]
            self.v2e[v] = mult(result, frac(-1, m))

        else:
            dependent_v = None
            for v, m in free:
                if dependent_v is None and v != self.const:
                    dependent_v = (v, m)
                    continue

                self.add_free(v)
                result = plus(result, {v: m})

            v, m = dependent_v
            self.v2e[v] = mult(result, frac(-1, m))

        return True

    def register(self, vc: list[tuple[str, float]], dep: pr.Dependency) -> None:
        """"""Register a new equality vc=[(v, c), ..] with traceback dependency dep.""""""
        result = plus_all(*[{v: c} for v, c in vc])
        if is_zero(result):
            return

        vs, _ = zip(*vc)
        for v in vs:
            if v not in self.v2i:
                self.v2i[v] = len(self.v2i)

        (m, n), l = self.A.shape, len(self.v2i)
        if l > m:
            self.A = np.concatenate([self.A, np.zeros([l - m, n])], 0)

        new_column = np.zeros([len(self.v2i), 2])  # N, 2
        for v, c in vc:
            new_column[self.v2i[v], 0] += float(c)
            new_column[self.v2i[v], 1] -= float(c)

        self.A = np.concatenate([self.A, new_column], 1)
        self.c += [1.0, -1.0]
        self.deps += [dep]

    def register2(
            self, a: str, b: str, m: float, n: float, dep: pr.Dependency
    ) -> None:
        self.register([(a, m), (b, -n)], dep)

    def register3(self, a: str, b: str, f: float, dep: pr.Dependency) -> None:
        self.register([(a, 1), (b, -1), (self.const, -f)], dep)

    def register4(
            self, a: str, b: str, c: str, d: str, dep: pr.Dependency
    ) -> None:
        self.register([(a, 1), (b, -1), (c, -1), (d, 1)], dep)

    def why(self, e: dict[str, float]) -> list[Any]:
        """"""AR traceback == MILP.""""""
        if not self.do_why:
            return []
        # why expr == 0?
        # Solve min(c^Tx) s.t. A_eq * x = b_eq, x >= 0
        e = strip(e)
        if not e:
            return []

        b_eq = [0] * len(self.v2i)
        for v, c in e.items():
            b_eq[self.v2i[v]] += float(c)

        try:
            x = optimize.linprog(c=self.c, A_eq=self.A, b_eq=b_eq, method='highs')[
                'x'
            ]
        except:  # pylint: disable=bare-except
            x = optimize.linprog(
                c=self.c,
                A_eq=self.A,
                b_eq=b_eq,
            )['x']

        deps = []
        for i, dep in enumerate(self.deps):
            if x[2 * i] > 1e-12 or x[2 * i + 1] > 1e-12:
                if dep not in deps:
                    deps.append(dep)
        return deps

    def record_eq(self, v1: str, v2: str, v3: str, v4: str) -> None:
        self.eqs.add((v1, v2, v3, v4))
        self.eqs.add((v2, v1, v4, v3))
        self.eqs.add((v3, v4, v1, v2))
        self.eqs.add((v4, v3, v2, v1))

    def check_record_eq(self, v1: str, v2: str, v3: str, v4: str) -> bool:
        if (v1, v2, v3, v4) in self.eqs:
            return True
        if (v2, v1, v4, v3) in self.eqs:
            return True
        if (v3, v4, v1, v2) in self.eqs:
            return True
        if (v4, v3, v2, v1) in self.eqs:
            return True
        return False

    def add_eq2(
            self, a: str, b: str, m: float, n: float, dep: pr.Dependency
    ) -> None:
        # a/b = m/n
        if not self.add_expr([(a, m), (b, -n)]):
            return []
        self.register2(a, b, m, n, dep)

    def add_eq3(self, a: str, b: str, f: float, dep: pr.Dependency) -> None:
        # a - b = f * constant
        self.eqs.add((a, b, frac(f)))
        self.eqs.add((b, a, frac(1 - f)))

        if not self.add_expr([(a, 1), (b, -1), (self.const, -f)]):
            return []

        self.register3(a, b, f, dep)

    def add_eq4(self, a: str, b: str, c: str, d: str, dep: pr.Dependency) -> None:
        # a - b = c - d
        self.record_eq(a, b, c, d)
        self.record_eq(a, c, b, d)

        expr = list(minus({a: 1, b: -1}, {c: 1, d: -1}).items())

        if not self.add_expr(expr):
            return []

        self.register4(a, b, c, d, dep)
        self.groups, _, _ = update_groups(
            self.groups, [{(a, b), (c, d)}, {(b, a), (d, c)}]
        )

    def pairs(self) -> Generator[list[tuple[str, str]], None, None]:
        for v1, v2 in perm2(list(self.v2e.keys())):  # pylint: disable=g-builtin-op
            if v1 == self.const or v2 == self.const:
                continue
            yield v1, v2

    def modulo(self, e: dict[str, float]) -> dict[str, float]:
        return strip(e)

    def get_all_eqs(
            self,
    ) -> dict[tuple[tuple[str, float], ...], list[tuple[str, str]]]:
        h2pairs = defaultdict(list)
        for v1, v2 in self.pairs():
            e1, e2 = self.v2e[v1], self.v2e[v2]
            e12 = minus(e1, e2)
            h12 = hashed(self.modulo(e12))
            h2pairs[h12].append((v1, v2))
        return h2pairs

    def get_all_eqs_and_why(
            self, return_quads: bool = True
    ) -> Generator[Any, None, None]:
        """"""Check all 4/3/2-permutations for new equalities.""""""
        groups = []

        for h, vv in self.get_all_eqs().items():
            if h == ():  # pylint: disable=g-explicit-bool-comparison
                for v1, v2 in vv:
                    if (v1, v2) in self.eqs or (v2, v1) in self.eqs:
                        continue
                    self.eqs.add((v1, v2))
                    # why v1 - v2 = e12 ?  (note modulo(e12) == 0)
                    why_dict = minus({v1: 1, v2: -1}, minus(self.v2e[v1], self.v2e[v2]))
                    yield v1, v2, self.why(why_dict)
                continue

            if len(h) == 1 and h[0][0] == self.const:
                for v1, v2 in vv:
                    frac = h[0][1]  # pylint: disable=redefined-outer-name
                    if (v1, v2, frac) in self.eqs:
                        continue
                    self.eqs.add((v1, v2, frac))
                    # why v1 - v2 = e12 ?  (note modulo(e12) == 0)
                    why_dict = minus({v1: 1, v2: -1}, minus(self.v2e[v1], self.v2e[v2]))
                    value = simplify(frac.numerator, frac.denominator)
                    yield v1, v2, value, self.why(why_dict)
                continue

            groups.append(vv)

        if not return_quads:
            return

        self.groups, links, _ = update_groups(self.groups, groups)
        for (v1, v2), (v3, v4) in links:
            if self.check_record_eq(v1, v2, v3, v4):
                continue
            e12 = minus(self.v2e[v1], self.v2e[v2])
            e34 = minus(self.v2e[v3], self.v2e[v4])

            why_dict = minus(  # why (v1-v2)-(v3-v4)=e12-e34?
                minus({v1: 1, v2: -1}, {v3: 1, v4: -1}), minus(e12, e34)
            )
            self.record_eq(v1, v2, v3, v4)
            yield v1, v2, v3, v4, self.why(why_dict)


class GeometricTable(Table):
    """"""Abstract class representing the coefficient matrix (table) A.""""""

    def __init__(self, name: str = ''):
        super().__init__(name)
        self.v2obj = {}

    def get_name(self, objs: list[Any]) -> list[str]:
        self.v2obj.update({o.name: o for o in objs})
        return [o.name for o in objs]

    def map2obj(self, names: list[str]) -> list[Any]:
        return [self.v2obj[n] for n in names]

    def get_all_eqs_and_why(
            self, return_quads: bool
    ) -> Generator[Any, None, None]:
        for out in super().get_all_eqs_and_why(return_quads):
            if len(out) == 3:
                x, y, why = out
                x, y = self.map2obj([x, y])
                yield x, y, why
            if len(out) == 4:
                x, y, f, why = out
                x, y = self.map2obj([x, y])
                yield x, y, f, why
            if len(out) == 5:
                a, b, x, y, why = out
                a, b, x, y = self.map2obj([a, b, x, y])
                yield a, b, x, y, why


class RatioTable(GeometricTable):
    """"""Coefficient matrix A for log(distance).""""""

    def __init__(self, name: str = ''):
        name = name or '1'
        super().__init__(name)
        self.one = self.const

    def add_eq(self, l1: gm.Length, l2: gm.Length, dep: pr.Dependency) -> None:
        l1, l2 = self.get_name([l1, l2])
        return super().add_eq3(l1, l2, 0.0, dep)

    def add_const_ratio(
            self, l1: gm.Length, l2: gm.Length, m: float, n: float, dep: pr.Dependency
    ) -> None:
        l1, l2 = self.get_name([l1, l2])
        return super().add_eq2(l1, l2, m, n, dep)

    def add_eqratio(
            self,
            l1: gm.Length,
            l2: gm.Length,
            l3: gm.Length,
            l4: gm.Length,
            dep: pr.Dependency,
    ) -> None:
        l1, l2, l3, l4 = self.get_name([l1, l2, l3, l4])
        return self.add_eq4(l1, l2, l3, l4, dep)

    def get_all_eqs_and_why(self) -> Generator[Any, None, None]:
        return super().get_all_eqs_and_why(True)


class AngleTable(GeometricTable):
    """"""Coefficient matrix A for slope(direction).""""""

    def __init__(self, name: str = ''):
        name = name or 'pi'
        super().__init__(name)
        self.pi = self.const

    def modulo(self, e: dict[str, float]) -> dict[str, float]:
        e = strip(e)
        if self.pi not in e:
            return super().modulo(e)

        e[self.pi] = e[self.pi] % 1
        return strip(e)

    def add_para(
            self, d1: gm.Direction, d2: gm.Direction, dep: pr.Dependency
    ) -> None:
        return self.add_const_angle(d1, d2, 0, dep)

    def add_const_angle(
            self, d1: gm.Direction, d2: gm.Direction, ang: float, dep: pr.Dependency
    ) -> None:
        if ang and d2._obj.num > d1._obj.num:  # pylint: disable=protected-access
            d1, d2 = d2, d1
            ang = 180 - ang

        d1, d2 = self.get_name([d1, d2])

        num, den = simplify(ang, 180)
        ang = frac(int(num), int(den))
        return super().add_eq3(d1, d2, ang, dep)

    def add_eqangle(
            self,
            d1: gm.Direction,
            d2: gm.Direction,
            d3: gm.Direction,
            d4: gm.Direction,
            dep: pr.Dependency,
    ) -> None:
        """"""Add the inequality d1-d2=d3-d4.""""""
        # Use string as variables.
        l1, l2, l3, l4 = [d._obj.num for d in [d1, d2, d3, d4]]  # pylint: disable=protected-access
        d1, d2, d3, d4 = self.get_name([d1, d2, d3, d4])
        ang1 = {d1: 1, d2: -1}
        ang2 = {d3: 1, d4: -1}

        if l2 > l1:
            ang1 = plus({self.pi: 1}, ang1)
        if l4 > l3:
            ang2 = plus({self.pi: 1}, ang2)

        ang12 = minus(ang1, ang2)
        self.record_eq(d1, d2, d3, d4)
        self.record_eq(d1, d3, d2, d4)

        expr = list(ang12.items())
        if not self.add_expr(expr):
            return []

        self.register(expr, dep)

    def get_all_eqs_and_why(self) -> Generator[Any, None, None]:
        return super().get_all_eqs_and_why(True)


class DistanceTable(GeometricTable):
    """"""Coefficient matrix A for position(point, line).""""""

    def __init__(self, name: str = ''):
        name = name or '1:1'
        self.merged = {}
        self.ratios = set()
        super().__init__(name)

    def pairs(self) -> Generator[tuple[str, str], None, None]:
        l2vs = defaultdict(list)
        for v in list(self.v2e.keys()):  # pylint: disable=g-builtin-op
            if v == self.const:
                continue
            l, p = v.split(':')
            l2vs[l].append(p)

        for l, ps in l2vs.items():
            for p1, p2 in perm2(ps):
                yield l + ':' + p1, l + ':' + p2

    def name(self, l: gm.Line, p: gm.Point) -> str:
        v = l.name + ':' + p.name
        self.v2obj[v] = (l, p)
        return v

    def map2obj(self, names: list[str]) -> list[gm.Point]:
        return [self.v2obj[n][1] for n in names]

    def add_cong(
            self,
            l12: gm.Line,
            l34: gm.Line,
            p1: gm.Point,
            p2: gm.Point,
            p3: gm.Point,
            p4: gm.Point,
            dep: pr.Dependency,
    ) -> None:
        """"""Add that distance between p1 and p2 (on l12) == p3 and p4 (on l34).""""""
        if p2.num > p1.num:
            p1, p2 = p2, p1
        if p4.num > p3.num:
            p3, p4 = p4, p3

        p1 = self.name(l12, p1)
        p2 = self.name(l12, p2)
        p3 = self.name(l34, p3)
        p4 = self.name(l34, p4)
        return super().add_eq4(p1, p2, p3, p4, dep)

    def get_all_eqs_and_why(self) -> Generator[Any, None, None]:
        for x in super().get_all_eqs_and_why(True):
            yield x

        # Now we figure out all the const ratios.
        h2pairs = defaultdict(list)
        for v1, v2 in self.pairs():
            if (v1, v2) in self.merged:
                continue
            e1, e2 = self.v2e[v1], self.v2e[v2]
            e12 = minus(e1, e2)
            h12 = hashed(e12)
            h2pairs[h12].append((v1, v2, e12))

        for (_, vves1), (_, vves2) in perm2(list(h2pairs.items())):
            v1, v2, e12 = vves1[0]
            for v1_, v2_, _ in vves1[1:]:
                self.merged[(v1_, v2_)] = (v1, v2)

            v3, v4, e34 = vves2[0]
            for v3_, v4_, _ in vves2[1:]:
                self.merged[(v3_, v4_)] = (v3, v4)

            if (v1, v2, v3, v4) in self.ratios:
                continue

            d12 = div(e12, e34)
            if d12 is None or d12 > 1 or d12 < 0:
                continue

            self.ratios.add((v1, v2, v3, v4))
            self.ratios.add((v2, v1, v4, v3))

            n, d = d12.numerator, d12.denominator

            # (v1 - v2) * d = (v3 - v4) * n
            why_dict = minus(
                minus({v1: d, v2: -d}, {v3: n, v4: -n}),
                minus(mult(e12, d), mult(e34, n)),  # there is no modulo, so this is 0
            )

            v1, v2, v3, v4 = self.map2obj([v1, v2, v3, v4])
            yield v1, v2, v3, v4, abs(n), abs(d), self.why(why_dict)



","<br>

<center><img src=""https://lh3.googleusercontent.com/tVTh_ZCW5Qozy4vOCpMH06B7Ac_eF7fmEULMMTwDellOh6hnOMUtf28toD68N527IHQTlBWfBCHcZykYPMdrS48yvuEcJKMJG8rU3YRM3u5Ojn3JXnc=w2144-h1206-n-nu-rw"" width=100% style=""padding: 0 0 !important; margin: 0 0 !important;""></center>

<br style=""margin: 15px;"">

<h2 style=""text-align: center; font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">
    <span style=""text-decoration: underline;"">
        <font color=#799cb7>L</font>ET'S 
        <font color=#799cb7>L</font>EARN 
        <font color=#799cb7>T</font>OGETHER !
    </span><br><br><br style=""margin: 15px;"">
<span style=""font-size: 18px; letter-spacing: 1px;"">
    <font color=#799cb7>U</font>NDERSTANDING    
    <font color=#799cb7>W</font>ITH
    <font color=#799cb7>O</font>UR
    <font color=#799cb7>O</font>WN
    <font color=#799cb7>I</font>MPLEMENTATION (!WIP!)
</span><br style=""margin: 15px;""></h2>

<p style=""text-align: center; font-family: Verdana; font-size: 12px; font-style: normal; font-weight: bold; text-decoration: None; text-transform: none; letter-spacing: 1px; color: black; background-color: #ffffff;"">CREATED BY: DARIEN SCHETTLER</p>

<br>

<center><div class=""alert alert-block alert-danger"" style=""margin: 2em; line-height: 1.7em; font-family: Verdana;"">
    <b style=""font-size: 18px;"">🛑 &nbsp; WARNING:</b><br><br><b>THIS IS A WORK IN PROGRESS</b><br>
</div></center>


<center><div class=""alert alert-block alert-warning"" style=""margin: 2em; line-height: 1.7em; font-family: Verdana;"">
    <b style=""font-size: 18px;"">👏 &nbsp; IF YOU FORK THIS OR FIND THIS HELPFUL &nbsp; 👏</b><br><br><b style=""font-size: 22px; color: darkorange"">PLEASE UPVOTE!</b><br><br>This was a lot of work for me and it makes me feel appreciated when others like my work. 😅
</div></center>



<p id=""toc""></p>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; color: #192a51; background-color: #ffffff;"">
    TABLE OF CONTENTS
</h1>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#introduction"" style=""text-decoration: none; color: #799cb7;"">1&nbsp;&nbsp;&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#background_information"" style=""text-decoration: none; color: #799cb7;"">2&nbsp;&nbsp;&nbsp;&nbsp;BACKGROUND INFORMATION</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#imports"" style=""text-decoration: none; color: #799cb7;"">3&nbsp;&nbsp;&nbsp;&nbsp;IMPORTS</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#geometry"" style=""text-decoration: none; color: #799cb7;"">4&nbsp;&nbsp;&nbsp;&nbsp;GEOMETRY</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#problem"" style=""text-decoration: none; color: #799cb7;"">5&nbsp;&nbsp;&nbsp;&nbsp;PROBLEM</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#ar"" style=""text-decoration: none; color: #799cb7;"">6&nbsp;&nbsp;&nbsp;&nbsp;ALGEBRAIC REASONING</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#ar"" style=""text-decoration: none; color: #799cb7;"">7&nbsp;&nbsp;&nbsp;&nbsp;GRAPH</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#ar"" style=""text-decoration: none; color: #799cb7;"">8&nbsp;&nbsp;&nbsp;&nbsp;DDAR</a></h3>

<hr>

<h3 style=""text-indent: 10vw; font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; background-color: #ffffff;""><a href=""#next_steps"" style=""text-decoration: none; color: #799cb7;"">9&nbsp;&nbsp;&nbsp;&nbsp;NEXT STEPS</a></h3>

<hr>

<br>
<br>

<a id=""introduction""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""introduction"">1&nbsp;&nbsp;INTRODUCTION & JUSTIFICATION&nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>

<img src=""https://lh3.googleusercontent.com/y7r-p8VmkqSLE0ZcwidAO0osQ1Sz1y4FBhwQNkv7t1M5bajHTvCu1vTYxDmVJZ2WuknpHeQB2E6RkPUEu-fAVoAxgh8thMPR6bcK4NFyGFuQ4mo5=w1232-rw"" width=90%>

<br>

**Evan Chen** (a math coach and former Olympiad gold-medalist):
> ""AlphaGeometry's output is impressive because it's both verifiable and clean. 
>
> Past AI solutions to proof-based competition problems have sometimes been hit-or-miss (outputs are only correct sometimes and need human checks). AlphaGeometry doesn't have this weakness: its solutions have machine-verifiable structure. Yet despite this, its output is still human-readable. 
> 
> One could have imagined a computer program that solved geometry problems by brute-force coordinate systems: think pages and pages of tedious algebra calculation. AlphaGeometry is **not that**. It uses classical geometry rules with angles and similar triangles just as students do""

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.1 <b>WHAT</b> IS THIS?</h3>
<hr>

<ul>
    <li style=""font-family: Verdana;"">This notebook will follow the authors learning path and highlight relevant terms, information, and useful content about the competition.</li>
    <li>This notebook will conduct an <b>E</b>xploratory <b>D</b>ata <b>A</b>nalysis for the competition.</li>
    <li>This notebook will propose an open-source baseline solution.</li>
</ul>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.2 <b>WHY</b> IS THIS?</h3>
<hr>

<ul>
    <li>Writing and sharing my learning path and the resulting exploratory data analysis can help improve my own understanding of the competition and the data.</li>
    <li>Sharing my work may help others who are interested in the competition (or the data). This help may take the form of:
        <ul>
            <li>Better understanding the problem and potential common solutions (incl. my baseline).</li>
            <li>Better understanding of the provided dataset.</li>
            <li>Better understanding of the background information and research.</li>
            <li>Better ability to hypothesize new solutions.</li>
        </ul>
    </li>
    <li>Exploratory data analysis is a critical step in any data science project. Sharing my EDA might help others in the competition.</li>
    <li>Writing and sharing my work is often a fun and rewarding experience! It not only allows me to explore and try different techniques, ideas, and visualizations but also encourages and supports other learners and participants.</li>
</ul>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.3 <b>WHO</b> IS THIS FOR?</h3>
<hr>


<ul>
    <li>The primary purpose of this notebook is to educate <b>MYSELF</b>, however, my review/learning might be beneficial to others:
        <ul>
            <li>Other Kagglers (aka. current and future competition participants).</li>
            <li>Anyone interested in learning more about sign language recognition and its potential applications.</li>
            <li>Educators, students, or researchers who want to gain hands-on experience working with real-world data and building machine learning models and want to follow along with something relatively straightforward.</li>
            <li>Those who want to learn how to use specific tools (competition specific and data science) and libraries such as TensorFlow Lite, MediaPipe, pandas, numpy, etc.</li>
        </ul>
    </li>
</ul>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">1.4 <b>HOW</b> WILL THIS WORK?</h3>
<hr>


<p>I'm going to assemble some markdown cells (like this one) at the beginning of the notebook to go over some concepts/details/etc.</p>

<p>Following this, I will attempt to walk through the data and understand it better prior to composing a baseline solution.</p>

<br>
<br>

<a id=""background_information""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""background_information"">2&nbsp;&nbsp;BACKGROUND INFORMATION &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.1 <b>UNDERSTANDING</b> DEEPMIND'S <b>ALPHA</b>GEOMETRY</h3>
<hr>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Overview of <span style=""color: #77AAB0 !important;"">Alpha</span><span style=""color: #192a51 !important;"">Geometry</span></b>

**(1) Purpose and Achievement**: 
* AlphaGeometry is an AI system designed to solve complex geometry problems. 
* AlphaGeometry represents a significant advancement in AI's ability to perform mathematical reasoning.
* In tests, it solved 25 out of 30 Olympiad geometry problems within the time limits of the competition, <b><mark>nearly matching the performance of human gold medalists.</mark></b>

**(2) Comparison with Previous Systems**: 
* The previous state-of-the-art system, based on <b><a href=""https://en.wikipedia.org/wiki/Wu%27s_method_of_characteristic_set#:~:text=Wu's%20method%20uses%20polynomial%20division,another%20to%20give%20a%20remainder."">""Wu’s method""</a></b>, solved only 10 out of these 30 problems. 
* This shows a significant leap in capabilities with AlphaGeometry.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">How <span style=""color: #77AAB0 !important;"">Alpha</span><span style=""color: #192a51 !important;"">Geometry</span> Works</b>

**(1) The Neuro-Symbolic System**: 
* <u>Basic Definition</u>
    * It combines a neural language model with a symbolic deduction engine. 
    * The neural model provides quick, intuitive ideas, while the symbolic engine applies formal logic and rules to arrive at conclusions.
* <u>ELI5 - Neuro-Symbolic System</u>
    * Imagine you're trying to solve a complex puzzle, like a treasure hunt. You have two friends helping you: one is an imaginative storyteller (the neural language model), and the other is a meticulous detective (the symbolic deduction engine).
        * <b><span style=""color: #77AAB0 !important;"">Imaginative Storyteller (Neural Language Model)</span></b>:
            * This friend is great at coming up with creative ideas quickly. 
            * They suggest where the treasure might be hidden based on the stories and legends they know. 
            * They don't always stick to strict rules but provide you with lots of possible clues based on patterns they've seen in other treasure hunts.
        * <b><span style=""color: #192a51 !important;"">Meticulous Detective (Symbolic Deduction Engine)</span></b>:
            * Your other friend is very logical and methodical. 
            * They take each of the storyteller's ideas and meticulously analyze them, using a map and a set of rules about how treasure hunts usually work. 
            * They carefully check each idea to see if it follows the rules and makes sense in the context of this specific puzzle.
    * To successfully complete the treasure hunt we need <b>BOTH FRIENDS!</b>: 
        * the storyteller's creative ideas to know where to look 
        * and the detective's logical approach to figure out which of those ideas actually lead to the treasure. 
        * Together, they make a great team for solving complex puzzles.
    * This is similar to how a Neuro-Symbolic System works in AI: 
        * the neural part quickly generates a range of ideas or hypotheses, and the symbolic part rigorously evaluates these ideas to find the correct solution.<br>

**(2) The Problem-Solving Process**: 
* <u>Basic Definition</u>
    * For geometry problems, the system first uses symbolic deduction. 
    * If it gets stuck, the neural model suggests new geometric constructs (like points or lines), which then opens new paths for the symbolic engine to explore.
* <u>ELI5 - Neuro-Symbolic System</u>
    * Let's continue our treasure hunt analogy with our two friends — the <b><span style=""color: #77AAB0 !important;"">Imaginative Storyteller (Neural Language Model)</span></b> and the <b><span style=""color: #192a51 !important;"">Meticulous Detective (Symbolic Deduction Engine)</span></b>.
    * To find the treasure, the Detective (Symbolic Deduction Engine) takes the lead initially.
        * They have a map and a set of rules on how typical treasure hunts work. 
        * So, they start analyzing the clues you already have, following the paths on the map logically and methodically, applying these rules. 
        * They're trying to figure out where to go next based on the information at hand.
    * However, sometimes the detective comes to a dead-end (ohno)...
        * At a certain point, the detective hits a dead end. 
        * They've followed the rules and the map as far as they can, but they can't figure out where the treasure is. 
        * They need a new idea or a new place to look, something that's not already on the map or in the rules.
    * The Storyteller (Neural Language Model) Steps In (and Steps Up!):
        * This is where the storyteller comes in. 
        * By thinking outside the box, using their imagination and pattern recognition skills, they are able to suggest new possibilities: 
            * ""What if there’s a hidden path not marked on the map? What if the treasure is buried under that old tree that looks like the one in the legend?"" 
        * These are analagous to new geometric constructs in the context of the puzzle—ideas that aren't part of the original set of clues or map.
    * Annnd We're Back to the Detective:
        * With these new ideas from the storyteller, the detective now has new avenues to explore. 
        * They start applying their logical, rule-based approach to these fresh suggestions. 
        * For instance, they might start considering how a hidden path could connect known locations on the map or how the tree mentioned in the legend relates to known landmarks.
    * In this analogy, the storyteller's imaginative suggestions are like the neural model proposing new geometric constructs when faced with a challenging geometry problem.
        * These new constructs (like adding a new line or point in a geometric diagram) open up new possibilities that weren't apparent before. 
        * Then, the detective's logical approach is akin to the symbolic deduction engine taking these new constructs and rigorously working through them to find a solution to the problem. 
        * Together, they move past the dead-end and closer to finding the treasure, just as the Neuro-Symbolic System solves complex geometry problems.

**(3) Example(s) of Problem Solving**: 
<img src=""https://lh3.googleusercontent.com/CXoZ8QVYA7wKFPt3RurU7Z0SDyp32YQS9gJaEwE-U1AtjAQ-eXEaGxnOSTUH01oyN7YOxz-BILe390w2wHVEFF7XPmCOzqr0QMBroKc4J5kPFyqYVqU=w1232-rw"">
<br>
<img src=""https://lh3.googleusercontent.com/XEyvy2yOfpwazku1bh2mgN48QquA21bUXscAAYOSp34kN-qb1E6glno62gNSqSth921OVJ5nBBT8GNFiVg1nwv3U2jd3vo6YCFENsn3qBD9yQZsD=w1232-rw"">
<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Synthetic Data Generation</b>


**(1) The Training Data(set)**: 
* AlphaGeometry was trained on a massive dataset of <b><u>synthetic</u></b> geometry problems <b>(100 million unique examples).</b>
* This approach bypasses the limitations of relying on human-generated training data

**(2) Synethetic Data Generation Method**: 
* The system generated <b>a billion(!) random diagrams</b>... using these it 
    * Derived relationships
    * Found proofs
    * And identified which constructs were necessary for the respective proofs. 
* This process allowed the original examples to be distilled down to <b>100 million unique examples.</b>

**(3) Some Examples of the Generated Data**
<img src=""https://lh3.googleusercontent.com/I2xcIu8Js4iZP89NPUe2Cr_43To5aamQNzzXDsDD_PamVRJQFZQ7SUdu6zJVlXAJ2Gq6fnINeHzsQeY5ugdSFzdnAaSrIuYcLsgSfJLDjJalifcD=w1232-rw"">

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Evaluation and Applications</b>

**(1) Verification and Evaluation**: 
* The solutions provided by AlphaGeometry were verified by computer, compared with previous methods and human performance, and evaluated by a math expert(s) for correctness and readability.

**(2) Scope of Use**: 
* Currently, AlphaGeometry is specialized in geometry, <b>capable of solving about <mark>one-third of the problems</mark> in a typical International Mathematical Olympiad.</b>

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Broader Implications and Goals</b>

**(1) Mathematical Reasoning with AI**: 
* This development is part of a larger effort to enhance AI's capacity for mathematical reasoning and problem-solving.

**(2) Long-Term Goals**: 
* The ultimate aim is to create AI systems that can generalize across various mathematical fields and contribute to the advancement of human knowledge.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">My Takeaways</b>

**Technical Innovation**: 
* DeepMind continues to contribute exciting and groundbreaking advancements to the AI space in ways that no one else is doing.
    * By targeting real problems (Fusion, Protein Folding, Drug Discovery, Math/Algorithms, etc.) and creating solutions that objectively advance the respective fields, DeepMind stands alone.
* The combination of neural models for intuition and symbolic engines for rigorous logic has been tapped as a solution before by DeepMind, and it would appear that they have found this to be a solid combo when it comes to solving problems that require a mix of imagination, problem solving, and technical rigour.

**Training Methodology**: 
* I thought the use of synthetic data generation is particularly interesting, as it represents a scalable way to train AI without human intervention.
    * We have all heard about this being possible, or working in niche cases... but to see it leveraged with such success is a huge step forward.

**Real-World Impact**: 
* While currently focused on geometry, the techniques and learnings from AlphaGeometry could influence other AI applications in science, engineering, and beyond.
    * As mentioned previously, this 1-2 combo of neural models (LLMs) and symbolic engines (Solvers) seems to hold a lot of promise for future work.

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.2 <b>KEY</b> TERMS RELATED TO <b>ALPHA</b>GEOMETRY</h3>
<hr>

This is just the start... I will add to this as we go.
**(1) AI (Artificial Intelligence)**
- **Definition**: The simulation of human intelligence in machines that are programmed to think like humans and mimic their actions.
- **ELI5**: Like teaching a robot to think and act like a person.
- **Relevance**: AlphaGeometry is an AI system, meaning it's a computer program designed to solve geometry problems like a human, particularly those found in Olympiads.

**(2) Neuro-Symbolic System**
- **Definition**: An approach in AI that combines neural networks (which excel in learning patterns from data) with symbolic AI (which uses structured logic to reason and solve problems).
- **ELI5**: It's like combining fast, instinctive thinking (neural) with careful, rule-based thinking (symbolic) to solve problems.
- **Relevance**: AlphaGeometry uses this approach to both intuitively guess and logically deduce solutions to geometry problems.

**(3) Neural Language Model**
- **Definition**: A type of AI that processes and understands human language. These models are trained on large datasets of text.
- **ELI5**: Imagine a robot that has read a lot of books and can use that knowledge to understand and generate language.
- **Relevance**: In AlphaGeometry, the neural language model helps by quickly generating ideas or guesses about solving geometry problems.

**(4) Symbolic Deduction Engine**
- **Definition**: A system in AI that uses explicit rules and logic to derive conclusions from given premises or data.
- **ELI5**: It's like a very strict math teacher who follows the rules of math precisely to solve problems.
- **Relevance**: This part of AlphaGeometry methodically works through geometry problems step-by-step, following strict geometrical rules.

**(5) Synthetic Data Generation**
- **Definition**: The creation of artificial data by a computer program, used for training AI models.
- **ELI5**: It's like creating a bunch of practice math problems for a student to learn from, instead of using problems from real textbooks.
- **Relevance**: AlphaGeometry was trained on many made-up geometry problems, helping it learn how to solve a wide variety of real problems.

**(6) Parallelized Computing**
- **Definition**: A type of computing where many calculations or processes are carried out simultaneously.
- **ELI5**: Imagine many people working on different parts of a big puzzle at the same time, instead of one person doing it alone.
- **Relevance**: This was used to quickly generate the huge amount of synthetic data needed to train AlphaGeometry.

**(7) Olympiad Geometry Problems**
- **Definition**: Advanced geometry problems like those found in international mathematics competitions for high school students.
- **ELI5**: These are very tricky puzzle-like math problems that are part of a big, worldwide math competition for students.
- **Relevance**: AlphaGeometry is designed to solve these complex problems, which are a test of its mathematical reasoning abilities.

**(8) International Mathematical Olympiad (IMO)**
- **Definition**: An annual mathematics competition for high school students from around the world, known for its challenging problems.
- **ELI5**: Like the Olympics, but for super hard high school math problems.
- **Relevance**: AlphaGeometry's performance is benchmarked against the level of these Olympiad problems.

**(9) Euclid's Five Postulates**

| **Postulate** | **Original Postulate Text** | **Detailed Explanation** | **ELI5 Explanation** | **Analogy** |
|:-----------:|-------------------------|----------------------|------------------|---------|
| **1** | It is possible to draw a straight line segment joining any two points. | This postulate states that if you have any two distinct points, you can always draw a straight line connecting them. It's a fundamental concept in geometry that establishes the existence of straight lines. | You can always draw a straight line between any two points. | Like connecting dots on paper with a ruler. |
| **2** | It is possible to indefinitely extend any straight line segment continuously in a straight line. | This means that a straight line can be extended infinitely in both directions. It does not have inherent endpoints and can be elongated as much as desired. | A straight line can go on forever in both directions. | Like a road that goes on forever and never curves. |
| **3** | Given any straight line segment, it is possible to draw a circle having the segment as a radius and one endpoint as its center. | This postulate allows for the construction of a circle using any straight line segment as its radius. The endpoint of this segment serves as the center of the circle. | You can draw a circle using any straight line segment, with one end of the line being the center of the circle. | Like using a piece of string with one end fixed, to draw a circle. |
| **4** | All right angles are equal to each other or congruent. | This postulate asserts that all right angles (angles of 90 degrees) are identical in measure. It establishes the consistency of right angles across different geometric contexts. | All right angles are the same, no matter where they are. | All corners of a square or a rectangle are the same angle. |
| **5** | Through a given point not on a given straight line, only one line can be drawn parallel to a given line. | This controversial postulate states that if you have a line and a point not on the line, there is exactly one line through the point that doesn't intersect the original line (i.e., is parallel to it). This postulate is the basis for non-Euclidean geometries when it's altered or omitted. | From a point not on a line, only one straight line can be drawn that will never meet the original line. | Like a walking path made parallel to railroad tracks that never cross each other. |

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">2.3 <b>SECTION</b>-BY-SECTION <b>ALPHA</b>GEOMETRY <a href=""https://www.nature.com/articles/s41586-023-06747-5"">PAPER</a> REVIEW</h3>
<hr>


<b style=""text-decoration: underline; font-family: Verdana; font-size: 18px; text-transform: uppercase; letter-spacing: 2px;"">Abstract Section</b>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Summary:</b>
* The paper introduces AlphaGeometry, an AI designed to solve complex geometry problems at the Olympiad level, a significant achievement in AI and automated reasoning. 
* Traditional machine learning struggles in mathematical domains due to the difficulty in converting human proofs into a format machines can understand. 
* This issue is particularly pronounced in geometry. 
* AlphaGeometry overcomes these challenges by generating its own database of theorems and proofs, employing a combination of neural networks and symbolic reasoning. 
* It has shown remarkable results, solving 25 out of 30 Olympiad-level problems, nearly matching the average score of top human competitors in these contests.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Important Information:</b>

1. ""Proving mathematical theorems at the olympiad level represents a notable milestone in human-level automated reasoning."" 
    * This highlights the significance of the achievement, as Olympiad-level problems are extremely challenging.
2. ""The problem is even worse for geometry because of its unique translation challenges.""
    * This indicates the specific difficulty in adapting machine learning for geometry.
3. ""AlphaGeometry is a neuro-symbolic system that uses a neural language model...to guide a symbolic deduction engine."" 
    * This shows the innovative approach of AlphaGeometry, combining advanced AI techniques.
4. ""On a test set of 30 latest Olympiad-level problems, AlphaGeometry solves 25."" 
    * This quantifies the system's success and its comparison to human performance.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Explanation Like I'm 5 (ELI5):</b>

* Imagine you have a super smart robot that loves playing with shape puzzles. 
* Most robots find these puzzles really hard, especially the trickiest ones made for the smartest kids. 
* But this robot, AlphaGeometry, is special. 
* It can solve almost all of these tough puzzles quickly and even explain how it did it, just like the smartest kids who win gold medals in shape puzzle contests!

<br>
    
<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Key Terms and Definitions:</b>
    
1. **Theorem Proving**: 
    * Like solving a riddle or puzzle in mathematics. 
    * It's about proving whether certain statements about numbers, shapes, or patterns are true.
2. **Euclidean Plane Geometry**: 
    * This is the study of shapes, sizes, and the properties of space. 
    * If you've ever played with shapes on a flat table, that's like studying plane geometry.
3. **Neuro-Symbolic System**: 
    * A combination of two AI techniques. 
        * **""Neuro""** refers to neural networks, which are like a simplified version of how our brains work
        * **""Symbolic""** involves using clear, defined rules and symbols, like in traditional computer programs.
4. **Neural Language Model**: 
    * This is a part of AI that understands and uses human-like language. 
        * It's trained to read, understand, and sometimes write text like a human.
        * Think LLM (ChatGPT, etc.)
5. **Symbolic Deduction Engine**: 
    * This is a computer program that solves problems using a series of logical steps and rules, a bit like following a recipe to bake a cake, but for solving math problems.
6. **International Mathematical Olympiad (IMO)**: 
    * A world championship mathematics competition for high school students, known for its very challenging problems.
   
<b style=""text-decoration: underline; font-family: Verdana; font-size: 18px; text-transform: uppercase; letter-spacing: 2px;"">Main Section</b>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Summary:</b>

* This section of the AlphaGeometry paper explains the challenges and advancements in AI theorem proving, particularly in geometry. 
* Theorem proving is a complex AI task due to the difficulty in translating human proofs into formats understandable by machines. 
* The paper highlights the scarcity of training data for geometry problems and the limitations of current methods. 
* AlphaGeometry addresses these challenges by generating synthetic data (100 million theorems and proofs), focusing on Euclidean plane geometry. 
* It combines a pretrained language model with specialized symbolic engines for proof search, particularly for auxiliary construction - a key challenge in theorem proving. 
* This approach has led to AlphaGeometry performing close to the level of an IMO gold medalist in solving classical geometry problems.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Important Information:</b>

1. ""Theorem proving is difficult for learning-based methods because training data of human proofs translated into machine-verifiable languages are scarce."" 
    * This emphasizes the challenge of data scarcity in AI theorem proving.
2. ""By using existing symbolic engines on a diverse set of random theorem premises, we extracted 100 million synthetic theorems and their proofs."" 
    * This shows how AlphaGeometry overcomes the data scarcity problem.
3. ""We pretrain a language model... and fine-tune it to focus on auxiliary construction during proof search."" 
    * This explains the technique used for solving complex geometry problems.
4. ""AlphaGeometry... substantially outperforms the previous state-of-the-art geometry-theorem-proving computer program."" 
    * This highlights the significant advancement AlphaGeometry represents in the field.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Explanation Like You're 5 (ELI5)</b>

* Imagine you have a really big book of puzzles that are super hard, and you have a magic pen that can draw new puzzles and find answers to them. 
* This magic pen is like AlphaGeometry. 
* It's smart because it learned from a huge number of puzzles it created by itself. 
* When it sees a new puzzle, it uses its magic to think of new ways to solve it, like drawing new shapes or lines that help find the answer. 
* This magic pen is so good at solving puzzles that it's almost as smart as the cleverest kids who win big puzzle competitions!

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Key Terms and Definitions</b>

1. **Theorem Proving**: 
    * In AI, this refers to the process of finding proofs for mathematical statements using algorithms and computational methods.
2. **Synthetic Data**: 
    * Artificially created data used to train machine learning models, as opposed to real-world data.
3. **Euclidean Plane Geometry**: 
    * The study of geometric shapes and properties in a flat, two-dimensional space, like the geometry of shapes drawn on paper.
4. **Auxiliary Construction**: 
    * In geometry, this involves adding extra lines, points, or shapes to a diagram to help prove a theorem.
5. **Language Model**: 
    * An AI model trained to understand and generate human-like text.
6. **Symbolic Engines**: 
    * Software systems that solve problems using symbols and logic, following a set of predefined rules.
7. **International Mathematical Olympiad (IMO)**: 
    * A prestigious annual competition for high school students, featuring challenging mathematics problems.
8. **Exogenous Term Generation**: 
    * In AI theorem proving, this refers to the creation of new elements or terms during the proof process that were not part of the original problem statement.
<br>

<a id=""imports""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""imports"">3&nbsp;&nbsp;IMPORTS &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<br>

<a id=""geometry""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""geometry"">4&nbsp;&nbsp;GEOMETRY &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.1 <code><b>GEOMETRY.PY</b></code> FILE - <b>IMPORTS</b></h3>
<hr>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.2 <code><b>GEOMETRY.PY</b></code> FILE - THE <b>NODE</b> CLASS</h3>
<hr>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Class Definition</b>

* The Node class is a component in a graph structure, it will be used for proving geometric theorems and/or other similar tasks. 
* The docstring explains that nodes can represent various geometric entities and maintain relationships with other nodes.

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">High Level ELI5 Analogy</b>

* Let's use an analogy of a social network to explain the Node class. 
* As such, we imagine each `**Node**` as a **person** in a social network. 
* This network isn't just about who knows whom, but also includes details about friendships merging, people representing groups, and different types of relationships.

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Constructor and Attributes</b>

* The **`__init__`** method initializes a Node instance. 
* It sets up various attributes as shown in the table below:

| **Attribute**         | **Type**        | **Purpose in Node Class**                                     | **Social Network Analogy**                                                                          |
|-------------------|-------------|-----------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| **`self.name`**       | **`str`**       | Represents the name of the node.                          | Like a person's name in the social network. If they don't have a name, they use a unique ID.     |
| **`self.graph`**      | **`Any`**       | Reference to the graph this node is part of.              | Represents the social network platform or community the person belongs to.                      |
| **`self.edge_graph`** | **`dict`**      | Tracks connections to other nodes.                        | A list of the person's friends and the details about how and why they are friends (shared interests, etc.).  |
| **`self.merge_graph`**| **`dict`**      | Maintains history of merges with other nodes.             | History of when and why two people (one of which is the person) decided to represent themselves as a single entity (like a couple or a team). |
| **`self.rep_by`**     | **`Node`**/**`None`** | Indicates which node this node is represented by.        | If a person is part of a group or team, this shows who is the spokesperson or leader of that group. |
| **`self.members`**    | **`set`**       | Set of nodes in the equivalence class this node belongs to. | Members of a group or community that the person is part of.                                      |
| **`self._val`**       | **`Node`**/**`None`** | Private attribute for value-type relationships.           | Represents a specific quality or characteristic of a/the person, like their role in a project.      |
| **`self._obj`**       | **`Node`**/**`None`** | Private attribute for object-type relationships.          | The actual project or object that is associated with the person's role.                          |
| **`self.deps`**       | **`list`**      | List of dependencies.                                     | Other people or things that this person relies on or is influenced by.                          |
| **`self.num`**        | **`Numeric`**/**`None`** | Numerical representation of the node.                     | A unique number or ID for the person, used for sorting or identification purposes.              |
| **`self.change`**     | **`set`**       | Tracks nodes dependent on this node's numerical representation. | People who are influenced or affected by changes in this person's status or role.               |

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Method Overview</b>

To explain the methods of the **`Node`** class, let's continue using the social network analogy as well as explaining things simply based on the real purpose.


| **Method**                  | **Purpose in Node Class**                                       | **Social Network Analogy**                                                                                   |
|-------------------------|-------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| **`set_rep`**               | Sets another node as the representative of this node.       | Choosing someone to represent you in the social network, like a spokesperson or agent.                  |
| **`rep`**                   | Finds the representative node of this node.                 | Finding out who is currently representing you in the network.                                            |
| **`why_rep`**               | Explains why a node has a certain representative.           | Understanding the reasons or history behind why someone represents you.                                  |
| **`rep_and_why`**           | Gets the representative and the reason for representation.  | Identifying your representative and understanding why they represent you.                                |
| **`neighbors`**             | Finds neighboring nodes of a certain type.                  | Looking for people in your network who have a specific relationship to you (friends, colleagues, etc.). |
| **`merge_edge_graph`**      | Merges the edge graph of another node into this one.        | Combining your friendship network with someone else's.                                                   |
| **`merge`**                 | Merges this node with a list of other nodes.                | Forming a group or a team with a list of people.                                                         |
| **`merge_one`**             | Merges this node with another specific node.                | Forming a partnership or alliance with another person.                                                   |
| **`is_val`**                | Checks if a node has a specific value-type relationship.    | Determining if your relationship with someone has a specific characteristic (like a work relationship). |
| **`set_val`**               | Sets a value-type relationship for the node.                | Defining a specific characteristic of your relationship with someone.                                    |
| **`set_obj`**               | Sets an object-type relationship for the node.              | Associating a specific item or project with your relationship.                                           |
| **`val`** (property)        | Gets the value-type relationship of the node.               | Checking the specific characteristic of your relationship with someone.                                  |
| **`obj`** (property)        | Gets the object-type relationship of the node.              | Looking at the item or project associated with your relationship.                                        |
| **`equivs`**                | Gets all nodes equivalent to this node.                     | Finding all the people who are considered the same as you in the network (like members of a team).      |
| **`connect_to`**            | Connects this node to another node with dependencies.       | Forming a connection or relationship with someone, with specific reasons or conditions.                 |
| **`equivs_upto`**           | Finds equivalent nodes up to a certain level.               | Identifying people who are equivalent to you up to a certain degree or within a certain context.        |
| **`why_equal`**             | Explains why this node is equal to other nodes.             | Understanding why you are considered the same as other people in specific situations.                    |
| **`why_equal_groups`**      | Finds reasons for equality among groups of nodes.           | Finding out why you are considered part of different groups or categories in the network.                |
| **`why_val`**               | Explains why a node has a specific value-type relationship. | Understanding why a specific characteristic defines your relationship with someone.                      |
| **`why_connect`**           | Explains the reason behind a connection to another node.    | Understanding the reasons or history behind your connection with someone else.                           |

Each method in the `Node` class plays a role similar to interactions and relationships in a social network, managing how individuals (nodes) relate to each other, form groups, represent one another, and define their relationships.

---

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Code Walkthrough</b>

I will now go through the actual code itself:
* I will add comments that are overly verbose to help over-explain functionality
* I will add Google style docstrings
* I will rewrite certain parts of the code if necessary to improve my understanding

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">4.3 <code><b>GEOMETRY.PY</b></code> FILE - THE <b>NODE</b> CLASS</h3>
<hr>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">The Remaining Class Definitions</b>

* Each subclass represents different geometric concepts.
* These classes inherit from Node and have additional methods specific to their geometric nature.
* The actual geometric concepts that are created as subclasses are:
    * **`Point`** / **`Node`**
        * A basic unit in geometry, representing a location in space with no implicit size or dimension.
    * **`Line`**
        * A line is an **infinitely long** (otherwise it would be a **segment**, straight path with no thickness.
        * It's a fundamental concept because it's used to define other geometric figures, and many theorems in Euclidean Geometry are based on the properties of lines.
    * **`Segment`**
        * A segment is a part of a line that is bounded by two distinct end points. 
        * Segments are important because they represent the simplest form of a measurable distance in geometry.
    * **`Circle`**
        * A circle is a set of points in a plane that are all at a given distance (the radius) from a fixed point (the center). 
        * Circles are crucial in geometry due to their symmetry and the way they relate to other geometric figures like lines and angles.
    * **`Angle`**
        * An angle is formed by two rays (or line segments) with a common endpoint. 
        * Angles are a fundamental measure of the rotation between two intersecting lines and are key to understanding geometric properties and relationships.
        * Angles help us define more complication geometric concepts (planes, etc)
    * **`Ratio`**
        * In geometry, ratios are used to compare sizes of similar figures, lengths of sides, and other quantities. 
        * Ratios are fundamental in understanding proportions and scaling in geometry, as well as in trigonometry.
    * **`Direction`**
        * Refers to the course along which something moves or faces. 
        * In geometry, direction can be represented as vectors or through angular relationships.
    * **`Measure`** and **`Length`**
        * Understanding how to quantify or measure geometrical entities. 
        * Length typically refers to the distance between two points/nodes
        * Measure is similar but usually extends to Angle(s), Area(s), etc.
    * **`Angle`**
        * Formed by two rays (or lines) that share a common endpoint. 
        * Understanding how angles are measured and their properties is important.

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Resources for Fundamentals of Euclidean Geometry</b>

* <a href=""https://math.libretexts.org/Courses/Mount_Royal_University/MATH_1150%3A_Mathematical_Reasoning/4%3A_Basic_Concepts_of_Euclidean_Geometry/4.1%3A_Euclidean_geometry""><b>Mathematics LibreTexts</b></a>: 
    * This resource offers detailed explanations of the basic concepts in Euclidean geometry. 
    * It covers the definitions and properties of points, lines, planes, angles, and various geometric figures, which are essential for understanding the structure and relationships in Euclidean space. 
    * It also discusses **Euclid's five postulates** (discussed above), which are the foundational assumptions of this field. 
    * This is a great resource for learning about the core elements of Euclidean Geometry in a structured manne.
* <a href=""https://byjus.com/maths/euclidean-geometry/""><b>BYJU'S Euclidean Geometry</b></a>: 
    * This is an educational resource that provides an overview of Euclidean geometry.
    * It covers the study of geometrical shapes and figures based on different axioms and theorems, primarily focusing on flat or plane surfaces (similar to the topic of AlphaGeometry). 
    * The resource also touches upon the historical context of Euclidean geometry, its development, and its foundational elements like points, lines, and planes. 
    * I found this one useful for understanding the practical applications and historical significance of Euclidean Geometry.
* <a href=""https://www.britannica.com/science/Euclidean-geometry/Solid-geometry""><b>Britannica on Euclidean Geometry</b></a>: 
    * This article provides a summary of Euclidean geometry, emphasizing its role as the study of plane and solid figures based on axioms and theorems used by the Greek mathematician Euclid. 
    * It underlines the importance of fundamental concepts like points, lines, angles, and circles in forming the basis of Euclidean geometry (very similar to what we are doing next). 
    * The resource is valuable for those looking to understand the broader context and impact of Euclidean geometry in the field of mathematics.

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Graph Networking Concepts</b>

* **Node (Vertex)** 
    * A fundamental unit in a graph network, representing an entity (e.g., a point, line, circle, etc. ***in geometry***).
* **Edge** 
    * Represents the relationship or connection between two nodes in a graph.
* **Graph Traversal**: 
    * The process of visiting, checking, and/or updating nodes in a graph. 
    * Common methods include (but are not limited to) 
        * <b><a href=""https://www.wikiwand.com/en/Breadth-first_search"">Breadth-First Search (BFS)</a></b>
        * <b><a href=""https://www.wikiwand.com/en/Depth-first_search"">Depth-First Search (DFS)</a></b>
* **Abstraction Levels**
    * In graph networks, different levels of abstraction can be used to simplify or complicate the representation of relationships.
* **Neighbors**
    * In a graph, neighbors of a node are other nodes that are directly connected to it by an edge.
* **Equivalence & Equality in Graphs**
    * Understanding when two nodes are considered equivalent or equal
    * This is not as straightforward as it may appear... it may involve complex logic beyond simple identity or value comparison.
* **Recursion** 
    * Some functions use recursion, which is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem.
    * NOTE: This is not a graph networking concept but is important nonetheless

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Point` Class</b>

| **Method**            | **Purpose in Point Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node without any modification.             | Point is a basic entity in geometry without additional methods beyond those in Node. |

---

<br>

---

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Direction` Class</b>

| **Method**            | **Purpose in Direction Class**                                        | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node and represents a geometric direction. | Direction is used to represent the concept of direction in geometry without additional methods beyond those in Node. |

---

<br>

---

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Measure` Class</b>

| **Method**            | **Purpose in Measure Class**                                          | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node, specializing in geometric measures.  | Measure represents various measurements like angles, lengths, etc., without additional methods beyond those in Node. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Length` Class</b>

| **Method**            | **Purpose in Length Class**                                           | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node, specializing in representing lengths.| Length represents lengths in geometry without additional methods beyond those in Node. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Value` Class</b>

| **Method**            | **Purpose in Value Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| *(No specific methods)* | Inherits all behavior from Node, encapsulating a generic value.       | Value is used in various contexts like ratios without additional methods beyond those in Node. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Line` Class</b>

| **Method**            | **Purpose in Line Class**                                             | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**             | Creates a new Direction node associated with this Line.               | Used to create a directional aspect for a line.      |
| **`why_coll`**            | Explains why given points are collinear with this line.               | Used to determine the collinearity of points with the line. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Segment` Class</b>

| **Method**            | **Purpose in Segment Class**                                          | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**            | Creates a new Length node associated with this Segment.               | Used to associate a length measure with a segment.   |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Circle` Class</b>

| **Method**            | **Purpose in Circle Class**                                           | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`why_cyclic`**          | Explains why given points are cyclic with respect to this circle.     | Determines the cyclic nature of points with respect to the circle. |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Angle` Class</b>

| **Method**            | **Purpose in Angle Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**             | Creates a new Measure node associated with this Angle.                | Associates a measurement with an angle.              |
| **`set_directions`**      | Sets two Direction nodes associated with this Angle.                  | Used to define the directional aspects of an angle.  |
| **`directions`** (property)| Gets the Direction nodes associated with this Angle.                  | Retrieves the directional components of an angle.    |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">`Ratio` Class</b>

| **Method**            | **Purpose in Ratio Class**                                            | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`new_val`**             | Creates a new Value node associated with this Ratio.                  | Associates a value with a ratio.                     |
| **`set_lengths`**         | Sets two Length nodes associated with this Ratio.                     | Used to define the proportional lengths in a ratio.  |
| **`lengths`** (property)  | Gets the Length nodes associated with this Ratio.                     | Retrieves the lengths involved in the ratio.         |

---

<br>

---


<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Other Standalone Functions</b>

| **Function**          | **Purpose**                                                           | **Description**                                      |
|-----------------------|-----------------------------------------------------------------------|------------------------------------------------------|
| **`why_connect`**         | Explains the connection reasons between pairs of nodes.               | Used to understand the dependencies behind node connections. |
| **`is_equiv`**           | Checks if two nodes are equivalent up to a certain level.             | Determines the equivalence of nodes with a depth limit in the graph. |
| **`is_equal`**           | Checks if two nodes are equal based on their values.                  | Evaluates equality based on node values and their relationships. |
| **`why_equal`**          | Explains why two nodes are considered equal.                         | Used to understand the reasons behind node equality. |
| **`get_lines_thru_all`** | Retrieves lines passing through a set of points.                      | Finds all lines intersecting a given set of points.  |
| **`line_of_and_why`**    | Determines the line connecting points and explains why.               | Identifies and rationalizes the line connecting specific points. |
| **`get_circles_thru_all`**| Retrieves circles passing through a set of points.                    | Finds all circles encompassing a given set of points.|
| **`circle_of_and_why`**   | Determines the circle connecting points and explains why.             | Identifies and rationalizes the circle connecting specific points.|
| **`name_map`**          | Maps structures to their names for easier representation.             | Converts complex structures into a readable name format. |
| **`all_angles`**          | Yields all angles formed by a pair of directions.                     | Generates angles based on direction pairs.           |
| **`all_ratios`**          | Yields all ratios formed by a pair of directions.                     | Generates ratios based on direction pairs.           |

---

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Readability Improvements</b>

To improve the readability and organization of the provided code, we can group related functionalities together and ensure a logical flow. This includes grouping the following:
* Class Definitions
    * We will place all class definitions at the beginning. 
    * This makes it easier to understand the available entities before diving into the functions that operate on them.
* Utility Functions
    * We place utility functions like **`why_connect`**, **`is_equal`**, **`why_equal`**, etc., after class definitions. 
    * These functions are general-purpose and can be used across different classes.
* Specific Functions
    * We place specific functions after the utility functions.
    * These functions, like **`get_lines_thru_all`**, **`line_of_and_why`**, **`get_circles_thru_all`**, **`circle_of_and_why`**, etc., offer more specific (sometimes more complicated) functionality.
    * These functions often utilize the utility functions and class methods.
* Global Variables and Constants
    * We place **`RANKING`** (and other globals if they existed... but they don't) at the end. 
    * Globals are often less crucial to the immediate understanding of the code's functionality.

<br>

---

<br>

<b style=""text-decoration: underline; font-family: Verdana; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;"">Code Walkthrough</b>

I will now go through the actual code itself and at a minimum...
* I will add comments that are overly verbose to help over-explain functionality
* I will add Google style docstrings
* I will rewrite certain parts of the code if necessary to improve my understanding

<br>


<br>

**Let's make a fake Geometry module so we can spoof the import**
<br>

<a id=""problem""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""problem"">5&nbsp;&nbsp;PROBLEM &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.1 <code>PROBLEM.PY</code> FILE <b>IMPORTS</b></h3>
<hr>

We can see by the imports that we are mostly dealing the **`geometry`** submodule, the **`pretty`** submodule and a few additional packages (i.e. <a href=""https://docs.python.org/3/library/fractions.html"">`Fractions`</a>, `NumPy`, `SciPy`, etc.)

We also include the license information here as found within the original file:
* https://github.com/google-deepmind/alphageometry/blob/main/ar.py
* **Apache License, Version 2.0**
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.2 <code><b>PRETTY.PY</b></code> FILE - THE <b>PRETTY</b> HELPER FUNCTIONS</h3>
<hr>

Utilities for string manipulation in the DSL.
<br>

**Let's make a fake Pretty module (**`pt`**) so we can spoof the import**
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.3 <code><b>PROBLEM.PY</b></code> FILE - BASIC <b>FUNCTIONS</b></h3>
<hr>

reshape, isint, _gcd, simplify, hashed, and hashed_txt

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.4 <code><b>PROBLEM.PY</b></code> FILE - PREDICATE <b>CLASSES</b></h3>
<hr>

These two classes (**`Construction`** and **`Clause`**) are for handling one or many (respectively) predicates.

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.5 <code><b>PROBLEM.PY</b></code> FILE - THE PROBLEM <b>CLASS</b></h3>
<hr>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.6 <code><b>PROBLEM.PY</b></code> FILE - THE DEFINITION <b>CLASS</b></h3>
<hr>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.7 <code><b>PROBLEM.PY</b></code> FILE - THE THEOREM <b>CLASS</b></h3>

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.8 <code><b>PROBLEM.PY</b></code> FILE - THE DEPENDENCY AND EMPTYDEPENDENCY <b>CLASS</b></h3>

**`Dependency`** extends **`Construction`** and represents a geometrical predicate that depends on other predicates. 

<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">5.9 <code><b>PROBLEM.PY</b></code> FILE - THE SPECIFIC/COMPLEX <b>FUNCTIONS</b></h3>

<br>

<a id=""ar""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""numericals"">6&nbsp;&nbsp;NUMERICALS &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.1 <code><b>NUMERICALS.PY</b></code> FILE <b>IMPORTS</b></h3>
<hr>

We can see by the imports that we are mostly dealing the **`geometry`** submodule and a few additional packages (i.e. <a href=""https://docs.python.org/3/library/fractions.html"">`Fractions`</a>, `NumPy`, `SciPy`, etc.)

We also include the license information here as found within the original file:
* https://github.com/google-deepmind/alphageometry/blob/main/ar.py
* **Apache License, Version 2.0**
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.2 <code><b>NUMERICALS.PY</b></code> FILE - THE GEOMETRIC <b>CLASSES</b></h3>


| **Function Name**                | **Description**                                                                         | **Parameters**                                                                                                                                                                                                  | **Returns**                                                                                | **Notes**                                                               |
|:----------------------------------:|-----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|-------------------------------------------------------------------------|
| **`_perpendicular_bisector`**    | Constructs a line that is the perpendicular bisector of the segment between two points. | **`p1`**, **`p2`**: Points defining the segment.                                                                                                                                                                | **`Line`**: The perpendicular bisector.                                                    | -                                                                       |
| **`same_sign`**                  | Checks if two sets of points have the same rotational direction.                        | **`a`**, **`b`**, **`c`**, **`d`**, **`e`**, **`f`**: Points to check.                                                                                                                                          | **`bool`**: True if same rotational direction, otherwise False.                            | Uses cross product.                                                     |
| **`solve_quad`**                 | Solves a quadratic equation of the form ax^2 + bx + c = 0.                              | **`a`**, **`b`**, **`c`**: Coefficients of the equation.                                                                                                                                                        | **`tuple[float, float]`**: Solutions of the equation.                                      | Returns **`None`** if no real solutions.                                |
| **`circle_circle_intersection`** | Finds intersection points of two circles.                                               | **`c1`**, **`c2`**: The two circles to intersect.                                                                                                                                                               | **`tuple[Point, Point]`**: Intersection points.                                            | Raises **`InvalidQuadSolveError`** for certain conditions.              |
| **`line_circle_intersection`**   | Calculates intersection points of a line and a circle.                                  | **`line`**: The line, **`circle`**: The circle.                                                                                                                                                                 | **`tuple[Point, Point]`**: Intersection points.                                            | Handles vertical and horizontal lines specially.                        |
| **`_check_between`**             | Checks if a point is between two other points.                                          | **`a`**, **`b`**, **`c`**: The points to check.                                                                                                                                                                 | **`bool`**: True if **`a`** is between **`b`** and **`c`**.                                | Uses dot product for the check.                                         |
| **`circle_segment_intersect`**   | Finds intersection points between a circle and a line segment.                          | **`circle`**: The circle, **`p1`**, **`p2`**: Endpoints of the segment.                                                                                                                                         | **`list[Point]`**: Intersection points.                                                    | Filters out points not on the segment.                                  |
| **`line_segment_intersection`**  | Calculates the intersection point of a line and a line segment.                         | **`l`**: The line, **`A`**, **`B`**: Endpoints of the segment.                                                                                                                                                  | **`Point`**: Intersection point.                                                           | -                                                                       |
| **`line_line_intersection`**     | Finds the intersection point of two lines.                                              | **`l1`**, **`l2`**: The lines to intersect.                                                                                                                                                                     | **`Point`**: Intersection point.                                                           | Raises **`InvalidLineIntersectError`** if lines are parallel.           |
| **`check_too_close`**            | Checks if any new point is too close to existing points.                                | **`newpoints`**: List of new points, **`points`**: List of existing points, **`tol`**: Tolerance factor.                                                                                                        | **`bool`**: True if any new point is too close to existing points.                         | Compares distances based on a minimum distance threshold.               |
| **`check_too_far`**              | Checks if any new point is too far from existing points.                                | **`newpoints`**: List of new points, **`points`**: List of existing points, **`tol`**: Tolerance factor.                                                                                                        | **`bool`**: True if any new point is too far from existing points.                         | Compares distances based on a maximum distance threshold.               |
| **`check_aconst`**               | Checks if an angle between points matches a given constant ratio.                       | **`args`**: List containing points **`a`**, **`b`**, **`c`**, **`d`** and angle ratio **`num`**, **`den`**.                                                                                                     | **`bool`**: True if angle matches the constant.                                            | Uses **`ang_between`** for angle calculation.                           |
| **`check`**                      | Performs various geometric checks based on the provided name.                           | **`name`**: Name of the check, **`args`**: List of points or geometric objects.                                                                                                                                 | **`bool`**: Result of the check.                                                           | Delegates to specific **`check_`** functions.                           |
| **`check_circle`**               | Checks if points form a circle.                                                         | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points form a circle.                                                  | Ensures equal distances from a common point.                            |
| **`check_coll`**                 | Checks if points are collinear.                                                         | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points are collinear.                                                  | Uses line equation for the check.                                       |
| **`check_ncoll`**                | Checks if points are not collinear.                                                     | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points are not collinear.                                              | Negation of **`check_coll`**.                                           |
| **`check_sameside`**             | Checks if two sets of points are on the same side of a line.                            | **`points`**: List of six points.                                                                                                                                                                               | **`bool`**: True if on the same side.                                                      | Uses dot product for the check.                                         |
| **`check_para_or_coll`**         | Checks if points form parallel lines or are collinear.                                  | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if parallel or collinear.                                                 | Combines **`check_para`** and **`check_coll`**.                         |
| **`check_para`**                 | Checks if points form parallel lines.                                                   | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if lines are parallel.                                                    | Uses line properties for the check.                                     |
| **`check_perp`**                 | Checks if points form perpendicular lines.                                              | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if lines are perpendicular.                                               | Uses line properties for the check.                                     |
| **`check_cyclic`**               | Checks if points lie on a common circle.                                                | **`points`**: List of points.                                                                                                                                                                                   | **`bool`**: True if points are cyclic.                                                     | Uses circle properties for the check.                                   |
| **`bring_together`**             | Brings points together based on line intersections.                                     | **`a`**, **`b`**, **`c`**, **`d`**: Points to be processed.                                                                                                                                                     | **`tuple[Point, Point, Point, Point]`**: New points after processing.                      | Uses line intersections to generate new points.                         |
| **`same_clock`**                 | Checks if two sets of points have the same clockwise order.                             | **`a`**, **`b`**, **`c`**, **`d`**, **`e`**, **`f`**: Points to check.                                                                                                                                          | **`bool`**: True if both sets have the same clockwise order.                               | Uses cross product to determine order.                                  |
| **`check_const_angle`**          | Checks if an angle between points is a constant.                                        | **`points`**: List containing points and constants.                                                                                                                                                             | **`bool`**: True if angle is constant.                                                     | Uses angle calculation and comparison.                                  |
| **`check_eqangle`**              | Checks if two sets of points form equal angles.                                         | **`points`**: List of eight points.                                                                                                                                                                             | **`bool`**: True if angles are equal.                                                      | Compares angles formed by line intersections.                           |
| **`check_eqratio`**              | Checks if ratios of distances between points are equal.                                 | **`points`**: List of eight points.                                                                                                                                                                             | **`bool`**: True if ratios are equal.                                                      | Compares ratios of distances.                                           |
| **`check_cong`**                 | Checks if distances between pairs of points are congruent.                              | **`points`**: List of four points.                                                                                                                                                                              | **`bool`**: True if distances are congruent.                                               | Compares distances directly.                                            |
| **`check_midp`**                 | Checks if a point is the midpoint between two other points.                             | **`points`**: List of three points.                                                                                                                                                                             | **`bool`**: True if one point is the midpoint.                                             | Ensures the distances to the midpoint are equal.                        |
| **`check_simtri`**               | Checks if two sets of points form similar triangles.                                    | **`points`**: List of six points.                                                                                                                                                                               | **`bool`**: True if triangles are similar.                                                 | Compares ratios of sides' lengths.                                      |
| **`check_contri`**               | Checks if two sets of points form congruent triangles.                                  | **`points`**: List of six points.                                                                                                                                                                               | **`bool`**: True if triangles are congruent.                                               | Compares lengths of corresponding sides.                                |
| **`check_ratio`**                | Checks if ratio of distances between pairs of points matches a given ratio.             | **`points`**: List containing points and the ratio.                                                                                                                                                             | **`bool`**: True if ratio matches.                                                         | Compares product of distances with the given ratio.                     |
| **`draw_angle`**                 | Draws an angle on a matplotlib axis.                                                    | **`ax`**: Matplotlib axis, **`head`**: Vertex of the angle, **`p1`**, **`p2`**: Points defining the angle, **`color`**, **`alpha`**, **`frac`**: Styling options.                                               | None                                                                                       | Uses arctan2 for angle calculation.                                     |
| **`naming_position`**            | Determines a good position for naming a point in a drawing.                             | **`ax`**: Matplotlib axis, **`p`**: Point to be named, **`lines`** and **`circles`**: Existing geometric objects.                                                                                               | **`tuple[float, float]`**: Position for the name.                                          | Avoids overlap with other objects.                                      |
| **`draw_point`**                 | Draws a point on a matplotlib axis.                                                     | **`ax`**: Matplotlib axis, **`p`**: Point to draw, **`name`**: Name of the point, **`lines`**, **`circles`**: Existing geometric objects, **`color`**, **`size`**: Styling options.                             | None                                                                                       | -                                                                       |
| **`_draw_line`**                 | Helper function to draw a line in matplotlib.                                           | **`ax`**: Matplotlib axis, **`p1`**, **`p2`**: Points defining the line, **`color`**, **`lw`**, **`alpha`**: Styling options.                                                                                   | None                                                                                       | -                                                                       |
| **`draw_line`**                  | Draws a line on a matplotlib axis.                                                      | **`ax`**: Matplotlib axis, **`line`**: Line to draw, **`color`**: Styling option.                                                                                                                               | **`tuple[Point, Point]`**: Points defining the line.                                       | Extends line to fit the drawing area.                                   |
| **`_draw_circle`**               | Helper function to draw a circle in matplotlib.                                         | **`ax`**: Matplotlib axis, **`c`**: Circle to draw, **`color`**, **`lw`**: Styling options.                                                                                                                     | None                                                                                       | -                                                                       |
| **`draw_circle`**                | Draws a circle on a matplotlib axis.                                                    | **`ax`**: Matplotlib axis, **`circle`**: Circle to draw, **`color`**: Styling option.                                                                                                                           | **`Circle`**: The drawn circle.                                                            | -                                                                       |
| **`mark_segment`**               | Marks a segment on a matplotlib axis.                                                   | **`ax`**: Matplotlib axis, **`p1`**, **`p2`**: Endpoints of the segment, **`color`**, **`alpha`**: Styling options.                                                                                             | None                                                                                       | Places a marker at the midpoint of the segment.                         |
| **`highlight_angle`**            | Highlights an angle in a matplotlib drawing.                                            | **`ax`**: Matplotlib axis, **`a`**, **`b`**, **`c`**, **`d`**: Points defining the angle, **`color`**, **`alpha`**: Styling options.                                                                            | None                                                                                       | Uses **`draw_angle`** for highlighting.                                 |
| **`highlight`**                  | Draws various highlights based on the provided name.                                    | **`ax`**: Matplotlib axis, **`name`**: Type of highlight, **`args`**: Points or objects for the highlight, **`lcolor`**, **`color1`**, **`color2`**: Styling options.                                           | None                                                                                       | Delegates to specific drawing functions based on **`name`**.            |
| **`_draw`**                      | Draws all elements on a matplotlib axis.                                                | **`ax`**: Matplotlib axis, **`points`**, **`lines`**, **`circles`**: Geometric objects to draw, **`goal`**, **`equals`**, **`highlights`**: Additional drawing parameters.                                      | None                                                                                       | Main function to handle drawing of all elements.                        |
| **`set_theme`**                  | Sets the theme for the drawing.                                                         | **`theme`**: The theme to set.                                                                                                                                                                                  | None                                                                                       | Global variable **`THEME`** is used.                                    |
| **`get_theme`**                  | Gets the current drawing theme.                                                         | None                                                                                                                                                                                                            | **`str`**: Current theme.                                                                  | -                                                                       |
| **`draw`**                       | Main function to draw everything on a single canvas.                                    | **`points`**, **`lines`**, **`circles`**, **`segments`**: Geometric objects, **`goal`**, **`highlights`**, **`equals`**: Additional parameters, **`block`**, **`save_to`**, **`theme`**: Configuration options. | None                                                                                       | Initializes and configures the matplotlib drawing.                      |
| **`close_enough`**               | Checks if two float values are close enough based on a tolerance.                       | **`a`**, **`b`**: Float values, **`tol`**: Tolerance.                                                                                                                                                           | **`bool`**: True if values are close enough.                                               | -                                                                       |
| **`assert_close_enough`**        | Asserts that two float values are close enough.                                         | **`a`**, **`b`**: Float values, **`tol`**: Tolerance.                                                                                                                                                           | None                                                                                       | Throws an assertion error if not                                        |
| **`ang_of`**                     | Calculates the angle of a line segment defined by two points.                           | **`tail`**, **`head`**: The points defining the line segment.                                                                                                                                                   | **`float`**: The angle in radians.                                                         | Uses **`np.arctan2`** for angle calculation.                            |
| **`ang_between`**                | Calculates the angle between two line segments sharing a common tail point.             | **`tail`**, **`head1`**, **`head2`**: The points defining the line segments.                                                                                                                                    | **`float`**: The angle in radians.                                                         | Adjusts angle to be within the range \[-π, π\].                         |
| **`head_from`**                  | Calculates the head point of a line segment given its tail, length, and angle.          | **`tail`**: Starting point, **`ang`**: Angle in radians, **`length`**: Length of the segment.                                                                                                                   | **`Point`**: The head point of the segment.                                                | -                                                                       |
| **`random_points`**              | Generates a list of random points.                                                      | **`n`**: Number of points to generate.                                                                                                                                                                          | **`list[Point]`**: List of randomly generated points.                                      | Points are within the range \[-1, 1\] for both x and y.                 |
| **`random_rfss`**                | Applies random rotation, flip, scale, and shift to a list of points.                    | **`points`**: List of points to transform.                                                                                                                                                                      | **`list[Point]`**: Transformed list of points.                                             | Used for creating variations in geometric configurations.               |
| **`reduce`**                     | Reduces intersecting geometric objects to points of intersection.                       | **`objs`**: List of geometric objects, **`existing_points`**: List of existing points for reference.                                                                                                            | **`list[Point]`**: Points of intersection.                                                 | Handles different types of intersections.                               |
| **`sketch`**                     | General function to sketch various geometric objects based on a name.                   | **`name`**: Name of the sketch function, **`args`**: Arguments for the sketch function.                                                                                                                         | **`list[Union[Point, Line, Circle, HalfLine, HoleCircle]]`**: Resulting geometric objects. | Delegates to specific **`sketch_`** functions.                          |
| **`sketch_on_opline`**           | Sketches a half-line opposite to a given line segment.                                  | **`args`**: Points defining the line segment.                                                                                                                                                                   | **`HalfLine`**: The opposite half-line.                                                    | -                                                                       |
| **`sketch_on_hline`**            | Sketches a half-line.                                                                   | **`args`**: Points defining the half-line.                                                                                                                                                                      | **`HalfLine`**: The sketched half-line.                                                    | -                                                                       |
| **`sketch_ieq_triangle`**        | Sketches an isosceles right-angled triangle.                                            | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: The triangle's vertices.                                          | -                                                                       |
| **`sketch_incenter2`**           | Sketches the incenter of a triangle and feet of angle bisectors.                        | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Incenter and feet of angle bisectors.                             | Uses angle bisectors to find the incenter.                              |
| **`sketch_excenter2`**           | Sketches an excenter of a triangle and feet of external angle bisectors.                | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Excenter and feet of external angle bisectors.                    | Uses external angle bisectors to find the excenter.                     |
| **`sketch_centroid`**            | Sketches the centroid of a triangle and midpoints of its sides.                         | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Centroid and midpoints of sides.                                  | Uses midpoints and line intersections to find the centroid.             |
| **`sketch_ninepoints`**          | Sketches the nine-point circle center of a triangle and midpoints of its sides.         | **`args`**: Points defining the triangle.                                                                                                                                                                       | **`tuple[Point, ...]`**: Nine-point circle center and midpoints of sides.                  | Uses midpoints to find the nine-point circle center.                    |
| **`sketch_2l1c`**                | Sketches a circle touching two lines and another circle.                                | **`args`**: Points defining the lines and the circle.                                                                                                                                                           | **`tuple[Point, ...]`**: Points related to the construction.                               | Complex geometric construction involving lines and a circle.            |
| **`sketch_3peq`**                | Sketches points for creating a figure with three equal segments.                        | **`args`**: Points defining the base figure.                                                                                                                                                                    | **`tuple[Point, ...]`**: Points defining the equal segments.                               | -                                                                       |
| **`try_to_sketch_intersect`**    | Tries to find an intersection point between two sketched objects.                       | **`name1`**, **`args1`**: First object, **`name2`**, **`args2`**: Second object, **`existing_points`**: Reference points.                                                                                       | **`Optional[Point]`**: Intersection point if found.                                        | Handles different types of intersections.                               |
| **`sketch_acircle`**             | Sketches a circle based on specific geometric constraints.                              | **`args`**: Points defining the constraints.                                                                                                                                                                    | **`Circle`**: The resulting circle.                                                        | Uses line intersections to define the circle.                           |
| **`sketch_aline`**               | Sketches a construction line based on specific angles and points.                       | **`args`**: Points defining the angles and line.                                                                                                                                                                | **`HalfLine`**: The resulting construction line.                                           | Complex geometric construction involving angles.                        |
| **`sketch_amirror`**             | Sketches an angle mirror line.                                                          | **`args`**: Points defining the angle to mirror.                                                                                                                                                                | **`HalfLine`**: The angle mirror line.                                                     | -                                                                       |
| **`sketch_bisect`**              | Sketches a line that bisects the angle between two line segments.                       | **`args`**: Points defining the angle.                                                                                                                                                                          | **`Line`**: The angle bisector.                                                            | -                                                                       |
| **`sketch_exbisect`**            | Sketches a line that bisects the external angle between two line segments.              | **`args`**: Points defining the angle.                                                                                                                                                                          | **`Line`**: The external angle bisector.                                                   | -                                                                       |
| **`sketch_bline`**               | Sketches the perpendicular bisector of a line segment.                                  | **`args`**: Points defining the line segment.                                                                                                                                                                   | **`Line`**: The perpendicular bisector.                                                    | -                                                                       |
| **`sketch_dia`**                 | Sketches a circle with a given diameter.                                                | **`args`**: Points defining the diameter.                                                                                                                                                                       | **`Circle`**: The circle with the specified diameter.                                      | -                                                                       |
| **`sketch_tangent`**             | Sketches tangent points from a point to a circle.                                       | **`args`**: Points defining the circle and external point.                                                                                                                                                      | **`tuple[Point, Point]`**: Tangent points.                                                 | Uses circle properties to find tangent points.                          |
| **`sketch_circle`**              | Sketches a circle based on a center and a point on the circumference.                   | **`args`**: Points defining the circle.                                                                                                                                                                         | **`Circle`**: The sketched circle.                                                         | -                                                                       |
| **`sketch_cc_tangent`**          | Sketches tangents to two circles.                                                       | **`args`**: Points defining the circles.                                                                                                                                                                        | **`tuple[Point, ...]`**: Points of tangency.                                               | Complex geometric construction involving two circles.                   |
| **`sketch_hcircle`**             | Sketches a hole circle (circle with a known point inside).                              | **`args`**: Points defining the circle and the hole.                                                                                                                                                            | **`HoleCircle`**: The hole circle.                                                         | -                                                                       |
| **`sketch_e5128`**               | Sketches points for a specific geometric problem (E5128).                               | **`args`**: Points defining the problem.                                                                                                                                                                        | **`tuple[Point, Point]`**: Points related to the problem.                                  | -                                                                       |
| **`sketch_eq_quadrangle`**       | Sketches a quadrangle with two equal opposite sides.                                    | **`args`**: Points defining the base quadrangle.                                                                                                                                                                | **`tuple[Point, ...]`**: Points of the quadrangle.                                         | Randomized construction within constraints.                             |
| **`sketch_eq_trapezoid`**        | Sketches an isosceles trapezoid.                                                        | **`args`**: Points defining the base trapezoid.                                                                                                                                                                 | **`tuple[Point, ...]`**: Points of the trapezoid.                                          | Randomized construction within constraints.                             |
| **`sketch_eqangle2`**            | Sketches a point based on equal angles constraint.                                      | **`args`**: Points defining the angles.                                                                                                                                                                         | **`Point`**: The resulting point.                                                          | Complex geometric construction involving equal angles.                  |
| **`sketch_eqangle3`**            | Sketches a circle based on equal angle constraints.                                     | **`args`**: Points defining the angles and circle.                                                                                                                                                              | **`Circle`**: The resulting circle.                                                        | Complex geometric construction involving angles and a circle.           |
| **`sketch_eqdia_quadrangle`**    | Sketches a quadrangle with two equal diagonals.                                         | **`args`**: Points defining the base quadrangle.                                                                                                                                                                | **`tuple[Point, ...]`**: Points of the quadrangle.                                         | Randomized construction within constraints.                             |
| **`sketch_free`**                | Sketches a random free point.                                                           | **`args`**: Not used.                                                                                                                                                                                           | **`Point`**: A random point.                                                               | Generates a completely random point.                                    |
| **`sketch_isos`**                | Sketches an isosceles triangle.                                                         | **`args`**: Points defining the base triangle.                                                                                                                                                                  | **`tuple[Point, ...]`**: Points of the triangle.                                           | Randomized construction within constraints.                             |
| **`sketch_line`**                | Sketches a line based on two points.                                                    | **`args`**: Points defining the line.                                                                                                                                                                           | **`Line`**: The sketched line.                                                             | -                                                                       |
| **`sketch_cyclic`**              | Sketches a circle passing through three points.                                         | **`args`**: Points defining the circle.                                                                                                                                                                         | **`Circle`**: The cyclic circle.                                                           | -                                                                       |
| **`sketch_hline`**               | Sketches a half-line.                                                                   | **`args`**: Points defining the half-line.                                                                                                                                                                      | **`HalfLine`**: The sketched half-line.                                                    | -                                                                       |
| **`sketch_midp`**                | Sketches the midpoint between two points.                                               | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: The midpoint.                                                                 | -                                                                       |
| **`sketch_pentagon`**            | Sketches a pentagon.                                                                    | **`args`**: Points defining the pentagon's vertices.                                                                                                                                                            | **`tuple[Point, ...]`**: Points of the pentagon.                                           | Constructs a pentagon with random orientation and size.                 |
| **`sketch_pline`**               | Sketches a line parallel to a given line through a point.                               | **`args`**: Point **`a`** and line through points **`b`** and **`c`**.                                                                                                                                          | **`Line`**: The parallel line.                                                             | -                                                                       |
| **`sketch_pmirror`**             | Sketches the reflection of a point across another point.                                | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: Reflected point.                                                              | Reflects **`a`** across **`b`**.                                        |
| **`sketch_quadrangle`**          | Sketches a random quadrangle.                                                           | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the quadrangle.                                         | Creates a quadrangle with random orientation and size.                  |
| **`sketch_r_trapezoid`**         | Sketches a right-angled trapezoid.                                                      | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the trapezoid.                                          | Constructs a right-angled trapezoid with random orientation and size.   |
| **`sketch_r_triangle`**          | Sketches a right-angled triangle.                                                       | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Creates a right-angled triangle with random orientation and size.       |
| **`sketch_rectangle`**           | Sketches a rectangle.                                                                   | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the rectangle.                                          | Constructs a rectangle with random orientation and size.                |
| **`sketch_reflect`**             | Sketches the reflection of a point across a line.                                       | **`args`**: Point **`a`** and line through points **`b`** and **`c`**.                                                                                                                                          | **`Point`**: Reflected point.                                                              | Reflects **`a`** across the line through **`b`** and **`c`**.           |
| **`sketch_risos`**               | Sketches a right isosceles triangle.                                                    | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Constructs a right isosceles triangle with random orientation and size. |
| **`sketch_rotaten90`**           | Rotates a point 90 degrees counterclockwise around another point.                       | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: The rotated point.                                                            | Rotation is performed counterclockwise.                                 |
| **`sketch_rotatep90`**           | Rotates a point 90 degrees clockwise around another point.                              | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`Point`**: The rotated point.                                                            | Rotation is performed clockwise.                                        |
| **`sketch_s_angle`**             | Sketches a line segment with a specified slope angle.                                   | **`args`**: Points **`a`**, **`b`**, and angle **`y`**.                                                                                                                                                         | **`HalfLine`**: The line segment.                                                          | **`y`** is the angle in degrees from **`a`** to **`b`**.                |
| **`sketch_segment`**             | Sketches a line segment between two random points.                                      | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, Point]`**: Endpoints of the segment.                                       | Generates a random line segment.                                        |
| **`sketch_shift`**               | Shifts a point by the vector defined by two other points.                               | **`args`**: Points **`a`**, **`b`**, and **`c`**.                                                                                                                                                               | **`Point`**: The shifted point.                                                            | Shifts **`c`** by the vector from **`a`** to **`b`**.                   |
| **`sketch_square`**              | Sketches a square.                                                                      | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`tuple[Point, Point]`**: Two opposite vertices of the square.                            | Constructs a square with one side defined by **`a`** and **`b`**.       |
| **`sketch_isquare`**             | Sketches an isosceles square.                                                           | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the square.                                             | Constructs an isosceles square with random orientation and size.        |
| **`sketch_tline`**               | Sketches a line perpendicular to a given line through a point.                          | **`args`**: Point **`a`** and line through points **`b`** and **`c`**.                                                                                                                                          | **`Line`**: The perpendicular line.                                                        | -                                                                       |
| **`sketch_trapezoid`**           | Sketches a trapezoid.                                                                   | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the trapezoid.                                          | Constructs a trapezoid with random orientation and size.                |
| **`sketch_triangle`**            | Sketches a triangle.                                                                    | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Creates a triangle with random orientation and size.                    |
| **`sketch_triangle12`**          | Sketches a triangle with side lengths in a 1:2 ratio.                                   | **`args`**: Not used.                                                                                                                                                                                           | **`tuple[Point, ...]`**: Points of the triangle.                                           | Constructs a triangle with sides in a 1:2 ratio.                        |
| **`sketch_trisect`**             | Sketches two trisectors of an angle.                                                    | **`args`**: Points **`a`**, **`b`**, and **`c`**.                                                                                                                                                               | **`tuple[Point, Point]`**: Points defining the trisectors.                                 | Divides the angle at **`b`** into three equal parts.                    |
| **`sketch_trisegment`**          | Sketches two points dividing a segment into three equal parts.                          | **`args`**: Points **`a`** and **`b`**.                                                                                                                                                                         | **`tuple[Point, Point]`**: The two division points.                                        | Divides the segment into three equal parts.                             |




**GRAPH UTILS**
**GRAPH**
<br>

<a id=""ar""></a>

<h1 style=""font-family: Verdana; font-size: 24px; font-style: normal; font-weight: bold; text-decoration: none; text-transform: none; letter-spacing: 3px; background-color: #ffffff; color: #799cb7;"" id=""ar"">6&nbsp;&nbsp;ALGEBRAIC REASONING &nbsp;&nbsp;&nbsp;&nbsp;<a style=""text-decoration: none; color: #77AAB0;"" href=""#toc"">&#10514;</a></h1>

<br>
<h3 style=""font-family: Verdana; font-size: 20px; font-style: normal; font-weight: normal; text-decoration: none; text-transform: none; letter-spacing: 2px; color: #192a51; background-color: #ffffff;"">6.1 <code><b>AR.PY</b></code> FILE <b>IMPORTS</b></h3>
<hr>

We can see by the imports that we are mostly dealing the **`geometry`** submodule, the **`problem`** submodule and a few additional packages (i.e. <a href=""https://docs.python.org/3/library/fractions.html"">`Fractions`</a>, `NumPy`, `SciPy`, etc.)

We also include the license information here as found within the original file:
* https://github.com/google-deepmind/alphageometry/blob/main/ar.py
* **Apache License, Version 2.0**
","['AI Mathematical Olympiad - Progress Prize 1', 'AlphaGeometry Github Repo', 'My CSS Styles']","['IPython.core.display', 'os', 'sys', 'tensorflow', 'pandas', 'numpy', 'sklearn;', 'kaggle_datasets', 'collections', 'datetime', 'zipfile', 'glob', 'Levenshtein', 'subprocess', 'warnings', 'requests', 'hashlib', 'imageio', 'IPython', 'sklearn', 'urllib', 'pickle', 'random', 'shutil', 'string', 'json', 'math', 'time', 'gzip', 'ast', 'io', 'gc', 're', 'matplotlib.colors', 'matplotlib.patches', 'plotly.graph_objects', 'matplotlib.pyplot', 'tqdm.notebook', 'plotly.express', 'tifffile', 'seaborn', 'PIL', 'matplotlib;', 'plotly', 'cv2', 'plotly.io', '__future__', 'typing', 'types', 'matplotlib', 'numpy.random']","Here are the unique aspects of the Machine Learning code written in Python:

**Pair Generation**: The `pairs` method generates a generator that yields tuples containing two strings each representing a line and a point pair. This is done by iterating over a dictionary, splitting each key-value pair into its components (line and point), and then combining them to form a new tuple.

**Name Generation**: The `name` method generates a unique name for a line-point pair by concatenating the line's name with the point's name, separated by a colon. This name is used as a key in another dictionary (`v2obj`) to store the corresponding line and point objects.

**Mapping Objects**: The `map2obj` method maps a list of names (generated by the `name` method) to a list of points. This is done by iterating over the list of names, looking up each name in the `v2obj` dictionary, and then returning the corresponding point object.

**Congruence Addition**: The `add_cong` method adds a congruence constraint between two line-point pairs. It first checks if one pair has a higher number than the other (based on some internal ordering), swaps them if necessary, and then names each point using the `name` method. Finally, it calls the parent class's `add_eq4` method to add the congruence constraint.

**Ratios Generation**: The code generates ratios of distances between line-point pairs by iterating over all possible pairs of points (using the `pairs` generator) and checking if the ratio is within a certain range. If so, it adds the ratio to a set of ratios and also adds the corresponding congruence constraint.

**Why Explanation**: The code provides an explanation for why each congruence constraint holds by computing the difference between two line-point pairs (using the `minus` function) and then simplifying the expression using some internal logic. This is done in the `get_all_eqs_and_why` method, which yields a generator that produces all congruence constraints along with their explanations.

These unique aspects of the code demonstrate various machine learning techniques such as pair generation, name generation, mapping objects, congruence addition, ratios generation, and why explanation."
Pure RNG,https://www.kaggle.com/code/xiaoz259/pure-rng,,,gold,72,5973,6.0s,1 month,"# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    BitsAndBytesConfig, 
    AutoConfig,
    set_seed
)

set_seed(42)

MODEL_PATH = ""/kaggle/input/deepseek-math""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map=""auto"",
    torch_dtype=""auto"",
    trust_remote_code=True,
#     quantization_config=quantization_config,
    config=config
)
model.dtype
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import transformers

pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=""auto"",
)
print(f""Transformers Version: {transformers.__version__}"")
import torch

torch.backends.cuda.enable_mem_efficient_sdp(False)
import re
import sys
import subprocess


def process_output(output):
    result = output
    
    try:
        code = output.split('```')[1][7:]

        with open('code.py', 'w') as fout:
            fout.write(code)

        batcmd = 'timeout 7 ' + sys.executable + ' code.py'
        try:
            shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
            print(shell_output)
            code_output = round(float(eval(shell_output))) % 1000
        except:
            code_output = -1

        print('CODE RESULTS', code_output)
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        code_output = -1
    
    try:
        result_output = re.findall(r'\\boxed\{(.*)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        result_output = -1
    
    return result_output, code_output
import re
from collections import defaultdict


tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'


n_repetitions = 8 if PRIVATE else 2

total_results = []
total_answers = []

for i in tqdm(range(len(df))):
    id_ = df['id'].loc[i]
    problem = df['problem'].loc[i]
    
    messages = [
        {
            ""role"": ""user"", 
            ""content"": problem + tool_instruction
        }
    ]
    
    query_prompt = tokenizer.apply_chat_template(
        messages,
        tokenize=False
    )
    
    results = []
    answers = []
    
    for _ in tqdm(range(n_repetitions)):
        try:lo
            raw_output = pipeline(
                query_prompt, 
                max_new_tokens=2048, 
                do_sample=True, 
                temperature=0.8964,
                return_full_text=False
            )
            raw_output = raw_output[0]['generated_text']

            result_output, code_output = process_output(raw_output)

            torch.cuda.empty_cache()
            gc.collect()

        except Exception as e:
            print(e)
            result_output, code_output = -1, -1
        
        results.append(result_output)
        answers.append(code_output)
    
    total_results.append(results)
    total_answers.append(answers)
import numpy as np
from collections import Counter

final_answers = []

for a, b in zip(total_answers, total_results):
    a = np.array(a)
    b = np.array(b)
    a[a < 0] = b[a < 0]
    
    pred = Counter(a.tolist()).most_common(2)

    ans = pred[0][0] if not pred[0][0] < 0 else pred[1][0]

    final_answers.append(ans)
    print(ans)

df['answer'] = final_answers
df
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = final_answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')
with open('code.py', 'w') as fout:
    fout.write(""print('done')"")

batcmd = 'timeout 7 ' + sys.executable + ' code.py'
try:
    shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
    print(shell_output)
except:
    pass
","# credits:
# https://www.kaggle.com/code/olyatsimboy/aimo-openmath-mistral-baseline
# https://www.kaggle.com/code/aatiffraz/prompt-prediction-w-mixtral-mistral7b-gemma-llama
# https://www.kaggle.com/code/thedrcat/aimo-mixtral-baseline
!pip install -U /kaggle/input/bitsandbytes-0-42-0-py3-none-any-whl/bitsandbytes-0.42.0-py3-none-any.whl -qq
import torch
from transformers import (
    AutoModelForCausalLM, 
    AutoTokenizer, 
    BitsAndBytesConfig, 
    AutoConfig,
    set_seed
)

set_seed(42)

MODEL_PATH = ""/kaggle/input/deepseek-math""

quantization_config = BitsAndBytesConfig(
    load_in_4bit = True,
    bnb_4bit_quant_type=""nf4"",
    bnb_4bit_compute_dtype=torch.bfloat16,
    bnb_4bit_use_double_quant=True,
)

config = AutoConfig.from_pretrained(MODEL_PATH)
config.gradient_checkpointing = True


tokenizer = AutoTokenizer.from_pretrained(MODEL_PATH)

model = AutoModelForCausalLM.from_pretrained(
    MODEL_PATH,
    device_map=""auto"",
    torch_dtype=""auto"",
    trust_remote_code=True,
#     quantization_config=quantization_config,
    config=config
)
model.dtype
import pandas as pd
from tqdm import tqdm
PRIVATE = True

df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/test.csv')
df.head()
if len(df) < 5:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    PRIVATE = False
df.head()
import gc
device = 'cuda'
def naive_parse(answer):
    out = []
    start = False
    end = False
    for l in reversed(list(answer)):
        if l in '0123456789' and not end:
            start = True
            out.append(l)
        else:
            if start:
                end = True
        
    out = reversed(out)
    return ''.join(out)
import transformers

pipeline = transformers.pipeline(
    ""text-generation"",
    model=model,
    tokenizer=tokenizer,
    torch_dtype='auto',
    device_map=""auto"",
)
print(f""Transformers Version: {transformers.__version__}"")
import torch

torch.backends.cuda.enable_mem_efficient_sdp(False)
import re
import sys
import subprocess


def process_output(output):
    result = output
    
    try:
        code = output.split('```')[1][7:]

        with open('code.py', 'w') as fout:
            fout.write(code)

        batcmd = 'timeout 7 ' + sys.executable + ' code.py'
        try:
            shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
            print(shell_output)
            code_output = round(float(eval(shell_output))) % 1000
        except:
            code_output = -1

        print('CODE RESULTS', code_output)
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        code_output = -1
    
    try:
        result_output = re.findall(r'\\boxed\{(.*)\}', result)

        print('BOXED', result_output)
        if not len(result_output):
            result_output = naive_parse(result)
        else:
            result_output = result_output[-1]

        print('BOXED', result_output)
        if not len(result_output):
            result_output = -1
        
        else:
            result_output = round(float(eval(result_output))) % 1000
    
    except Exception as e:
        print(e)
        print('ERROR PARSING')
        result_output = -1
    
    return result_output, code_output
import re
from collections import defaultdict


tool_instruction = "" The answer should be given as a non-negative modulo 1000.""
tool_instruction += '\nPlease integrate natural language reasoning with programs to solve the problem above, and put your final answer within \\boxed{}.'


n_repetitions = 8 if PRIVATE else 2

total_results = []
total_answers = []

for i in tqdm(range(len(df))):
    id_ = df['id'].loc[i]
    problem = df['problem'].loc[i]
    
    messages = [
        {
            ""role"": ""user"", 
            ""content"": problem + tool_instruction
        }
    ]
    
    query_prompt = tokenizer.apply_chat_template(
        messages,
        tokenize=False
    )
    
    results = []
    answers = []
    
    for _ in tqdm(range(n_repetitions)):
        try:lo
            raw_output = pipeline(
                query_prompt, 
                max_new_tokens=2048, 
                do_sample=True, 
                temperature=0.8964,
                return_full_text=False
            )
            raw_output = raw_output[0]['generated_text']

            result_output, code_output = process_output(raw_output)

            torch.cuda.empty_cache()
            gc.collect()

        except Exception as e:
            print(e)
            result_output, code_output = -1, -1
        
        results.append(result_output)
        answers.append(code_output)
    
    total_results.append(results)
    total_answers.append(answers)
import numpy as np
from collections import Counter

final_answers = []

for a, b in zip(total_answers, total_results):
    a = np.array(a)
    b = np.array(b)
    a[a < 0] = b[a < 0]
    
    pred = Counter(a.tolist()).most_common(2)

    ans = pred[0][0] if not pred[0][0] < 0 else pred[1][0]

    final_answers.append(ans)
    print(ans)

df['answer'] = final_answers
df
df[['id','answer']].to_csv(""submission.csv"", header=True, index=False)
df[['id','answer']].head()
if not PRIVATE:
    df = pd.read_csv('/kaggle/input/ai-mathematical-olympiad-prize/train.csv')
    df['model_answer'] = final_answers
    df['match'] = df.answer == df.model_answer
    print(f'{df.match.sum()} matches in {len(df)} examples')
with open('code.py', 'w') as fout:
    fout.write(""print('done')"")

batcmd = 'timeout 7 ' + sys.executable + ' code.py'
try:
    shell_output = subprocess.check_output(batcmd, shell=True).decode('utf8')
    print(shell_output)
except:
    pass
","# Zero-shot MMOS-DeepSeekMath-7B with self-consistency and generated code reasoning evaluation

Self-consistency is a modification of the standard greedy decoding in reasoning pipelines via sampling several diverse answers followed by aggregation, e.g., most common answer ([SC-CoT paper](https://arxiv.org/pdf/2203.11171.pdf)).

In this kernel, we will consider MMOS-DeepSeekMath-7B RL-tuned backbone; in my experiments, this model produces more consistent code reasoning and the code block execution will allow us to decrease arithmetic hallucinations.
","['AI Mathematical Olympiad - Progress Prize 1', 'bitsandbytes-0.42.0-py3-none-any.whl', 'deepseek-math', 'open-math-mistral']","['torch', 'transformers', 'pandas', 'tqdm', 'gc', 're', 'sys', 'subprocess', 'collections', 'numpy']","Here are the unique aspects of the Machine Learning code written in Python:

1. **Pre-trained Model**: The code uses a pre-trained AutoModelForCausalLM model, which is a type of transformer-based language model that can be fine-tuned for specific tasks.

2. **Text Generation Pipeline**: A text generation pipeline is created using the Hugging Face Transformers library, which allows for generating text based on user input and prompts.

3. **Custom Tokenizer**: The code uses a custom tokenizer to preprocess the input text and generate output.

4. **Memory-Efficient Cuda**: The code enables memory-efficient CUDA operations to improve performance when working with large datasets on NVIDIA GPUs.

5. **Error Handling**: The code includes robust error handling mechanisms, such as try-except blocks, to handle exceptions and errors that may occur during the processing of input data.

6. **Modular Code Organization**: The code is organized into modular sections, each responsible for a specific task or functionality, making it easier to maintain and update.

7. **Data Preprocessing**: The code includes data preprocessing steps, such as reading in CSV files, handling missing values, and converting data types, to prepare the input data for processing.

8. **Repetition and Sampling**: The code uses repetition and sampling techniques to generate multiple output responses for each input prompt, which can be useful for tasks that require generating diverse output options.

9. **Counter-Based Frequency Analysis**: The code uses the Counter class from the collections module to analyze the frequency of generated output responses and identify the most common ones.

10. **Submission Generation**: The code generates a submission file in CSV format based on the final answers, which can be used for evaluation or competition purposes.

These unique aspects demonstrate the complexity and sophistication of the Machine Learning code written in Python, highlighting its ability to process natural language input, generate text output, and handle errors and exceptions."
